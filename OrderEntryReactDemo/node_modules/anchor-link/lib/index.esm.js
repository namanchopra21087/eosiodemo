import e from"pako";import{Struct as t,UInt64 as s,Serializer as i,Bytes as r,Checksum256 as n,PermissionLevel as a,PublicKey as o,Name as c,PrivateKey as l,APIClient as h,Signature as u,SignedTransaction as p}from"@greymass/eosio";import{ChainId as d,SigningRequest as f,ResolvedSigningRequest as m,PlaceholderName as y,PlaceholderPermission as g}from"eosio-signing-request";export{PlaceholderAuth,PlaceholderName,PlaceholderPermission}from"eosio-signing-request";import w from"fetch-ponyfill";import{AES_CBC as k}from"asmcrypto.js";import{v4 as b}from"uuid";import S from"isomorphic-ws";function v(){return(v=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(e[i]=s[i])}return e}).apply(this,arguments)}class _ extends Error{constructor(e){super("User canceled request "+(e?"("+e+")":"")),this.code="E_CANCEL"}}class q extends Error{constructor(e){super("Unable to verify identity "+(e?"("+e+")":"")),this.code="E_IDENTITY"}}class x extends Error{constructor(e,t){super(e),this.code=t}}var E;function P(e,t,s,i){var r,n=arguments.length,a=n<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,s):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,s,i);else for(var o=e.length-1;o>=0;o--)(r=e[o])&&(a=(n<3?r(a):n>3?r(t,s,a):r(t,s))||a);return n>3&&a&&Object.defineProperty(t,s,a),a}!function(e){e.defaults={chainId:"aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906",client:"https://eos.greymass.com",service:"https://cb.anchor.link"}}(E||(E={}));let O=class extends t{};P([t.field("public_key")],O.prototype,"from",void 0),P([t.field("uint64")],O.prototype,"nonce",void 0),P([t.field("bytes")],O.prototype,"ciphertext",void 0),P([t.field("uint32")],O.prototype,"checksum",void 0),O=P([t.type("sealed_message")],O);let K=class extends t{};P([t.field("name")],K.prototype,"session_name",void 0),P([t.field("public_key")],K.prototype,"request_key",void 0),K=P([t.type("link_create")],K);let I=class extends t{};P([t.field("time_point_sec")],I.prototype,"expiration",void 0),I=P([t.type("link_info")],I);const R=w().fetch;class T{async remove(){this.link.storage&&await this.link.removeSession(this.identifier,this.auth)}static restore(e,t){switch(t.type){case"channel":return new N(e,t.data,t.metadata);case"fallback":return new U(e,t.data,t.metadata);default:throw new Error("Unable to restore, session data invalid")}}}class N extends T{constructor(e,t,h){super(),this.type="channel",this.timeout=12e4,this.link=e,this.auth=a.from(t.auth),this.publicKey=o.from(t.publicKey),this.channel=t.channel,this.identifier=c.from(t.identifier);const u=l.from(t.requestKey),p=o.from(t.channel.key);this.encrypt=e=>function(e,t,a,o){const c=t.sharedSecret(a);o||(o=s.random());const l=i.encode({object:o}).appending(c.array).sha512Digest,h=new k(l.array.slice(0,32),l.array.slice(32,48)),u=r.from(h.encrypt(r.from(e,"utf8").array)),p=new DataView(n.hash(l.array).array.buffer).getUint32(0,!0);return O.from({from:t.toPublic(),nonce:o,ciphertext:u,checksum:p})}(e.encode(!0,!1),u,p),this.metadata=v({},h||{},{timeout:this.timeout,name:this.channel.name}),this.serialize=()=>({type:"channel",data:t,metadata:this.metadata})}onSuccess(e,t){this.link.transport.onSuccess&&this.link.transport.onSuccess(e,t)}onFailure(e,t){this.link.transport.onFailure&&this.link.transport.onFailure(e,t)}onRequest(e,t){const s=I.from({expiration:new Date(Date.now()+this.timeout).toISOString().slice(0,-1)});this.link.transport.onSessionRequest&&this.link.transport.onSessionRequest(this,e,t),setTimeout(()=>{t(new x("Wallet did not respond in time","E_TIMEOUT"))},this.timeout+500),e.setInfoKey("link",s),R(this.channel.url,{method:"POST",headers:{"X-Buoy-Wait":(this.timeout/1e3).toFixed(0)},body:i.encode({object:this.encrypt(e)}).array}).then(e=>{200!==e.status&&t(new x("Unable to push message","E_DELIVERY"))}).catch(e=>{t(new x(`Unable to reach link service (${e.message||String(e)})`,"E_DELIVERY"))})}prepare(e){return this.link.transport.prepare?this.link.transport.prepare(e,this):Promise.resolve(e)}showLoading(){if(this.link.transport.showLoading)return this.link.transport.showLoading()}makeSignatureProvider(){return this.link.makeSignatureProvider([this.publicKey.toString()],this)}transact(e,t){return this.link.transact(e,t,this)}}class U extends T{constructor(e,t,s){super(),this.type="fallback",this.link=e,this.auth=a.from(t.auth),this.publicKey=o.from(t.publicKey),this.metadata=s||{},this.identifier=c.from(t.identifier),this.serialize=()=>({type:this.type,data:t,metadata:this.metadata})}onSuccess(e,t){this.link.transport.onSuccess&&this.link.transport.onSuccess(e,t)}onFailure(e,t){this.link.transport.onFailure&&this.link.transport.onFailure(e,t)}onRequest(e,t){this.link.transport.onSessionRequest?this.link.transport.onSessionRequest(this,e,t):this.link.transport.onRequest(e,t)}prepare(e){return this.link.transport.prepare?this.link.transport.prepare(e,this):Promise.resolve(e)}showLoading(){if(this.link.transport.showLoading)return this.link.transport.showLoading()}makeSignatureProvider(){return this.link.makeSignatureProvider([this.publicKey.toString()],this)}transact(e,t){return this.link.transact(e,t,this)}}class j{constructor(e){this.address=e.trim().replace(/\/$/,"")}create(){const e=`${this.address}/${b()}`;return new $(e)}}class ${constructor(e){this.url=e,this.ctx={}}wait(){return this.url.includes("hyperbuoy")?async function(e,t){let s=!0;for(t.cancel=()=>{s=!1};s;){try{const t=await R(e);if(408===t.status)continue;if(200===t.status)return await t.json();throw new Error(`HTTP ${t.status}: ${t.statusText}`)}catch(e){console.warn("Unexpected hyperbuoy error",e)}await D(1e3)}return new Promise(()=>{})}(this.url,this.ctx):(e=this.url,t=this.ctx,new Promise((s,i)=>{let r=!0,n=0;const a=e.replace(/^http/,"ws"),o=e=>{try{s(JSON.parse(e))}catch(e){e.message="Unable to parse callback JSON: "+e.message,i(e)}},c=()=>{const e=new S(a);t.cancel=()=>{r=!1,e.readyState!==S.OPEN&&e.readyState!==S.CONNECTING||e.close()},e.onmessage=t=>{if(r=!1,e.readyState===S.OPEN&&e.close(),"undefined"!=typeof Blob&&t.data instanceof Blob){const e=new FileReader;e.onload=()=>{o(e.result)},e.onerror=e=>{i(e)},e.readAsText(t.data)}else o("string"==typeof t.data?t.data:t.data.toString())},e.onopen=()=>{n=0},e.onclose=()=>{var e;r&&setTimeout(c,(e=n++,Math.min(Math.pow(10*e,2),1e4)))}};c()}));var e,t}cancel(){this.ctx.cancel&&this.ctx.cancel()}}function D(e){return new Promise(t=>{setTimeout(t,e)})}class L{constructor(t){if(this.abiCache=new Map,this.pendingAbis=new Map,"object"!=typeof t)throw new TypeError("Missing options object");if(!t.transport)throw new TypeError("options.transport is required, see https://github.com/greymass/anchor-link#transports");this.client=void 0===t.client||"string"==typeof t.client?new h({url:t.client||E.defaults.client}):t.client,this.chainId=d.from(t.chainId||E.defaults.chainId),this.callbackService=void 0===t.service||"string"==typeof t.service?new j(t.service||E.defaults.service):t.service,this.transport=t.transport,null!==t.storage&&(this.storage=t.storage||this.transport.storage),this.requestOptions={abiProvider:this,zlib:e}}async getAbi(e){const t=e.toString();let s=this.abiCache.get(t);if(!s){let i=this.pendingAbis.get(t);i||(i=this.client.v1.chain.get_abi(e),this.pendingAbis.set(t,i)),s=(await i).abi,this.pendingAbis.delete(t),s&&this.abiCache.set(t,s)}return s}async createRequest(e,t){const s=t||this.transport;let i=await f.create(v({},e,{chainId:this.chainId.toString(),broadcast:!1}),this.requestOptions);s.prepare&&(i=await s.prepare(i));const r=this.callbackService.create();return i.setCallback(r.url,!0),{request:i,callback:r}}async sendRequest(e,t,s,i=!1){const r=s||this.transport;try{if(e.data.callback!==t.url)throw new Error("Invalid request callback");if(!0===e.data.flags.broadcast||!1===e.data.flags.background)throw new Error("Invalid request flags");const s=new Promise((s,i)=>{r.onRequest(e,e=>{t.cancel(),i("string"==typeof e?new _(e):e)})}),n=await Promise.race([t.wait(),s]);if("string"==typeof n.rejected)throw new _(n.rejected);const o=n,c=a.from({actor:o.sa,permission:o.sp}),l=Object.keys(o).filter(e=>e.startsWith("sig")&&"sig0"!==e).map(e=>u.from(o[e])),h=await m.fromPayload(o,this.requestOptions),d=h.request.getInfoKey("fuel_sig","string");d&&l.unshift(u.from(d));const f={request:h.request,transaction:h.transaction,resolvedTransaction:h.resolvedTransaction,signatures:l,payload:o,signer:c};if(i){const e=p.from(v({},h.transaction,{signatures:l})),t=await this.client.v1.chain.push_transaction(e);f.processed=t.processed}return r.onSuccess&&r.onSuccess(e,f),f}catch(t){throw r.onFailure&&r.onFailure(e,t),t}}async transact(e,t,s){const i=s||this.transport,r=!t||!1!==t.broadcast;i&&i.showLoading&&i.showLoading(),e.actions&&(e.expiration||e.ref_block_num||e.ref_block_prefix||e.max_net_usage_words||e.max_cpu_usage_ms||e.delay_sec)&&(e={transaction:v({expiration:"1970-01-01T00:00:00",ref_block_num:0,ref_block_prefix:0,max_net_usage_words:0,max_cpu_usage_ms:0,delay_sec:0},e)});const{request:n,callback:a}=await this.createRequest(e,i);return await this.sendRequest(n,a,i,r)}async identify(e){const{request:t,callback:s}=await this.createRequest({identity:{permission:e.requestPermission,scope:e.scope},info:e.info}),i=await this.sendRequest(t,s);if(!i.request.isIdentity())throw new q("Unexpected response");const r=i.transaction.signingDigest(t.getChainId()),n=i.signatures[0].recoverDigest(r),{signer:o}=i,c=await this.client.v1.chain.get_account(o.actor);if(!c)throw new q("Signature from unknown account: "+o.actor);const l=c.permissions.find(({perm_name:e})=>o.permission.equals(e));if(!l)throw new q(`${o.actor} signed for unknown permission: ${o.permission}`);const h=l.required_auth,u=h.keys.find(({key:e})=>n.equals(e));if(!u)throw new q(`${C(o)} has no key matching id signature (${n})`);if(h.threshold>u.weight)throw new q(C(o)+" signature does not reach auth threshold");if(e.requestPermission){const t=a.from(e.requestPermission);if(!t.actor.equals(y)&&!t.actor.equals(o.actor)||!t.permission.equals(g)&&!t.permission.equals(o.permission))throw new q(`Unexpected identity proof from ${C(o)}, expected ${C(t)} `)}return v({},i,{account:c,signerKey:n})}async login(e){const t=l.generate("K1"),s=t.toPublic(),i=K.from({session_name:e,request_key:s}),r=await this.identify({scope:e,info:{link:i,scope:e}}),n={sameDevice:void 0!==r.request.getRawInfo().return_path};let a;return a=r.payload.link_ch&&r.payload.link_key&&r.payload.link_name?new N(this,{identifier:e,auth:r.signer,publicKey:r.signerKey,channel:{url:r.payload.link_ch,key:r.payload.link_key,name:r.payload.link_name},requestKey:t},n):new U(this,{identifier:e,auth:r.signer,publicKey:r.signerKey},n),this.storage&&await this.storeSession(e,a),v({},r,{session:a})}async restoreSession(e,t){if(!this.storage)throw new Error("Unable to restore session: No storage adapter configured");let s;if(t)s=this.sessionKey(e,C(t));else{const t=(await this.listSessions(e))[0];if(!t)return null;s=this.sessionKey(e,C(t))}const i=await this.storage.read(s);if(!i)return null;let r;try{r=JSON.parse(i)}catch(e){throw new Error(`Unable to restore session: Stored JSON invalid (${e.message||String(e)})`)}const n=T.restore(this,r);return t&&await this.touchSession(e,t),n}async listSessions(e){if(!this.storage)throw new Error("Unable to list sessions: No storage adapter configured");const t=this.sessionKey(e,"list");let s;try{s=JSON.parse(await this.storage.read(t)||"[]")}catch(e){throw new Error(`Unable to list sessions: Stored JSON invalid (${e.message||String(e)})`)}return s}async removeSession(e,t){if(!this.storage)throw new Error("Unable to remove session: No storage adapter configured");const s=this.sessionKey(e,C(t));await this.storage.remove(s),await this.touchSession(e,t,!0)}async clearSessions(e){if(!this.storage)throw new Error("Unable to clear sessions: No storage adapter configured");for(const t of await this.listSessions(e))await this.removeSession(e,t)}makeSignatureProvider(e,t){var s=this;return{getAvailableKeys:async function(){return e},sign:async function(e){const r=t||s.transport;let n=f.fromTransaction(e.chainId,e.serializedTransaction,s.requestOptions);const a=s.callbackService.create();n.setCallback(a.url,!0),n.setBroadcast(!1),r.prepare&&(n=await r.prepare(n));const{transaction:o,signatures:c}=await s.sendRequest(n,a,r);return v({},e,{serializedTransaction:i.encode({object:o}),signatures:c})}}}async touchSession(e,t,s=!1){const i=await this.listSessions(e),r=C(t),n=i.findIndex(e=>C(e)===r);n>=0&&i.splice(n,1),!1===s&&i.unshift(t);const a=this.sessionKey(e,"list");await this.storage.write(a,JSON.stringify(i))}async storeSession(e,t){const s=this.sessionKey(e,C(t.auth)),i=JSON.stringify(t.serialize());await this.storage.write(s,i),await this.touchSession(e,t.auth)}sessionKey(e,t){return[this.chainId.toString(),c.from(e).toString(),t].join("-")}}function C(e){const t=a.from(e),s=t.actor.equals(y)?"<any>":String(t.actor);let i;return i=t.permission.equals(y)||t.permission.equals(g)?"<any>":String(t.permission),`${s}@${i}`}export default L;export{_ as CancelError,q as IdentityError,L as Link,N as LinkChannelSession,U as LinkFallbackSession,E as LinkOptions,T as LinkSession,x as SessionError};
//# sourceMappingURL=index.esm.js.map
