{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar ecdsa = require('./ecdsa');\n\nvar hash = require('./hash');\n\nvar curve = require('ecurve').getCurveByName('secp256k1');\n\nvar assert = require('assert');\n\nvar BigInteger = require('bigi');\n\nvar keyUtils = require('./key_utils');\n\nvar PublicKey = require('./key_public');\n\nvar PrivateKey = require('./key_private');\n\nmodule.exports = Signature;\n\nfunction Signature(r, s, i) {\n  assert.equal(r != null, true, 'Missing parameter');\n  assert.equal(s != null, true, 'Missing parameter');\n  assert.equal(i != null, true, 'Missing parameter');\n  /**\n      Verify signed data.\n       @arg {String|Buffer} data - full data\n      @arg {pubkey|PublicKey} pubkey - EOSKey..\n      @arg {String} [encoding = 'utf8'] - data encoding (if data is a string)\n       @return {boolean}\n  */\n\n  function verify(data, pubkey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (typeof data === 'string') {\n      data = Buffer.from(data, encoding);\n    }\n\n    assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n    data = hash.sha256(data);\n    return verifyHash(data, pubkey);\n  }\n  /**\n      Verify a buffer of exactally 32 bytes in size (sha256(text))\n       @arg {String|Buffer} dataSha256 - 32 byte buffer or string\n      @arg {String|PublicKey} pubkey - EOSKey..\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {boolean}\n  */\n\n\n  function verifyHash(dataSha256, pubkey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n    if (typeof dataSha256 === 'string') {\n      dataSha256 = Buffer.from(dataSha256, encoding);\n    }\n\n    if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 bytes required\");\n    var publicKey = PublicKey(pubkey);\n    assert(publicKey, 'pubkey required');\n    return ecdsa.verify(curve, dataSha256, {\n      r: r,\n      s: s\n    }, publicKey.Q);\n  }\n\n  ;\n  /** @deprecated\n       Verify hex data by converting to a buffer then hashing.\n       @return {boolean}\n  */\n\n  function verifyHex(hex, pubkey) {\n    console.log('Deprecated: use verify(data, pubkey, \"hex\")');\n    var buf = Buffer.from(hex, 'hex');\n    return verify(buf, pubkey);\n  }\n\n  ;\n  /**\n      Recover the public key used to create this signature using full data.\n       @arg {String|Buffer} data - full data\n      @arg {String} [encoding = 'utf8'] - data encoding (if string)\n       @return {PublicKey}\n  */\n\n  function recover(data) {\n    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';\n\n    if (typeof data === 'string') {\n      data = Buffer.from(data, encoding);\n    }\n\n    assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n    data = hash.sha256(data);\n    return recoverHash(data);\n  }\n\n  ;\n  /**\n      @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or hex string\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {PublicKey}\n  */\n\n  function recoverHash(dataSha256) {\n    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n\n    if (typeof dataSha256 === 'string') {\n      dataSha256 = Buffer.from(dataSha256, encoding);\n    }\n\n    if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) {\n      throw new Error(\"dataSha256: 32 byte String or buffer requred\");\n    }\n\n    var e = BigInteger.fromBuffer(dataSha256);\n    var i2 = i;\n    i2 -= 27;\n    i2 = i2 & 3;\n    var Q = ecdsa.recoverPubKey(curve, e, {\n      r: r,\n      s: s,\n      i: i\n    }, i2);\n    return PublicKey.fromPoint(Q);\n  }\n\n  ;\n\n  function toBuffer() {\n    var buf;\n    buf = new Buffer(65);\n    buf.writeUInt8(i, 0);\n    r.toBuffer(32).copy(buf, 1);\n    s.toBuffer(32).copy(buf, 33);\n    return buf;\n  }\n\n  ;\n\n  function toHex() {\n    return toBuffer().toString(\"hex\");\n  }\n\n  ;\n  var signatureCache;\n\n  function toString() {\n    if (signatureCache) {\n      return signatureCache;\n    }\n\n    signatureCache = 'SIG_K1_' + keyUtils.checkEncode(toBuffer(), 'K1');\n    return signatureCache;\n  }\n\n  return {\n    r: r,\n    s: s,\n    i: i,\n    toBuffer: toBuffer,\n    verify: verify,\n    verifyHash: verifyHash,\n    verifyHex: verifyHex,\n    // deprecated\n    recover: recover,\n    recoverHash: recoverHash,\n    toHex: toHex,\n    toString: toString,\n\n    /** @deprecated use verify (same arguments and return) */\n    verifyBuffer: function verifyBuffer() {\n      console.log('Deprecated: use signature.verify instead (same arguments)');\n      return verify.apply(void 0, arguments);\n    },\n\n    /** @deprecated use recover (same arguments and return) */\n    recoverPublicKey: function recoverPublicKey() {\n      console.log('Deprecated: use signature.recover instead (same arguments)');\n      return recover.apply(void 0, arguments);\n    },\n\n    /** @deprecated use recoverHash (same arguments and return) */\n    recoverPublicKeyFromBuffer: function recoverPublicKeyFromBuffer() {\n      console.log('Deprecated: use signature.recoverHash instead (same arguments)');\n      return recoverHash.apply(void 0, arguments);\n    }\n  };\n}\n/**\n    Hash and sign arbitrary data.\n\n    @arg {string|Buffer} data - full data\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'utf8'] - data encoding (if string)\n\n    @return {Signature}\n*/\n\n\nSignature.sign = function (data, privateKey) {\n  var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n  if (typeof data === 'string') {\n    data = Buffer.from(data, encoding);\n  }\n\n  assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n  data = hash.sha256(data);\n  return Signature.signHash(data, privateKey);\n};\n/**\n    Sign a buffer of exactally 32 bytes in size (sha256(text))\n\n    @arg {string|Buffer} dataSha256 - 32 byte buffer or string\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n\n    @return {Signature}\n*/\n\n\nSignature.signHash = function (dataSha256, privateKey) {\n  var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n  if (typeof dataSha256 === 'string') {\n    dataSha256 = Buffer.from(dataSha256, encoding);\n  }\n\n  if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 byte buffer requred\");\n  privateKey = PrivateKey(privateKey);\n  assert(privateKey, 'privateKey required');\n  var der, e, ecsignature, i, lenR, lenS, nonce;\n  i = null;\n  nonce = 0;\n  e = BigInteger.fromBuffer(dataSha256);\n\n  while (true) {\n    ecsignature = ecdsa.sign(curve, dataSha256, privateKey.d, nonce++);\n    der = ecsignature.toDER();\n    lenR = der[3];\n    lenS = der[5 + lenR];\n\n    if (lenR === 32 && lenS === 32) {\n      i = ecdsa.calcPubKeyRecoveryParam(curve, e, ecsignature, privateKey.toPublic().Q);\n      i += 4; // compressed\n\n      i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)\n\n      break;\n    }\n\n    if (nonce % 10 === 0) {\n      console.log(\"WARN: \" + nonce + \" attempts to find canonical signature\");\n    }\n  }\n\n  return Signature(ecsignature.r, ecsignature.s, i);\n};\n\nSignature.fromBuffer = function (buf) {\n  var i, r, s;\n  assert(Buffer.isBuffer(buf), 'Buffer is required');\n  assert.equal(buf.length, 65, 'Invalid signature length');\n  i = buf.readUInt8(0);\n  assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');\n  r = BigInteger.fromBuffer(buf.slice(1, 33));\n  s = BigInteger.fromBuffer(buf.slice(33));\n  return Signature(r, s, i);\n};\n\nSignature.fromHex = function (hex) {\n  return Signature.fromBuffer(Buffer.from(hex, \"hex\"));\n};\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @return {Signature} or `null` (invalid)\n*/\n\n\nSignature.fromString = function (signature) {\n  try {\n    return Signature.fromStringOrThrow(signature);\n  } catch (e) {\n    return null;\n  }\n};\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @throws {Error} invalid\n    @return {Signature}\n*/\n\n\nSignature.fromStringOrThrow = function (signature) {\n  assert.equal((0, _typeof2[\"default\"])(signature), 'string', 'signature');\n  var match = signature.match(/^SIG_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n  assert(match != null && match.length === 3, 'Expecting signature like: SIG_K1_base58signature..');\n\n  var _match = (0, _slicedToArray2[\"default\"])(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 signature expected');\n  return Signature.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n/**\n    @arg {String|Signature} o - hex string\n    @return {Signature}\n*/\n\n\nSignature.from = function (o) {\n  var signature = o ? o.r && o.s && o.i ? o : typeof o === 'string' && o.length === 130 ? Signature.fromHex(o) : typeof o === 'string' && o.length !== 130 ? Signature.fromStringOrThrow(o) : Buffer.isBuffer(o) ? Signature.fromBuffer(o) : null : o;\n  /*null or undefined*/\n\n  if (!signature) {\n    throw new TypeError('signature should be a hex string or buffer');\n  }\n\n  return signature;\n};","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosjs-ecc/lib/signature.js"],"names":["_interopRequireDefault","require","_slicedToArray2","_typeof2","ecdsa","hash","curve","getCurveByName","assert","BigInteger","keyUtils","PublicKey","PrivateKey","module","exports","Signature","r","s","i","equal","verify","data","pubkey","encoding","arguments","length","undefined","Buffer","from","isBuffer","sha256","verifyHash","dataSha256","Error","publicKey","Q","verifyHex","hex","console","log","buf","recover","recoverHash","e","fromBuffer","i2","recoverPubKey","fromPoint","toBuffer","writeUInt8","copy","toHex","toString","signatureCache","checkEncode","verifyBuffer","apply","recoverPublicKey","recoverPublicKeyFromBuffer","sign","privateKey","signHash","der","ecsignature","lenR","lenS","nonce","d","toDER","calcPubKeyRecoveryParam","toPublic","readUInt8","slice","fromHex","fromString","signature","fromStringOrThrow","match","_match","keyType","keyString","checkDecode","o","TypeError"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar ecdsa = require('./ecdsa');\n\nvar hash = require('./hash');\n\nvar curve = require('ecurve').getCurveByName('secp256k1');\n\nvar assert = require('assert');\n\nvar BigInteger = require('bigi');\n\nvar keyUtils = require('./key_utils');\n\nvar PublicKey = require('./key_public');\n\nvar PrivateKey = require('./key_private');\n\nmodule.exports = Signature;\n\nfunction Signature(r, s, i) {\n  assert.equal(r != null, true, 'Missing parameter');\n  assert.equal(s != null, true, 'Missing parameter');\n  assert.equal(i != null, true, 'Missing parameter');\n  /**\n      Verify signed data.\n       @arg {String|Buffer} data - full data\n      @arg {pubkey|PublicKey} pubkey - EOSKey..\n      @arg {String} [encoding = 'utf8'] - data encoding (if data is a string)\n       @return {boolean}\n  */\n\n  function verify(data, pubkey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (typeof data === 'string') {\n      data = Buffer.from(data, encoding);\n    }\n\n    assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n    data = hash.sha256(data);\n    return verifyHash(data, pubkey);\n  }\n  /**\n      Verify a buffer of exactally 32 bytes in size (sha256(text))\n       @arg {String|Buffer} dataSha256 - 32 byte buffer or string\n      @arg {String|PublicKey} pubkey - EOSKey..\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {boolean}\n  */\n\n\n  function verifyHash(dataSha256, pubkey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n    if (typeof dataSha256 === 'string') {\n      dataSha256 = Buffer.from(dataSha256, encoding);\n    }\n\n    if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 bytes required\");\n    var publicKey = PublicKey(pubkey);\n    assert(publicKey, 'pubkey required');\n    return ecdsa.verify(curve, dataSha256, {\n      r: r,\n      s: s\n    }, publicKey.Q);\n  }\n\n  ;\n  /** @deprecated\n       Verify hex data by converting to a buffer then hashing.\n       @return {boolean}\n  */\n\n  function verifyHex(hex, pubkey) {\n    console.log('Deprecated: use verify(data, pubkey, \"hex\")');\n    var buf = Buffer.from(hex, 'hex');\n    return verify(buf, pubkey);\n  }\n\n  ;\n  /**\n      Recover the public key used to create this signature using full data.\n       @arg {String|Buffer} data - full data\n      @arg {String} [encoding = 'utf8'] - data encoding (if string)\n       @return {PublicKey}\n  */\n\n  function recover(data) {\n    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';\n\n    if (typeof data === 'string') {\n      data = Buffer.from(data, encoding);\n    }\n\n    assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n    data = hash.sha256(data);\n    return recoverHash(data);\n  }\n\n  ;\n  /**\n      @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or hex string\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {PublicKey}\n  */\n\n  function recoverHash(dataSha256) {\n    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n\n    if (typeof dataSha256 === 'string') {\n      dataSha256 = Buffer.from(dataSha256, encoding);\n    }\n\n    if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) {\n      throw new Error(\"dataSha256: 32 byte String or buffer requred\");\n    }\n\n    var e = BigInteger.fromBuffer(dataSha256);\n    var i2 = i;\n    i2 -= 27;\n    i2 = i2 & 3;\n    var Q = ecdsa.recoverPubKey(curve, e, {\n      r: r,\n      s: s,\n      i: i\n    }, i2);\n    return PublicKey.fromPoint(Q);\n  }\n\n  ;\n\n  function toBuffer() {\n    var buf;\n    buf = new Buffer(65);\n    buf.writeUInt8(i, 0);\n    r.toBuffer(32).copy(buf, 1);\n    s.toBuffer(32).copy(buf, 33);\n    return buf;\n  }\n\n  ;\n\n  function toHex() {\n    return toBuffer().toString(\"hex\");\n  }\n\n  ;\n  var signatureCache;\n\n  function toString() {\n    if (signatureCache) {\n      return signatureCache;\n    }\n\n    signatureCache = 'SIG_K1_' + keyUtils.checkEncode(toBuffer(), 'K1');\n    return signatureCache;\n  }\n\n  return {\n    r: r,\n    s: s,\n    i: i,\n    toBuffer: toBuffer,\n    verify: verify,\n    verifyHash: verifyHash,\n    verifyHex: verifyHex,\n    // deprecated\n    recover: recover,\n    recoverHash: recoverHash,\n    toHex: toHex,\n    toString: toString,\n\n    /** @deprecated use verify (same arguments and return) */\n    verifyBuffer: function verifyBuffer() {\n      console.log('Deprecated: use signature.verify instead (same arguments)');\n      return verify.apply(void 0, arguments);\n    },\n\n    /** @deprecated use recover (same arguments and return) */\n    recoverPublicKey: function recoverPublicKey() {\n      console.log('Deprecated: use signature.recover instead (same arguments)');\n      return recover.apply(void 0, arguments);\n    },\n\n    /** @deprecated use recoverHash (same arguments and return) */\n    recoverPublicKeyFromBuffer: function recoverPublicKeyFromBuffer() {\n      console.log('Deprecated: use signature.recoverHash instead (same arguments)');\n      return recoverHash.apply(void 0, arguments);\n    }\n  };\n}\n/**\n    Hash and sign arbitrary data.\n\n    @arg {string|Buffer} data - full data\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'utf8'] - data encoding (if string)\n\n    @return {Signature}\n*/\n\n\nSignature.sign = function (data, privateKey) {\n  var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n  if (typeof data === 'string') {\n    data = Buffer.from(data, encoding);\n  }\n\n  assert(Buffer.isBuffer(data), 'data is a required String or Buffer');\n  data = hash.sha256(data);\n  return Signature.signHash(data, privateKey);\n};\n/**\n    Sign a buffer of exactally 32 bytes in size (sha256(text))\n\n    @arg {string|Buffer} dataSha256 - 32 byte buffer or string\n    @arg {wif|PrivateKey} privateKey\n    @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n\n    @return {Signature}\n*/\n\n\nSignature.signHash = function (dataSha256, privateKey) {\n  var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n\n  if (typeof dataSha256 === 'string') {\n    dataSha256 = Buffer.from(dataSha256, encoding);\n  }\n\n  if (dataSha256.length !== 32 || !Buffer.isBuffer(dataSha256)) throw new Error(\"dataSha256: 32 byte buffer requred\");\n  privateKey = PrivateKey(privateKey);\n  assert(privateKey, 'privateKey required');\n  var der, e, ecsignature, i, lenR, lenS, nonce;\n  i = null;\n  nonce = 0;\n  e = BigInteger.fromBuffer(dataSha256);\n\n  while (true) {\n    ecsignature = ecdsa.sign(curve, dataSha256, privateKey.d, nonce++);\n    der = ecsignature.toDER();\n    lenR = der[3];\n    lenS = der[5 + lenR];\n\n    if (lenR === 32 && lenS === 32) {\n      i = ecdsa.calcPubKeyRecoveryParam(curve, e, ecsignature, privateKey.toPublic().Q);\n      i += 4; // compressed\n\n      i += 27; // compact  //  24 or 27 :( forcing odd-y 2nd key candidate)\n\n      break;\n    }\n\n    if (nonce % 10 === 0) {\n      console.log(\"WARN: \" + nonce + \" attempts to find canonical signature\");\n    }\n  }\n\n  return Signature(ecsignature.r, ecsignature.s, i);\n};\n\nSignature.fromBuffer = function (buf) {\n  var i, r, s;\n  assert(Buffer.isBuffer(buf), 'Buffer is required');\n  assert.equal(buf.length, 65, 'Invalid signature length');\n  i = buf.readUInt8(0);\n  assert.equal(i - 27, i - 27 & 7, 'Invalid signature parameter');\n  r = BigInteger.fromBuffer(buf.slice(1, 33));\n  s = BigInteger.fromBuffer(buf.slice(33));\n  return Signature(r, s, i);\n};\n\nSignature.fromHex = function (hex) {\n  return Signature.fromBuffer(Buffer.from(hex, \"hex\"));\n};\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @return {Signature} or `null` (invalid)\n*/\n\n\nSignature.fromString = function (signature) {\n  try {\n    return Signature.fromStringOrThrow(signature);\n  } catch (e) {\n    return null;\n  }\n};\n/**\n    @arg {string} signature - like SIG_K1_base58signature..\n    @throws {Error} invalid\n    @return {Signature}\n*/\n\n\nSignature.fromStringOrThrow = function (signature) {\n  assert.equal((0, _typeof2[\"default\"])(signature), 'string', 'signature');\n  var match = signature.match(/^SIG_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n  assert(match != null && match.length === 3, 'Expecting signature like: SIG_K1_base58signature..');\n\n  var _match = (0, _slicedToArray2[\"default\"])(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 signature expected');\n  return Signature.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n/**\n    @arg {String|Signature} o - hex string\n    @return {Signature}\n*/\n\n\nSignature.from = function (o) {\n  var signature = o ? o.r && o.s && o.i ? o : typeof o === 'string' && o.length === 130 ? Signature.fromHex(o) : typeof o === 'string' && o.length !== 130 ? Signature.fromStringOrThrow(o) : Buffer.isBuffer(o) ? Signature.fromBuffer(o) : null : o;\n  /*null or undefined*/\n\n  if (!signature) {\n    throw new TypeError('signature should be a hex string or buffer');\n  }\n\n  return signature;\n};"]},"metadata":{},"sourceType":"script"}