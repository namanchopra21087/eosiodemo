{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar ecurve = require('ecurve');\n\nvar Point = ecurve.Point;\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar BigInteger = require('bigi');\n\nvar assert = require('assert');\n\nvar hash = require('./hash');\n\nvar PublicKey = require('./key_public');\n\nvar keyUtils = require('./key_utils');\n\nvar createHash = require('create-hash');\n\nvar promiseAsync = require('./promise-async');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nmodule.exports = PrivateKey;\n/**\n  @typedef {string} wif - https://en.bitcoin.it/wiki/Wallet_import_format\n  @typedef {string} pubkey - EOSKey..\n  @typedef {ecurve.Point} Point\n*/\n\n/**\n  @param {BigInteger} d\n*/\n\nfunction PrivateKey(d) {\n  if (typeof d === 'string') {\n    return PrivateKey.fromString(d);\n  } else if (Buffer.isBuffer(d)) {\n    return PrivateKey.fromBuffer(d);\n  } else if ((0, _typeof2[\"default\"])(d) === 'object' && BigInteger.isBigInteger(d.d)) {\n    return PrivateKey(d.d);\n  }\n\n  if (!BigInteger.isBigInteger(d)) {\n    throw new TypeError('Invalid private key');\n  }\n  /** @return {string} private key like PVT_K1_base58privatekey.. */\n\n\n  function toString() {\n    // todo, use PVT_K1_\n    // return 'PVT_K1_' + keyUtils.checkEncode(toBuffer(), 'K1')\n    return toWif();\n  }\n  /**\n      @return  {wif}\n  */\n\n\n  function toWif() {\n    var private_key = toBuffer(); // checksum includes the version\n\n    private_key = Buffer.concat([new Buffer([0x80]), private_key]);\n    return keyUtils.checkEncode(private_key, 'sha256x2');\n  }\n\n  var public_key;\n  /**\n      @return {Point}\n  */\n\n  function toPublic() {\n    if (public_key) {\n      // cache\n      // S L O W in the browser\n      return public_key;\n    }\n\n    var Q = secp256k1.G.multiply(d);\n    return public_key = PublicKey.fromPoint(Q);\n  }\n\n  function toBuffer() {\n    return d.toBuffer(32);\n  }\n  /**\n    ECIES\n    @arg {string|Object} pubkey wif, PublicKey object\n    @return {Buffer} 64 byte shared secret\n  */\n\n\n  function getSharedSecret(public_key) {\n    public_key = PublicKey(public_key);\n    var KB = public_key.toUncompressed().toBuffer();\n    var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x\n    BigInteger.fromBuffer(KB.slice(33, 65)) // y\n    );\n    var r = toBuffer();\n    var P = KBP.multiply(BigInteger.fromBuffer(r));\n    var S = P.affineX.toBuffer({\n      size: 32\n    }); // SHA512 used in ECIES\n\n    return hash.sha512(S);\n  } // /** ECIES TODO unit test\n  //   @arg {string|Object} pubkey wif, PublicKey object\n  //   @return {Buffer} 64 byte shared secret\n  // */\n  // function getSharedSecret(public_key) {\n  //     public_key = PublicKey(public_key).toUncompressed()\n  //     var P = public_key.Q.multiply( d );\n  //     var S = P.affineX.toBuffer({size: 32});\n  //     // ECIES, adds an extra sha512\n  //     return hash.sha512(S);\n  // }\n\n  /**\n    @arg {string} name - child key name.\n    @return {PrivateKey}\n     @example activePrivate = masterPrivate.getChildKey('owner').getChildKey('active')\n    @example activePrivate.getChildKey('mycontract').getChildKey('myperm')\n  */\n\n\n  function getChildKey(name) {\n    // console.error('WARNING: getChildKey untested against eosd'); // no eosd impl yet\n    var index = createHash('sha256').update(toBuffer()).update(name).digest();\n    return PrivateKey(index);\n  }\n\n  function toHex() {\n    return toBuffer().toString('hex');\n  }\n\n  return {\n    d: d,\n    toWif: toWif,\n    toString: toString,\n    toPublic: toPublic,\n    toBuffer: toBuffer,\n    getSharedSecret: getSharedSecret,\n    getChildKey: getChildKey\n  };\n}\n/** @private */\n\n\nfunction parseKey(privateStr) {\n  assert.equal((0, _typeof2[\"default\"])(privateStr), 'string', 'privateStr');\n  var match = privateStr.match(/^PVT_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n\n  if (match === null) {\n    // legacy WIF - checksum includes the version\n    var versionKey = keyUtils.checkDecode(privateStr, 'sha256x2');\n    var version = versionKey.readUInt8(0);\n    assert.equal(0x80, version, \"Expected version \".concat(0x80, \", instead got \", version));\n\n    var _privateKey = PrivateKey.fromBuffer(versionKey.slice(1));\n\n    var _keyType = 'K1';\n    var format = 'WIF';\n    return {\n      privateKey: _privateKey,\n      format: format,\n      keyType: _keyType\n    };\n  }\n\n  assert(match.length === 3, 'Expecting private key like: PVT_K1_base58privateKey..');\n\n  var _match = (0, _slicedToArray2[\"default\"])(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 private key expected');\n  var privateKey = PrivateKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n  return {\n    privateKey: privateKey,\n    format: 'PVT',\n    keyType: keyType\n  };\n}\n\nPrivateKey.fromHex = function (hex) {\n  return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPrivateKey.fromBuffer = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error(\"Expecting parameter to be a Buffer type\");\n  }\n\n  if (buf.length === 33 && buf[32] === 1) {\n    // remove compression flag\n    buf = buf.slice(0, -1);\n  }\n\n  if (32 !== buf.length) {\n    throw new Error(\"Expecting 32 bytes, instead got \".concat(buf.length));\n  }\n\n  return PrivateKey(BigInteger.fromBuffer(buf));\n};\n/**\n    @arg {string} seed - any length string.  This is private, the same seed\n    produces the same private key every time.\n\n    @return {PrivateKey}\n*/\n\n\nPrivateKey.fromSeed = function (seed) {\n  // generate_private_key\n  if (!(typeof seed === 'string')) {\n    throw new Error('seed must be of type string');\n  }\n\n  return PrivateKey.fromBuffer(hash.sha256(seed));\n};\n/**\n  @arg {wif} key\n  @return {boolean} true if key is in the Wallet Import Format\n*/\n\n\nPrivateKey.isWif = function (text) {\n  try {\n    assert(parseKey(text).format === 'WIF');\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n  @arg {wif|Buffer|PrivateKey} key\n  @return {boolean} true if key is convertable to a private key object.\n*/\n\n\nPrivateKey.isValid = function (key) {\n  try {\n    PrivateKey(key);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/** @deprecated */\n\n\nPrivateKey.fromWif = function (str) {\n  console.log('PrivateKey.fromWif is deprecated, please use PrivateKey.fromString');\n  return PrivateKey.fromString(str);\n};\n/**\n    @throws {AssertError|Error} parsing key\n    @arg {string} privateStr Eosio or Wallet Import Format (wif) -- a secret\n*/\n\n\nPrivateKey.fromString = function (privateStr) {\n  return parseKey(privateStr).privateKey;\n};\n/**\n  Create a new random private key.\n\n  Call initialize() first to run some self-checking code and gather some CPU\n  entropy.\n\n  @arg {number} [cpuEntropyBits = 0] - additional CPU entropy, this already\n  happens once so it should not be needed again.\n\n  @return {Promise<PrivateKey>} - random private key\n*/\n\n\nPrivateKey.randomKey = function () {\n  var cpuEntropyBits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return PrivateKey.initialize().then(function () {\n    return PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({\n      cpuEntropyBits: cpuEntropyBits\n    }));\n  });\n};\n/**\n  @return {Promise<PrivateKey>} for testing, does not require initialize().\n*/\n\n\nPrivateKey.unsafeRandomKey = function () {\n  return Promise.resolve(PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({\n    safe: false\n  })));\n};\n\nvar initialized = false,\n    unitTested = false;\n/**\n  Run self-checking code and gather CPU entropy.\n\n  Initialization happens once even if called multiple times.\n\n  @return {Promise}\n*/\n\nfunction initialize() {\n  if (initialized) {\n    return;\n  }\n\n  unitTest();\n  keyUtils.addEntropy.apply(keyUtils, (0, _toConsumableArray2[\"default\"])(keyUtils.cpuEntropy()));\n  assert(keyUtils.entropyCount() >= 128, 'insufficient entropy');\n  initialized = true;\n}\n\nPrivateKey.initialize = promiseAsync(initialize);\n/**\n  Unit test basic private and public key functionality.\n\n  @throws {AssertError}\n*/\n\nfunction unitTest() {\n  var pvt = PrivateKey(hash.sha256(''));\n  var pvtError = 'key comparison test failed on a known private key';\n  assert.equal(pvt.toWif(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError);\n  assert.equal(pvt.toString(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError); // assert.equal(pvt.toString(), 'PVT_K1_2jH3nnhxhR3zPUcsKaWWZC9ZmZAnKm3GAnFD1xynGJE1Znuvjd', pvtError)\n\n  var pub = pvt.toPublic();\n  var pubError = 'pubkey string comparison test failed on a known public key';\n  assert.equal(pub.toString(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError); // assert.equal(pub.toString(), 'PUB_K1_859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2Ht7beeX', pubError)\n  // assert.equal(pub.toStringLegacy(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError)\n\n  doesNotThrow(function () {\n    return PrivateKey.fromString(pvt.toWif());\n  }, 'converting known wif from string');\n  doesNotThrow(function () {\n    return PrivateKey.fromString(pvt.toString());\n  }, 'converting known pvt from string');\n  doesNotThrow(function () {\n    return PublicKey.fromString(pub.toString());\n  }, 'converting known public key from string'); // doesNotThrow(() => PublicKey.fromString(pub.toStringLegacy()), 'converting known public key from string')\n\n  unitTested = true;\n}\n/** @private */\n\n\nvar doesNotThrow = function doesNotThrow(cb, msg) {\n  try {\n    cb();\n  } catch (error) {\n    error.message = \"\".concat(msg, \" ==> \").concat(error.message);\n    throw error;\n  }\n};","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosjs-ecc/lib/key_private.js"],"names":["_interopRequireDefault","require","_toConsumableArray2","_slicedToArray2","_typeof2","ecurve","Point","secp256k1","getCurveByName","BigInteger","assert","hash","PublicKey","keyUtils","createHash","promiseAsync","G","n","module","exports","PrivateKey","d","fromString","Buffer","isBuffer","fromBuffer","isBigInteger","TypeError","toString","toWif","private_key","toBuffer","concat","checkEncode","public_key","toPublic","Q","multiply","fromPoint","getSharedSecret","KB","toUncompressed","KBP","fromAffine","slice","r","P","S","affineX","size","sha512","getChildKey","name","index","update","digest","toHex","parseKey","privateStr","equal","match","versionKey","checkDecode","version","readUInt8","_privateKey","_keyType","format","privateKey","keyType","length","_match","keyString","fromHex","hex","buf","Error","fromSeed","seed","sha256","isWif","text","e","isValid","key","fromWif","str","console","log","randomKey","cpuEntropyBits","arguments","undefined","initialize","then","random32ByteBuffer","unsafeRandomKey","Promise","resolve","safe","initialized","unitTested","unitTest","addEntropy","apply","cpuEntropy","entropyCount","pvt","pvtError","pub","pubError","doesNotThrow","cb","msg","error","message"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar ecurve = require('ecurve');\n\nvar Point = ecurve.Point;\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar BigInteger = require('bigi');\n\nvar assert = require('assert');\n\nvar hash = require('./hash');\n\nvar PublicKey = require('./key_public');\n\nvar keyUtils = require('./key_utils');\n\nvar createHash = require('create-hash');\n\nvar promiseAsync = require('./promise-async');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nmodule.exports = PrivateKey;\n/**\n  @typedef {string} wif - https://en.bitcoin.it/wiki/Wallet_import_format\n  @typedef {string} pubkey - EOSKey..\n  @typedef {ecurve.Point} Point\n*/\n\n/**\n  @param {BigInteger} d\n*/\n\nfunction PrivateKey(d) {\n  if (typeof d === 'string') {\n    return PrivateKey.fromString(d);\n  } else if (Buffer.isBuffer(d)) {\n    return PrivateKey.fromBuffer(d);\n  } else if ((0, _typeof2[\"default\"])(d) === 'object' && BigInteger.isBigInteger(d.d)) {\n    return PrivateKey(d.d);\n  }\n\n  if (!BigInteger.isBigInteger(d)) {\n    throw new TypeError('Invalid private key');\n  }\n  /** @return {string} private key like PVT_K1_base58privatekey.. */\n\n\n  function toString() {\n    // todo, use PVT_K1_\n    // return 'PVT_K1_' + keyUtils.checkEncode(toBuffer(), 'K1')\n    return toWif();\n  }\n  /**\n      @return  {wif}\n  */\n\n\n  function toWif() {\n    var private_key = toBuffer(); // checksum includes the version\n\n    private_key = Buffer.concat([new Buffer([0x80]), private_key]);\n    return keyUtils.checkEncode(private_key, 'sha256x2');\n  }\n\n  var public_key;\n  /**\n      @return {Point}\n  */\n\n  function toPublic() {\n    if (public_key) {\n      // cache\n      // S L O W in the browser\n      return public_key;\n    }\n\n    var Q = secp256k1.G.multiply(d);\n    return public_key = PublicKey.fromPoint(Q);\n  }\n\n  function toBuffer() {\n    return d.toBuffer(32);\n  }\n  /**\n    ECIES\n    @arg {string|Object} pubkey wif, PublicKey object\n    @return {Buffer} 64 byte shared secret\n  */\n\n\n  function getSharedSecret(public_key) {\n    public_key = PublicKey(public_key);\n    var KB = public_key.toUncompressed().toBuffer();\n    var KBP = Point.fromAffine(secp256k1, BigInteger.fromBuffer(KB.slice(1, 33)), // x\n    BigInteger.fromBuffer(KB.slice(33, 65)) // y\n    );\n    var r = toBuffer();\n    var P = KBP.multiply(BigInteger.fromBuffer(r));\n    var S = P.affineX.toBuffer({\n      size: 32\n    }); // SHA512 used in ECIES\n\n    return hash.sha512(S);\n  } // /** ECIES TODO unit test\n  //   @arg {string|Object} pubkey wif, PublicKey object\n  //   @return {Buffer} 64 byte shared secret\n  // */\n  // function getSharedSecret(public_key) {\n  //     public_key = PublicKey(public_key).toUncompressed()\n  //     var P = public_key.Q.multiply( d );\n  //     var S = P.affineX.toBuffer({size: 32});\n  //     // ECIES, adds an extra sha512\n  //     return hash.sha512(S);\n  // }\n\n  /**\n    @arg {string} name - child key name.\n    @return {PrivateKey}\n     @example activePrivate = masterPrivate.getChildKey('owner').getChildKey('active')\n    @example activePrivate.getChildKey('mycontract').getChildKey('myperm')\n  */\n\n\n  function getChildKey(name) {\n    // console.error('WARNING: getChildKey untested against eosd'); // no eosd impl yet\n    var index = createHash('sha256').update(toBuffer()).update(name).digest();\n    return PrivateKey(index);\n  }\n\n  function toHex() {\n    return toBuffer().toString('hex');\n  }\n\n  return {\n    d: d,\n    toWif: toWif,\n    toString: toString,\n    toPublic: toPublic,\n    toBuffer: toBuffer,\n    getSharedSecret: getSharedSecret,\n    getChildKey: getChildKey\n  };\n}\n/** @private */\n\n\nfunction parseKey(privateStr) {\n  assert.equal((0, _typeof2[\"default\"])(privateStr), 'string', 'privateStr');\n  var match = privateStr.match(/^PVT_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n\n  if (match === null) {\n    // legacy WIF - checksum includes the version\n    var versionKey = keyUtils.checkDecode(privateStr, 'sha256x2');\n    var version = versionKey.readUInt8(0);\n    assert.equal(0x80, version, \"Expected version \".concat(0x80, \", instead got \", version));\n\n    var _privateKey = PrivateKey.fromBuffer(versionKey.slice(1));\n\n    var _keyType = 'K1';\n    var format = 'WIF';\n    return {\n      privateKey: _privateKey,\n      format: format,\n      keyType: _keyType\n    };\n  }\n\n  assert(match.length === 3, 'Expecting private key like: PVT_K1_base58privateKey..');\n\n  var _match = (0, _slicedToArray2[\"default\"])(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 private key expected');\n  var privateKey = PrivateKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n  return {\n    privateKey: privateKey,\n    format: 'PVT',\n    keyType: keyType\n  };\n}\n\nPrivateKey.fromHex = function (hex) {\n  return PrivateKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPrivateKey.fromBuffer = function (buf) {\n  if (!Buffer.isBuffer(buf)) {\n    throw new Error(\"Expecting parameter to be a Buffer type\");\n  }\n\n  if (buf.length === 33 && buf[32] === 1) {\n    // remove compression flag\n    buf = buf.slice(0, -1);\n  }\n\n  if (32 !== buf.length) {\n    throw new Error(\"Expecting 32 bytes, instead got \".concat(buf.length));\n  }\n\n  return PrivateKey(BigInteger.fromBuffer(buf));\n};\n/**\n    @arg {string} seed - any length string.  This is private, the same seed\n    produces the same private key every time.\n\n    @return {PrivateKey}\n*/\n\n\nPrivateKey.fromSeed = function (seed) {\n  // generate_private_key\n  if (!(typeof seed === 'string')) {\n    throw new Error('seed must be of type string');\n  }\n\n  return PrivateKey.fromBuffer(hash.sha256(seed));\n};\n/**\n  @arg {wif} key\n  @return {boolean} true if key is in the Wallet Import Format\n*/\n\n\nPrivateKey.isWif = function (text) {\n  try {\n    assert(parseKey(text).format === 'WIF');\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\n  @arg {wif|Buffer|PrivateKey} key\n  @return {boolean} true if key is convertable to a private key object.\n*/\n\n\nPrivateKey.isValid = function (key) {\n  try {\n    PrivateKey(key);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/** @deprecated */\n\n\nPrivateKey.fromWif = function (str) {\n  console.log('PrivateKey.fromWif is deprecated, please use PrivateKey.fromString');\n  return PrivateKey.fromString(str);\n};\n/**\n    @throws {AssertError|Error} parsing key\n    @arg {string} privateStr Eosio or Wallet Import Format (wif) -- a secret\n*/\n\n\nPrivateKey.fromString = function (privateStr) {\n  return parseKey(privateStr).privateKey;\n};\n/**\n  Create a new random private key.\n\n  Call initialize() first to run some self-checking code and gather some CPU\n  entropy.\n\n  @arg {number} [cpuEntropyBits = 0] - additional CPU entropy, this already\n  happens once so it should not be needed again.\n\n  @return {Promise<PrivateKey>} - random private key\n*/\n\n\nPrivateKey.randomKey = function () {\n  var cpuEntropyBits = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return PrivateKey.initialize().then(function () {\n    return PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({\n      cpuEntropyBits: cpuEntropyBits\n    }));\n  });\n};\n/**\n  @return {Promise<PrivateKey>} for testing, does not require initialize().\n*/\n\n\nPrivateKey.unsafeRandomKey = function () {\n  return Promise.resolve(PrivateKey.fromBuffer(keyUtils.random32ByteBuffer({\n    safe: false\n  })));\n};\n\nvar initialized = false,\n    unitTested = false;\n/**\n  Run self-checking code and gather CPU entropy.\n\n  Initialization happens once even if called multiple times.\n\n  @return {Promise}\n*/\n\nfunction initialize() {\n  if (initialized) {\n    return;\n  }\n\n  unitTest();\n  keyUtils.addEntropy.apply(keyUtils, (0, _toConsumableArray2[\"default\"])(keyUtils.cpuEntropy()));\n  assert(keyUtils.entropyCount() >= 128, 'insufficient entropy');\n  initialized = true;\n}\n\nPrivateKey.initialize = promiseAsync(initialize);\n/**\n  Unit test basic private and public key functionality.\n\n  @throws {AssertError}\n*/\n\nfunction unitTest() {\n  var pvt = PrivateKey(hash.sha256(''));\n  var pvtError = 'key comparison test failed on a known private key';\n  assert.equal(pvt.toWif(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError);\n  assert.equal(pvt.toString(), '5KYZdUEo39z3FPrtuX2QbbwGnNP5zTd7yyr2SC1j299sBCnWjss', pvtError); // assert.equal(pvt.toString(), 'PVT_K1_2jH3nnhxhR3zPUcsKaWWZC9ZmZAnKm3GAnFD1xynGJE1Znuvjd', pvtError)\n\n  var pub = pvt.toPublic();\n  var pubError = 'pubkey string comparison test failed on a known public key';\n  assert.equal(pub.toString(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError); // assert.equal(pub.toString(), 'PUB_K1_859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2Ht7beeX', pubError)\n  // assert.equal(pub.toStringLegacy(), 'EOS859gxfnXyUriMgUeThh1fWv3oqcpLFyHa3TfFYC4PK2HqhToVM', pubError)\n\n  doesNotThrow(function () {\n    return PrivateKey.fromString(pvt.toWif());\n  }, 'converting known wif from string');\n  doesNotThrow(function () {\n    return PrivateKey.fromString(pvt.toString());\n  }, 'converting known pvt from string');\n  doesNotThrow(function () {\n    return PublicKey.fromString(pub.toString());\n  }, 'converting known public key from string'); // doesNotThrow(() => PublicKey.fromString(pub.toStringLegacy()), 'converting known public key from string')\n\n  unitTested = true;\n}\n/** @private */\n\n\nvar doesNotThrow = function doesNotThrow(cb, msg) {\n  try {\n    cb();\n  } catch (error) {\n    error.message = \"\".concat(msg, \" ==> \").concat(error.message);\n    throw error;\n  }\n};"]},"metadata":{},"sourceType":"script"}