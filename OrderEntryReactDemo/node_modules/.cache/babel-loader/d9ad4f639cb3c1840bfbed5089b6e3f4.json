{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport * as esr from 'eosio-signing-request';\nimport { JsonRpc } from 'eosjs';\nimport * as ecc from 'eosjs-ecc';\nimport WebSocket from 'isomorphic-ws';\nimport zlib from 'pako';\nimport { v4 as uuid } from 'uuid';\nimport { CancelError, IdentityError } from './errors';\nimport { defaults } from './link-options';\nimport { LinkChannelSession, LinkFallbackSession, LinkSession } from './link-session';\nimport { abiEncode, fetch, generatePrivateKey, normalizePublicKey, publicKeyEqual } from './utils';\n/**\n * Main class, also exposed as the default export of the library.\n *\n * Example:\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport()\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\n\nexport var Link = /*#__PURE__*/function () {\n  /** Create a new link instance. */\n  function Link(options) {\n    _classCallCheck(this, Link);\n\n    this.abiCache = new Map();\n    this.pendingAbis = new Map();\n\n    if (typeof options !== 'object') {\n      throw new TypeError('Missing options object');\n    }\n\n    if (!options.transport) {\n      throw new TypeError('options.transport is required, see https://github.com/greymass/anchor-link#transports');\n    }\n\n    if (options.rpc === undefined || typeof options.rpc === 'string') {\n      this.rpc = new JsonRpc(options.rpc || defaults.rpc, {\n        fetch: fetch\n      });\n    } else {\n      this.rpc = options.rpc;\n    }\n\n    if (options.chainId) {\n      this.chainId = typeof options.chainId === 'number' ? esr.nameToId(options.chainId) : options.chainId;\n    } else {\n      this.chainId = defaults.chainId;\n    }\n\n    this.serviceAddress = (options.service || defaults.service).trim().replace(/\\/$/, '');\n    this.transport = options.transport;\n\n    if (options.storage !== null) {\n      this.storage = options.storage || this.transport.storage;\n    }\n\n    this.requestOptions = {\n      abiProvider: this,\n      textDecoder: options.textDecoder || new TextDecoder(),\n      textEncoder: options.textEncoder || new TextEncoder(),\n      zlib: zlib\n    };\n  }\n  /**\n   * Fetch the ABI for given account, cached.\n   * @internal\n   */\n\n\n  _createClass(Link, [{\n    key: \"getAbi\",\n    value: function () {\n      var _getAbi = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(account) {\n        var rv, _getAbi2;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                rv = this.abiCache.get(account);\n\n                if (rv) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _getAbi2 = this.pendingAbis.get(account);\n\n                if (!_getAbi2) {\n                  _getAbi2 = this.rpc.get_abi(account);\n                  this.pendingAbis.set(account, _getAbi2);\n                }\n\n                _context.next = 6;\n                return _getAbi2;\n\n              case 6:\n                rv = _context.sent.abi;\n                this.pendingAbis.delete(account);\n\n                if (rv) {\n                  this.abiCache.set(account, rv);\n                }\n\n              case 9:\n                return _context.abrupt(\"return\", rv);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAbi(_x) {\n        return _getAbi.apply(this, arguments);\n      }\n\n      return getAbi;\n    }()\n    /**\n     * Create a new unique buoy callback url.\n     * @internal\n     */\n\n  }, {\n    key: \"createCallbackUrl\",\n    value: function createCallbackUrl() {\n      return \"\".concat(this.serviceAddress, \"/\").concat(uuid());\n    }\n    /**\n     * Create a SigningRequest instance configured for this link.\n     * @internal\n     */\n\n  }, {\n    key: \"createRequest\",\n    value: function () {\n      var _createRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(args, transport) {\n        var t, request;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                t = transport || this.transport; // generate unique callback url\n\n                _context2.next = 3;\n                return esr.SigningRequest.create(_objectSpread(_objectSpread({}, args), {}, {\n                  chainId: this.chainId,\n                  broadcast: false,\n                  callback: {\n                    url: this.createCallbackUrl(),\n                    background: true\n                  }\n                }), this.requestOptions);\n\n              case 3:\n                request = _context2.sent;\n\n                if (!t.prepare) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 7;\n                return t.prepare(request);\n\n              case 7:\n                request = _context2.sent;\n\n              case 8:\n                return _context2.abrupt(\"return\", request);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function createRequest(_x2, _x3) {\n        return _createRequest.apply(this, arguments);\n      }\n\n      return createRequest;\n    }()\n    /**\n     * Send a SigningRequest instance using this link.\n     * @internal\n     */\n\n  }, {\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(request, transport) {\n        var broadcast,\n            t,\n            linkUrl,\n            ctx,\n            socket,\n            cancel,\n            payload,\n            signer,\n            signatures,\n            resolved,\n            info,\n            serializedTransaction,\n            transaction,\n            result,\n            res,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                broadcast = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;\n                t = transport || this.transport;\n                _context3.prev = 2;\n                linkUrl = request.data.callback;\n\n                if (linkUrl.startsWith(this.serviceAddress)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                throw new Error('Request must have a link callback');\n\n              case 6:\n                if (!(request.data.flags !== 2)) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw new Error('Invalid request flags');\n\n              case 8:\n                // wait for callback or user cancel\n                ctx = {};\n                socket = waitForCallback(linkUrl, ctx).then(function (data) {\n                  if (typeof data.rejected === 'string') {\n                    throw new CancelError(\"Rejected by wallet: \".concat(data.rejected));\n                  }\n\n                  return data;\n                });\n                cancel = new Promise(function (resolve, reject) {\n                  t.onRequest(request, function (reason) {\n                    if (ctx.cancel) {\n                      ctx.cancel();\n                    }\n\n                    if (typeof reason === 'string') {\n                      reject(new CancelError(reason));\n                    } else {\n                      reject(reason);\n                    }\n                  });\n                });\n                _context3.next = 13;\n                return Promise.race([socket, cancel]);\n\n              case 13:\n                payload = _context3.sent;\n                signer = {\n                  actor: payload.sa,\n                  permission: payload.sp\n                };\n                signatures = Object.keys(payload).filter(function (key) {\n                  return key.startsWith('sig') && key !== 'sig0';\n                }).map(function (key) {\n                  return payload[key];\n                }); // recreate transaction from request response\n\n                _context3.next = 18;\n                return esr.ResolvedSigningRequest.fromPayload(payload, this.requestOptions);\n\n              case 18:\n                resolved = _context3.sent;\n                info = resolved.request.getInfo();\n\n                if (info['fuel_sig']) {\n                  signatures.unshift(info['fuel_sig']);\n                }\n\n                serializedTransaction = resolved.serializedTransaction, transaction = resolved.transaction;\n                result = {\n                  request: resolved.request,\n                  serializedTransaction: serializedTransaction,\n                  transaction: transaction,\n                  signatures: signatures,\n                  payload: payload,\n                  signer: signer\n                };\n\n                if (!broadcast) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                _context3.next = 26;\n                return this.rpc.push_transaction({\n                  signatures: result.signatures,\n                  serializedTransaction: result.serializedTransaction\n                });\n\n              case 26:\n                res = _context3.sent;\n                result.processed = res.processed;\n\n              case 28:\n                if (t.onSuccess) {\n                  t.onSuccess(request, result);\n                }\n\n                return _context3.abrupt(\"return\", result);\n\n              case 32:\n                _context3.prev = 32;\n                _context3.t0 = _context3[\"catch\"](2);\n\n                if (t.onFailure) {\n                  t.onFailure(request, _context3.t0);\n                }\n\n                throw _context3.t0;\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 32]]);\n      }));\n\n      function sendRequest(_x4, _x5) {\n        return _sendRequest.apply(this, arguments);\n      }\n\n      return sendRequest;\n    }()\n    /**\n     * Sign and optionally broadcast a EOSIO transaction, action or actions.\n     *\n     * Example:\n     *\n     * ```ts\n     * let result = await myLink.transact({transaction: myTx})\n     * ```\n     *\n     * @param args The action, actions or transaction to use.\n     * @param options Options for this transact call.\n     * @param transport Transport override, for internal use.\n     */\n\n  }, {\n    key: \"transact\",\n    value: function () {\n      var _transact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(args, options, transport) {\n        var t, broadcast, anyArgs, request, result;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                t = transport || this.transport;\n                broadcast = options ? options.broadcast !== false : true; // Initialize the loading state of the transport\n\n                if (t && t.showLoading) {\n                  t.showLoading();\n                } // eosjs transact compat: upgrade to transaction if args have any header fields\n\n\n                anyArgs = args;\n\n                if (args.actions && (anyArgs.expiration || anyArgs.ref_block_num || anyArgs.ref_block_prefix || anyArgs.max_net_usage_words || anyArgs.max_cpu_usage_ms || anyArgs.delay_sec)) {\n                  args = {\n                    transaction: _objectSpread({\n                      expiration: '1970-01-01T00:00:00',\n                      ref_block_num: 0,\n                      ref_block_prefix: 0,\n                      max_net_usage_words: 0,\n                      max_cpu_usage_ms: 0,\n                      delay_sec: 0\n                    }, anyArgs)\n                  };\n                }\n\n                _context4.next = 7;\n                return this.createRequest(args, t);\n\n              case 7:\n                request = _context4.sent;\n                _context4.next = 10;\n                return this.sendRequest(request, t, broadcast);\n\n              case 10:\n                result = _context4.sent;\n                return _context4.abrupt(\"return\", result);\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function transact(_x6, _x7, _x8) {\n        return _transact.apply(this, arguments);\n      }\n\n      return transact;\n    }()\n    /**\n     * Send an identity request and verify the identity proof.\n     * @param requestPermission Optional request permission if the request is for a specific account or permission.\n     * @param info Metadata to add to the request.\n     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n     */\n\n  }, {\n    key: \"identify\",\n    value: function () {\n      var _identify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(requestPermission, info) {\n        var request, res, message, signer, signerKey, account, permission, auth, keyAuth;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.createRequest({\n                  identity: {\n                    permission: requestPermission || null\n                  },\n                  info: info\n                });\n\n              case 2:\n                request = _context5.sent;\n                _context5.next = 5;\n                return this.sendRequest(request);\n\n              case 5:\n                res = _context5.sent;\n\n                if (res.request.isIdentity()) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                throw new IdentityError(\"Unexpected response\");\n\n              case 8:\n                message = Buffer.concat([Buffer.from(request.getChainId(), 'hex'), Buffer.from(res.serializedTransaction), Buffer.alloc(32)]);\n                signer = res.signer;\n                signerKey = ecc.recover(res.signatures[0], message);\n                _context5.next = 13;\n                return this.rpc.get_account(signer.actor);\n\n              case 13:\n                account = _context5.sent;\n\n                if (account) {\n                  _context5.next = 16;\n                  break;\n                }\n\n                throw new IdentityError(\"Signature from unknown account: \".concat(signer.actor));\n\n              case 16:\n                permission = account.permissions.find(function (_ref) {\n                  var perm_name = _ref.perm_name;\n                  return perm_name === signer.permission;\n                });\n\n                if (permission) {\n                  _context5.next = 19;\n                  break;\n                }\n\n                throw new IdentityError(\"\".concat(signer.actor, \" signed for unknown permission: \").concat(signer.permission));\n\n              case 19:\n                auth = permission.required_auth;\n                keyAuth = auth.keys.find(function (_ref2) {\n                  var key = _ref2.key;\n                  return publicKeyEqual(key, signerKey);\n                });\n\n                if (keyAuth) {\n                  _context5.next = 23;\n                  break;\n                }\n\n                throw new IdentityError(\"\".concat(formatAuth(signer), \" has no key matching id signature\"));\n\n              case 23:\n                if (!(auth.threshold > keyAuth.weight)) {\n                  _context5.next = 25;\n                  break;\n                }\n\n                throw new IdentityError(\"\".concat(formatAuth(signer), \" signature does not reach auth threshold\"));\n\n              case 25:\n                if (!requestPermission) {\n                  _context5.next = 28;\n                  break;\n                }\n\n                if (!(requestPermission.actor !== esr.PlaceholderName && requestPermission.actor !== signer.actor || requestPermission.permission !== esr.PlaceholderPermission && requestPermission.permission !== signer.permission)) {\n                  _context5.next = 28;\n                  break;\n                }\n\n                throw new IdentityError(\"Unexpected identity proof from \".concat(formatAuth(signer), \", expected \").concat(formatAuth(requestPermission), \" \"));\n\n              case 28:\n                return _context5.abrupt(\"return\", _objectSpread(_objectSpread({}, res), {}, {\n                  account: account,\n                  signerKey: signerKey\n                }));\n\n              case 29:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function identify(_x9, _x10) {\n        return _identify.apply(this, arguments);\n      }\n\n      return identify;\n    }()\n    /**\n     * Login and create a persistent session.\n     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n     *                   Should be set to the contract account if applicable.\n     */\n\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(identifier) {\n        var privateKey, requestKey, createInfo, res, metadata, session;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return generatePrivateKey();\n\n              case 2:\n                privateKey = _context6.sent;\n                requestKey = ecc.privateToPublic(privateKey);\n                createInfo = {\n                  session_name: identifier,\n                  request_key: requestKey\n                };\n                _context6.next = 7;\n                return this.identify(undefined, {\n                  link: abiEncode(createInfo, 'link_create')\n                });\n\n              case 7:\n                res = _context6.sent;\n                metadata = {\n                  sameDevice: res.request.getRawInfo()['return_path'] !== undefined\n                };\n\n                if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n                  session = new LinkChannelSession(this, {\n                    identifier: identifier,\n                    auth: res.signer,\n                    publicKey: res.signerKey,\n                    channel: {\n                      url: res.payload.link_ch,\n                      key: res.payload.link_key,\n                      name: res.payload.link_name\n                    },\n                    requestKey: privateKey\n                  }, metadata);\n                } else {\n                  session = new LinkFallbackSession(this, {\n                    identifier: identifier,\n                    auth: res.signer,\n                    publicKey: res.signerKey\n                  }, metadata);\n                }\n\n                if (!this.storage) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                _context6.next = 13;\n                return this.storeSession(identifier, session);\n\n              case 13:\n                return _context6.abrupt(\"return\", _objectSpread(_objectSpread({}, res), {}, {\n                  session: session\n                }));\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function login(_x11) {\n        return _login.apply(this, arguments);\n      }\n\n      return login;\n    }()\n    /**\n     * Restore previous session, see [[Link.login]] to create a new session.\n     * @param identifier The session identifier, should be same as what was used when creating the session with [[Link.login]].\n     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n     * @returns A [[LinkSession]] instance or null if no session can be found.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n     **/\n\n  }, {\n    key: \"restoreSession\",\n    value: function () {\n      var _restoreSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(identifier, auth) {\n        var key, latest, data, sessionData, session;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (this.storage) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to restore session: No storage adapter configured');\n\n              case 2:\n                if (!auth) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                key = this.sessionKey(identifier, formatAuth(auth));\n                _context7.next = 12;\n                break;\n\n              case 6:\n                _context7.next = 8;\n                return this.listSessions(identifier);\n\n              case 8:\n                latest = _context7.sent[0];\n\n                if (latest) {\n                  _context7.next = 11;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", null);\n\n              case 11:\n                key = this.sessionKey(identifier, formatAuth(latest));\n\n              case 12:\n                _context7.next = 14;\n                return this.storage.read(key);\n\n              case 14:\n                data = _context7.sent;\n\n                if (data) {\n                  _context7.next = 17;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", null);\n\n              case 17:\n                _context7.prev = 17;\n                sessionData = JSON.parse(data);\n                _context7.next = 24;\n                break;\n\n              case 21:\n                _context7.prev = 21;\n                _context7.t0 = _context7[\"catch\"](17);\n                throw new Error(\"Unable to restore session: Stored JSON invalid (\".concat(_context7.t0.message || String(_context7.t0), \")\"));\n\n              case 24:\n                session = LinkSession.restore(this, sessionData);\n\n                if (!auth) {\n                  _context7.next = 28;\n                  break;\n                }\n\n                _context7.next = 28;\n                return this.touchSession(identifier, auth);\n\n              case 28:\n                return _context7.abrupt(\"return\", session);\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[17, 21]]);\n      }));\n\n      function restoreSession(_x12, _x13) {\n        return _restoreSession.apply(this, arguments);\n      }\n\n      return restoreSession;\n    }()\n    /**\n     * List stored session auths for given identifier.\n     * The most recently used session is at the top (index 0).\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n     **/\n\n  }, {\n    key: \"listSessions\",\n    value: function () {\n      var _listSessions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(identifier) {\n        var key, list;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (this.storage) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to list sessions: No storage adapter configured');\n\n              case 2:\n                key = this.sessionKey(identifier, 'list');\n                _context8.prev = 3;\n                _context8.t0 = JSON;\n                _context8.next = 7;\n                return this.storage.read(key);\n\n              case 7:\n                _context8.t1 = _context8.sent;\n\n                if (_context8.t1) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                _context8.t1 = '[]';\n\n              case 10:\n                _context8.t2 = _context8.t1;\n                list = _context8.t0.parse.call(_context8.t0, _context8.t2);\n                _context8.next = 17;\n                break;\n\n              case 14:\n                _context8.prev = 14;\n                _context8.t3 = _context8[\"catch\"](3);\n                throw new Error(\"Unable to list sessions: Stored JSON invalid (\".concat(_context8.t3.message || String(_context8.t3), \")\"));\n\n              case 17:\n                return _context8.abrupt(\"return\", list);\n\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[3, 14]]);\n      }));\n\n      function listSessions(_x14) {\n        return _listSessions.apply(this, arguments);\n      }\n\n      return listSessions;\n    }()\n    /**\n     * Remove stored session for given identifier and auth.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n\n  }, {\n    key: \"removeSession\",\n    value: function () {\n      var _removeSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(identifier, auth) {\n        var key;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this.storage) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to remove session: No storage adapter configured');\n\n              case 2:\n                key = this.sessionKey(identifier, formatAuth(auth));\n                _context9.next = 5;\n                return this.storage.remove(key);\n\n              case 5:\n                _context9.next = 7;\n                return this.touchSession(identifier, auth, true);\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function removeSession(_x15, _x16) {\n        return _removeSession.apply(this, arguments);\n      }\n\n      return removeSession;\n    }()\n    /**\n     * Remove all stored sessions for given identifier.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n\n  }, {\n    key: \"clearSessions\",\n    value: function () {\n      var _clearSessions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(identifier) {\n        var _iterator, _step, auth;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (this.storage) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('Unable to clear sessions: No storage adapter configured');\n\n              case 2:\n                _context10.t0 = _createForOfIteratorHelper;\n                _context10.next = 5;\n                return this.listSessions(identifier);\n\n              case 5:\n                _context10.t1 = _context10.sent;\n                _iterator = (0, _context10.t0)(_context10.t1);\n                _context10.prev = 7;\n\n                _iterator.s();\n\n              case 9:\n                if ((_step = _iterator.n()).done) {\n                  _context10.next = 15;\n                  break;\n                }\n\n                auth = _step.value;\n                _context10.next = 13;\n                return this.removeSession(identifier, auth);\n\n              case 13:\n                _context10.next = 9;\n                break;\n\n              case 15:\n                _context10.next = 20;\n                break;\n\n              case 17:\n                _context10.prev = 17;\n                _context10.t2 = _context10[\"catch\"](7);\n\n                _iterator.e(_context10.t2);\n\n              case 20:\n                _context10.prev = 20;\n\n                _iterator.f();\n\n                return _context10.finish(20);\n\n              case 23:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[7, 17, 20, 23]]);\n      }));\n\n      function clearSessions(_x17) {\n        return _clearSessions.apply(this, arguments);\n      }\n\n      return clearSessions;\n    }()\n    /**\n     * Create an eosjs compatible signature provider using this link.\n     * @param availableKeys Keys the created provider will claim to be able to sign for.\n     * @param transport (internal) Transport override for this call.\n     * @note We don't know what keys are available so those have to be provided,\n     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n     */\n\n  }, {\n    key: \"makeSignatureProvider\",\n    value: function makeSignatureProvider(availableKeys, transport) {\n      var _this = this;\n\n      return {\n        getAvailableKeys: function () {\n          var _getAvailableKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n            return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n              while (1) {\n                switch (_context11.prev = _context11.next) {\n                  case 0:\n                    return _context11.abrupt(\"return\", availableKeys);\n\n                  case 1:\n                  case \"end\":\n                    return _context11.stop();\n                }\n              }\n            }, _callee11);\n          }));\n\n          function getAvailableKeys() {\n            return _getAvailableKeys.apply(this, arguments);\n          }\n\n          return getAvailableKeys;\n        }(),\n        sign: function () {\n          var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(args) {\n            var t, request, _yield$_this$sendRequ, serializedTransaction, signatures;\n\n            return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n              while (1) {\n                switch (_context12.prev = _context12.next) {\n                  case 0:\n                    t = transport || _this.transport;\n                    request = esr.SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, _this.requestOptions);\n                    request.setCallback(_this.createCallbackUrl(), true);\n                    request.setBroadcast(false);\n\n                    if (!t.prepare) {\n                      _context12.next = 8;\n                      break;\n                    }\n\n                    _context12.next = 7;\n                    return t.prepare(request);\n\n                  case 7:\n                    request = _context12.sent;\n\n                  case 8:\n                    _context12.next = 10;\n                    return _this.sendRequest(request, t);\n\n                  case 10:\n                    _yield$_this$sendRequ = _context12.sent;\n                    serializedTransaction = _yield$_this$sendRequ.serializedTransaction;\n                    signatures = _yield$_this$sendRequ.signatures;\n                    return _context12.abrupt(\"return\", _objectSpread(_objectSpread({}, args), {}, {\n                      serializedTransaction: serializedTransaction,\n                      signatures: signatures\n                    }));\n\n                  case 14:\n                  case \"end\":\n                    return _context12.stop();\n                }\n              }\n            }, _callee12);\n          }));\n\n          function sign(_x18) {\n            return _sign.apply(this, arguments);\n          }\n\n          return sign;\n        }()\n      };\n    }\n    /**\n     * Create an eosjs authority provider using this link.\n     * @note Uses the configured RPC Node's `/v1/chain/get_required_keys` API to resolve keys.\n     */\n\n  }, {\n    key: \"makeAuthorityProvider\",\n    value: function makeAuthorityProvider() {\n      var rpc = this.rpc;\n      return {\n        getRequiredKeys: function getRequiredKeys(args) {\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n            var availableKeys, transaction, result;\n            return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n              while (1) {\n                switch (_context13.prev = _context13.next) {\n                  case 0:\n                    availableKeys = args.availableKeys, transaction = args.transaction;\n                    _context13.next = 3;\n                    return rpc.fetch('/v1/chain/get_required_keys', {\n                      transaction: transaction,\n                      available_keys: availableKeys.map(normalizePublicKey)\n                    });\n\n                  case 3:\n                    result = _context13.sent;\n                    return _context13.abrupt(\"return\", result.required_keys.map(normalizePublicKey));\n\n                  case 5:\n                  case \"end\":\n                    return _context13.stop();\n                }\n              }\n            }, _callee13);\n          }))();\n        }\n      };\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n  }, {\n    key: \"touchSession\",\n    value: function () {\n      var _touchSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(identifier, auth) {\n        var remove,\n            auths,\n            formattedAuth,\n            existing,\n            key,\n            _args14 = arguments;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                remove = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : false;\n                _context14.next = 3;\n                return this.listSessions(identifier);\n\n              case 3:\n                auths = _context14.sent;\n                formattedAuth = formatAuth(auth);\n                existing = auths.findIndex(function (a) {\n                  return formatAuth(a) === formattedAuth;\n                });\n\n                if (existing >= 0) {\n                  auths.splice(existing, 1);\n                }\n\n                if (remove === false) {\n                  auths.unshift(auth);\n                }\n\n                key = this.sessionKey(identifier, 'list');\n                _context14.next = 11;\n                return this.storage.write(key, JSON.stringify(auths));\n\n              case 11:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function touchSession(_x19, _x20) {\n        return _touchSession.apply(this, arguments);\n      }\n\n      return touchSession;\n    }()\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n  }, {\n    key: \"storeSession\",\n    value: function () {\n      var _storeSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(identifier, session) {\n        var key, data;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                key = this.sessionKey(identifier, formatAuth(session.auth));\n                data = JSON.stringify(session.serialize());\n                _context15.next = 4;\n                return this.storage.write(key, data);\n\n              case 4:\n                _context15.next = 6;\n                return this.touchSession(identifier, session.auth);\n\n              case 6:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function storeSession(_x21, _x22) {\n        return _storeSession.apply(this, arguments);\n      }\n\n      return storeSession;\n    }()\n    /** Session storage key for identifier and suffix. */\n\n  }, {\n    key: \"sessionKey\",\n    value: function sessionKey(identifier, suffix) {\n      return [this.chainId, identifier, suffix].join('-');\n    }\n  }]);\n\n  return Link;\n}();\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\n\nfunction waitForCallback(url, ctx) {\n  return new Promise(function (resolve, reject) {\n    var active = true;\n    var retries = 0;\n    var socketUrl = url.replace(/^http/, 'ws');\n\n    var handleResponse = function handleResponse(response) {\n      try {\n        resolve(JSON.parse(response));\n      } catch (error) {\n        error.message = 'Unable to parse callback JSON: ' + error.message;\n        reject(error);\n      }\n    };\n\n    var connect = function connect() {\n      var socket = new WebSocket(socketUrl);\n\n      ctx.cancel = function () {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {\n          socket.close();\n        }\n      };\n\n      socket.onmessage = function (event) {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.close();\n        }\n\n        if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n          var reader = new FileReader();\n\n          reader.onload = function () {\n            handleResponse(reader.result);\n          };\n\n          reader.onerror = function (error) {\n            reject(error);\n          };\n\n          reader.readAsText(event.data);\n        } else {\n          if (typeof event.data === 'string') {\n            handleResponse(event.data);\n          } else {\n            handleResponse(event.data.toString());\n          }\n        }\n      };\n\n      socket.onopen = function () {\n        retries = 0;\n      };\n\n      socket.onerror = function (error) {};\n\n      socket.onclose = function (close) {\n        if (active) {\n          setTimeout(connect, backoff(retries++));\n        }\n      };\n    };\n\n    connect();\n  });\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\n\n\nfunction backoff(tries) {\n  return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\n\n\nfunction formatAuth(auth) {\n  var actor = auth.actor,\n      permission = auth.permission;\n\n  if (actor === esr.PlaceholderName) {\n    actor = '<any>';\n  }\n\n  if (permission === esr.PlaceholderName || permission === esr.PlaceholderPermission) {\n    permission = '<any>';\n  }\n\n  return \"\".concat(actor, \"@\").concat(permission);\n}","map":{"version":3,"sources":["../src/link.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as esr from 'eosio-signing-request';\nimport { JsonRpc } from 'eosjs';\nimport * as ecc from 'eosjs-ecc';\nimport WebSocket from 'isomorphic-ws';\nimport zlib from 'pako';\nimport { v4 as uuid } from 'uuid';\nimport { CancelError, IdentityError } from './errors';\nimport { defaults } from './link-options';\nimport { LinkChannelSession, LinkFallbackSession, LinkSession } from './link-session';\nimport { abiEncode, fetch, generatePrivateKey, normalizePublicKey, publicKeyEqual } from './utils';\n/**\n * Main class, also exposed as the default export of the library.\n *\n * Example:\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport()\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\nexport class Link {\n    /** Create a new link instance. */\n    constructor(options) {\n        this.abiCache = new Map();\n        this.pendingAbis = new Map();\n        if (typeof options !== 'object') {\n            throw new TypeError('Missing options object');\n        }\n        if (!options.transport) {\n            throw new TypeError('options.transport is required, see https://github.com/greymass/anchor-link#transports');\n        }\n        if (options.rpc === undefined || typeof options.rpc === 'string') {\n            this.rpc = new JsonRpc(options.rpc || defaults.rpc, { fetch: fetch });\n        }\n        else {\n            this.rpc = options.rpc;\n        }\n        if (options.chainId) {\n            this.chainId =\n                typeof options.chainId === 'number'\n                    ? esr.nameToId(options.chainId)\n                    : options.chainId;\n        }\n        else {\n            this.chainId = defaults.chainId;\n        }\n        this.serviceAddress = (options.service || defaults.service).trim().replace(/\\/$/, '');\n        this.transport = options.transport;\n        if (options.storage !== null) {\n            this.storage = options.storage || this.transport.storage;\n        }\n        this.requestOptions = {\n            abiProvider: this,\n            textDecoder: options.textDecoder || new TextDecoder(),\n            textEncoder: options.textEncoder || new TextEncoder(),\n            zlib,\n        };\n    }\n    /**\n     * Fetch the ABI for given account, cached.\n     * @internal\n     */\n    async getAbi(account) {\n        let rv = this.abiCache.get(account);\n        if (!rv) {\n            let getAbi = this.pendingAbis.get(account);\n            if (!getAbi) {\n                getAbi = this.rpc.get_abi(account);\n                this.pendingAbis.set(account, getAbi);\n            }\n            rv = (await getAbi).abi;\n            this.pendingAbis.delete(account);\n            if (rv) {\n                this.abiCache.set(account, rv);\n            }\n        }\n        return rv;\n    }\n    /**\n     * Create a new unique buoy callback url.\n     * @internal\n     */\n    createCallbackUrl() {\n        return `${this.serviceAddress}/${uuid()}`;\n    }\n    /**\n     * Create a SigningRequest instance configured for this link.\n     * @internal\n     */\n    async createRequest(args, transport) {\n        const t = transport || this.transport;\n        // generate unique callback url\n        let request = await esr.SigningRequest.create({\n            ...args,\n            chainId: this.chainId,\n            broadcast: false,\n            callback: {\n                url: this.createCallbackUrl(),\n                background: true,\n            },\n        }, this.requestOptions);\n        if (t.prepare) {\n            request = await t.prepare(request);\n        }\n        return request;\n    }\n    /**\n     * Send a SigningRequest instance using this link.\n     * @internal\n     */\n    async sendRequest(request, transport, broadcast = false) {\n        const t = transport || this.transport;\n        try {\n            const linkUrl = request.data.callback;\n            if (!linkUrl.startsWith(this.serviceAddress)) {\n                throw new Error('Request must have a link callback');\n            }\n            if (request.data.flags !== 2) {\n                throw new Error('Invalid request flags');\n            }\n            // wait for callback or user cancel\n            const ctx = {};\n            const socket = waitForCallback(linkUrl, ctx).then((data) => {\n                if (typeof data.rejected === 'string') {\n                    throw new CancelError(`Rejected by wallet: ${data.rejected}`);\n                }\n                return data;\n            });\n            const cancel = new Promise((resolve, reject) => {\n                t.onRequest(request, (reason) => {\n                    if (ctx.cancel) {\n                        ctx.cancel();\n                    }\n                    if (typeof reason === 'string') {\n                        reject(new CancelError(reason));\n                    }\n                    else {\n                        reject(reason);\n                    }\n                });\n            });\n            const payload = await Promise.race([socket, cancel]);\n            const signer = {\n                actor: payload.sa,\n                permission: payload.sp,\n            };\n            const signatures = Object.keys(payload)\n                .filter((key) => key.startsWith('sig') && key !== 'sig0')\n                .map((key) => payload[key]);\n            // recreate transaction from request response\n            const resolved = await esr.ResolvedSigningRequest.fromPayload(payload, this.requestOptions);\n            const info = resolved.request.getInfo();\n            if (info['fuel_sig']) {\n                signatures.unshift(info['fuel_sig']);\n            }\n            const { serializedTransaction, transaction } = resolved;\n            const result = {\n                request: resolved.request,\n                serializedTransaction,\n                transaction,\n                signatures,\n                payload,\n                signer,\n            };\n            if (broadcast) {\n                const res = await this.rpc.push_transaction({\n                    signatures: result.signatures,\n                    serializedTransaction: result.serializedTransaction,\n                });\n                result.processed = res.processed;\n            }\n            if (t.onSuccess) {\n                t.onSuccess(request, result);\n            }\n            return result;\n        }\n        catch (error) {\n            if (t.onFailure) {\n                t.onFailure(request, error);\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sign and optionally broadcast a EOSIO transaction, action or actions.\n     *\n     * Example:\n     *\n     * ```ts\n     * let result = await myLink.transact({transaction: myTx})\n     * ```\n     *\n     * @param args The action, actions or transaction to use.\n     * @param options Options for this transact call.\n     * @param transport Transport override, for internal use.\n     */\n    async transact(args, options, transport) {\n        const t = transport || this.transport;\n        const broadcast = options ? options.broadcast !== false : true;\n        // Initialize the loading state of the transport\n        if (t && t.showLoading) {\n            t.showLoading();\n        }\n        // eosjs transact compat: upgrade to transaction if args have any header fields\n        let anyArgs = args;\n        if (args.actions &&\n            (anyArgs.expiration ||\n                anyArgs.ref_block_num ||\n                anyArgs.ref_block_prefix ||\n                anyArgs.max_net_usage_words ||\n                anyArgs.max_cpu_usage_ms ||\n                anyArgs.delay_sec)) {\n            args = {\n                transaction: {\n                    expiration: '1970-01-01T00:00:00',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_net_usage_words: 0,\n                    max_cpu_usage_ms: 0,\n                    delay_sec: 0,\n                    ...anyArgs,\n                },\n            };\n        }\n        const request = await this.createRequest(args, t);\n        const result = await this.sendRequest(request, t, broadcast);\n        return result;\n    }\n    /**\n     * Send an identity request and verify the identity proof.\n     * @param requestPermission Optional request permission if the request is for a specific account or permission.\n     * @param info Metadata to add to the request.\n     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n     */\n    async identify(requestPermission, info) {\n        const request = await this.createRequest({\n            identity: { permission: requestPermission || null },\n            info,\n        });\n        const res = await this.sendRequest(request);\n        if (!res.request.isIdentity()) {\n            throw new IdentityError(`Unexpected response`);\n        }\n        const message = Buffer.concat([\n            Buffer.from(request.getChainId(), 'hex'),\n            Buffer.from(res.serializedTransaction),\n            Buffer.alloc(32),\n        ]);\n        const { signer } = res;\n        const signerKey = ecc.recover(res.signatures[0], message);\n        const account = await this.rpc.get_account(signer.actor);\n        if (!account) {\n            throw new IdentityError(`Signature from unknown account: ${signer.actor}`);\n        }\n        const permission = account.permissions.find(({ perm_name }) => perm_name === signer.permission);\n        if (!permission) {\n            throw new IdentityError(`${signer.actor} signed for unknown permission: ${signer.permission}`);\n        }\n        const auth = permission.required_auth;\n        const keyAuth = auth.keys.find(({ key }) => publicKeyEqual(key, signerKey));\n        if (!keyAuth) {\n            throw new IdentityError(`${formatAuth(signer)} has no key matching id signature`);\n        }\n        if (auth.threshold > keyAuth.weight) {\n            throw new IdentityError(`${formatAuth(signer)} signature does not reach auth threshold`);\n        }\n        if (requestPermission) {\n            if ((requestPermission.actor !== esr.PlaceholderName &&\n                requestPermission.actor !== signer.actor) ||\n                (requestPermission.permission !== esr.PlaceholderPermission &&\n                    requestPermission.permission !== signer.permission)) {\n                throw new IdentityError(`Unexpected identity proof from ${formatAuth(signer)}, expected ${formatAuth(requestPermission)} `);\n            }\n        }\n        return {\n            ...res,\n            account,\n            signerKey,\n        };\n    }\n    /**\n     * Login and create a persistent session.\n     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n     *                   Should be set to the contract account if applicable.\n     */\n    async login(identifier) {\n        const privateKey = await generatePrivateKey();\n        const requestKey = ecc.privateToPublic(privateKey);\n        const createInfo = {\n            session_name: identifier,\n            request_key: requestKey,\n        };\n        const res = await this.identify(undefined, {\n            link: abiEncode(createInfo, 'link_create'),\n        });\n        const metadata = { sameDevice: res.request.getRawInfo()['return_path'] !== undefined };\n        let session;\n        if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n            session = new LinkChannelSession(this, {\n                identifier,\n                auth: res.signer,\n                publicKey: res.signerKey,\n                channel: {\n                    url: res.payload.link_ch,\n                    key: res.payload.link_key,\n                    name: res.payload.link_name,\n                },\n                requestKey: privateKey,\n            }, metadata);\n        }\n        else {\n            session = new LinkFallbackSession(this, {\n                identifier,\n                auth: res.signer,\n                publicKey: res.signerKey,\n            }, metadata);\n        }\n        if (this.storage) {\n            await this.storeSession(identifier, session);\n        }\n        return {\n            ...res,\n            session,\n        };\n    }\n    /**\n     * Restore previous session, see [[Link.login]] to create a new session.\n     * @param identifier The session identifier, should be same as what was used when creating the session with [[Link.login]].\n     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n     * @returns A [[LinkSession]] instance or null if no session can be found.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n     **/\n    async restoreSession(identifier, auth) {\n        if (!this.storage) {\n            throw new Error('Unable to restore session: No storage adapter configured');\n        }\n        let key;\n        if (auth) {\n            key = this.sessionKey(identifier, formatAuth(auth));\n        }\n        else {\n            let latest = (await this.listSessions(identifier))[0];\n            if (!latest) {\n                return null;\n            }\n            key = this.sessionKey(identifier, formatAuth(latest));\n        }\n        let data = await this.storage.read(key);\n        if (!data) {\n            return null;\n        }\n        let sessionData;\n        try {\n            sessionData = JSON.parse(data);\n        }\n        catch (error) {\n            throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);\n        }\n        const session = LinkSession.restore(this, sessionData);\n        if (auth) {\n            // update latest used\n            await this.touchSession(identifier, auth);\n        }\n        return session;\n    }\n    /**\n     * List stored session auths for given identifier.\n     * The most recently used session is at the top (index 0).\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n     **/\n    async listSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to list sessions: No storage adapter configured');\n        }\n        let key = this.sessionKey(identifier, 'list');\n        let list;\n        try {\n            list = JSON.parse((await this.storage.read(key)) || '[]');\n        }\n        catch (error) {\n            throw new Error(`Unable to list sessions: Stored JSON invalid (${error.message || String(error)})`);\n        }\n        return list;\n    }\n    /**\n     * Remove stored session for given identifier and auth.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async removeSession(identifier, auth) {\n        if (!this.storage) {\n            throw new Error('Unable to remove session: No storage adapter configured');\n        }\n        let key = this.sessionKey(identifier, formatAuth(auth));\n        await this.storage.remove(key);\n        await this.touchSession(identifier, auth, true);\n    }\n    /**\n     * Remove all stored sessions for given identifier.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async clearSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to clear sessions: No storage adapter configured');\n        }\n        for (const auth of await this.listSessions(identifier)) {\n            await this.removeSession(identifier, auth);\n        }\n    }\n    /**\n     * Create an eosjs compatible signature provider using this link.\n     * @param availableKeys Keys the created provider will claim to be able to sign for.\n     * @param transport (internal) Transport override for this call.\n     * @note We don't know what keys are available so those have to be provided,\n     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n     */\n    makeSignatureProvider(availableKeys, transport) {\n        return {\n            getAvailableKeys: async () => availableKeys,\n            sign: async (args) => {\n                const t = transport || this.transport;\n                let request = esr.SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, this.requestOptions);\n                request.setCallback(this.createCallbackUrl(), true);\n                request.setBroadcast(false);\n                if (t.prepare) {\n                    request = await t.prepare(request);\n                }\n                const { serializedTransaction, signatures, } = await this.sendRequest(request, t);\n                return {\n                    ...args,\n                    serializedTransaction,\n                    signatures,\n                };\n            },\n        };\n    }\n    /**\n     * Create an eosjs authority provider using this link.\n     * @note Uses the configured RPC Node's `/v1/chain/get_required_keys` API to resolve keys.\n     */\n    makeAuthorityProvider() {\n        const { rpc } = this;\n        return {\n            async getRequiredKeys(args) {\n                const { availableKeys, transaction } = args;\n                const result = await rpc.fetch('/v1/chain/get_required_keys', {\n                    transaction,\n                    available_keys: availableKeys.map(normalizePublicKey),\n                });\n                return result.required_keys.map(normalizePublicKey);\n            },\n        };\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async touchSession(identifier, auth, remove = false) {\n        let auths = await this.listSessions(identifier);\n        let formattedAuth = formatAuth(auth);\n        let existing = auths.findIndex((a) => formatAuth(a) === formattedAuth);\n        if (existing >= 0) {\n            auths.splice(existing, 1);\n        }\n        if (remove === false) {\n            auths.unshift(auth);\n        }\n        let key = this.sessionKey(identifier, 'list');\n        await this.storage.write(key, JSON.stringify(auths));\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async storeSession(identifier, session) {\n        let key = this.sessionKey(identifier, formatAuth(session.auth));\n        let data = JSON.stringify(session.serialize());\n        await this.storage.write(key, data);\n        await this.touchSession(identifier, session.auth);\n    }\n    /** Session storage key for identifier and suffix. */\n    sessionKey(identifier, suffix) {\n        return [this.chainId, identifier, suffix].join('-');\n    }\n}\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\nfunction waitForCallback(url, ctx) {\n    return new Promise((resolve, reject) => {\n        let active = true;\n        let retries = 0;\n        const socketUrl = url.replace(/^http/, 'ws');\n        const handleResponse = (response) => {\n            try {\n                resolve(JSON.parse(response));\n            }\n            catch (error) {\n                error.message = 'Unable to parse callback JSON: ' + error.message;\n                reject(error);\n            }\n        };\n        const connect = () => {\n            const socket = new WebSocket(socketUrl);\n            ctx.cancel = () => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN ||\n                    socket.readyState === WebSocket.CONNECTING) {\n                    socket.close();\n                }\n            };\n            socket.onmessage = (event) => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN) {\n                    socket.close();\n                }\n                if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n                    const reader = new FileReader();\n                    reader.onload = () => {\n                        handleResponse(reader.result);\n                    };\n                    reader.onerror = (error) => {\n                        reject(error);\n                    };\n                    reader.readAsText(event.data);\n                }\n                else {\n                    if (typeof event.data === 'string') {\n                        handleResponse(event.data);\n                    }\n                    else {\n                        handleResponse(event.data.toString());\n                    }\n                }\n            };\n            socket.onopen = () => {\n                retries = 0;\n            };\n            socket.onerror = (error) => { };\n            socket.onclose = (close) => {\n                if (active) {\n                    setTimeout(connect, backoff(retries++));\n                }\n            };\n        };\n        connect();\n    });\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\nfunction backoff(tries) {\n    return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\nfunction formatAuth(auth) {\n    let { actor, permission } = auth;\n    if (actor === esr.PlaceholderName) {\n        actor = '<any>';\n    }\n    if (permission === esr.PlaceholderName || permission === esr.PlaceholderPermission) {\n        permission = '<any>';\n    }\n    return `${actor}@${permission}`;\n}\n//# sourceMappingURL=link.js.map"]},"metadata":{},"sourceType":"module"}