{"ast":null,"code":"\"use strict\";\n\nvar assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa\n\n\nvar crypto = require('./hash');\n\nvar enforceType = require('./enforce_types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature'); // https://tools.ietf.org/html/rfc6979#section-3.2\n\n\nfunction deterministicGenerateK(curve, hash, d, checkSig, nonce) {\n  enforceType('Buffer', hash);\n  enforceType(BigInteger, d);\n\n  if (nonce) {\n    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));\n  } // sanity check\n\n\n  assert.equal(hash.length, 32, 'Hash must be 256 bit');\n  var x = d.toBuffer(32);\n  var k = new Buffer(32);\n  var v = new Buffer(32); // Step B\n\n  v.fill(1); // Step C\n\n  k.fill(0); // Step D\n\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k); // Step E\n\n  v = crypto.HmacSHA256(v, k); // Step F\n\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k); // Step G\n\n  v = crypto.HmacSHA256(v, k); // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n\n  v = crypto.HmacSHA256(v, k);\n  var T = BigInteger.fromBuffer(v); // Step H3, repeat until T is within the interval [1, n - 1]\n\n  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {\n    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);\n    v = crypto.HmacSHA256(v, k); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n\n    v = crypto.HmacSHA256(v, k);\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nfunction sign(curve, hash, d, nonce) {\n  var e = BigInteger.fromBuffer(hash);\n  var n = curve.n;\n  var G = curve.G;\n  var r, s;\n  var k = deterministicGenerateK(curve, hash, d, function (k) {\n    // find canonically valid signature\n    var Q = G.multiply(k);\n    if (curve.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  }, nonce);\n  var N_OVER_TWO = n.shiftRight(1); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return ECSignature(r, s);\n}\n\nfunction verifyRaw(curve, e, signature, Q) {\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s; // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false; // c = s^-1 mod n\n\n  var c = s.modInverse(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  var u1 = e.multiply(c).mod(n);\n  var u2 = r.multiply(c).mod(n); // 1.4.5 Compute R = (xR, yR) = u1G + u2Q\n\n  var R = G.multiplyTwo(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (curve.isInfinity(R)) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  var xR = R.affineX; // 1.4.7 Set v = xR mod n\n\n  var v = xR.mod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.equals(r);\n}\n\nfunction verify(curve, hash, signature, Q) {\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash);\n  return verifyRaw(curve, e, signature, Q);\n}\n/**\n  * Recover a public key from a signature.\n  *\n  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\n  * Key Recovery Operation\".\n  *\n  * http://www.secg.org/download/aid-780/sec1-v2.pdf\n  */\n\n\nfunction recoverPubKey(curve, e, signature, i) {\n  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s;\n  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');\n  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value'); // A set LSB signifies that the y-coordinate is odd\n\n  var isYOdd = i & 1; // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n\n  var isSecondKey = i >> 1; // 1.1 Let x = r + jn\n\n  var x = isSecondKey ? r.add(n) : r;\n  var R = curve.pointFromX(isYOdd, x); // 1.4 Check that nR is at infinity\n\n  var nR = R.multiply(n);\n  assert(curve.isInfinity(nR), 'nR is not a valid curve point'); // Compute -e from e\n\n  var eNeg = e.negate().mod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n\n  var rInv = r.modInverse(n);\n  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);\n  curve.validate(Q);\n  return Q;\n}\n/**\n  * Calculate pubkey extraction parameter.\n  *\n  * When extracting a pubkey from a signature, we have to\n  * distinguish four different cases. Rather than putting this\n  * burden on the verifier, Bitcoin includes a 2-bit value with the\n  * signature.\n  *\n  * This function simply tries all four cases and returns the value\n  * that resulted in a successful pubkey recovery.\n  */\n\n\nfunction calcPubKeyRecoveryParam(curve, e, signature, Q) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime = recoverPubKey(curve, e, signature, i); // 1.6.2 Verify Q\n\n    if (Qprime.equals(Q)) {\n      return i;\n    }\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n}\n\nmodule.exports = {\n  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,\n  deterministicGenerateK: deterministicGenerateK,\n  recoverPubKey: recoverPubKey,\n  sign: sign,\n  verify: verify,\n  verifyRaw: verifyRaw\n};","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosjs-ecc/lib/ecdsa.js"],"names":["assert","require","crypto","enforceType","BigInteger","ECSignature","deterministicGenerateK","curve","hash","d","checkSig","nonce","sha256","Buffer","concat","equal","length","x","toBuffer","k","v","fill","HmacSHA256","T","fromBuffer","signum","compareTo","n","sign","e","G","r","s","Q","multiply","isInfinity","affineX","mod","modInverse","add","N_OVER_TWO","shiftRight","subtract","verifyRaw","signature","c","u1","u2","R","multiplyTwo","xR","equals","verify","recoverPubKey","i","strictEqual","isYOdd","isSecondKey","pointFromX","nR","eNeg","negate","rInv","validate","calcPubKeyRecoveryParam","Qprime","Error","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar assert = require('assert'); // from github.com/bitcoinjs/bitcoinjs-lib from github.com/cryptocoinjs/ecdsa\n\n\nvar crypto = require('./hash');\n\nvar enforceType = require('./enforce_types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature'); // https://tools.ietf.org/html/rfc6979#section-3.2\n\n\nfunction deterministicGenerateK(curve, hash, d, checkSig, nonce) {\n  enforceType('Buffer', hash);\n  enforceType(BigInteger, d);\n\n  if (nonce) {\n    hash = crypto.sha256(Buffer.concat([hash, new Buffer(nonce)]));\n  } // sanity check\n\n\n  assert.equal(hash.length, 32, 'Hash must be 256 bit');\n  var x = d.toBuffer(32);\n  var k = new Buffer(32);\n  var v = new Buffer(32); // Step B\n\n  v.fill(1); // Step C\n\n  k.fill(0); // Step D\n\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0]), x, hash]), k); // Step E\n\n  v = crypto.HmacSHA256(v, k); // Step F\n\n  k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([1]), x, hash]), k); // Step G\n\n  v = crypto.HmacSHA256(v, k); // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n\n  v = crypto.HmacSHA256(v, k);\n  var T = BigInteger.fromBuffer(v); // Step H3, repeat until T is within the interval [1, n - 1]\n\n  while (T.signum() <= 0 || T.compareTo(curve.n) >= 0 || !checkSig(T)) {\n    k = crypto.HmacSHA256(Buffer.concat([v, new Buffer([0])]), k);\n    v = crypto.HmacSHA256(v, k); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n\n    v = crypto.HmacSHA256(v, k);\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nfunction sign(curve, hash, d, nonce) {\n  var e = BigInteger.fromBuffer(hash);\n  var n = curve.n;\n  var G = curve.G;\n  var r, s;\n  var k = deterministicGenerateK(curve, hash, d, function (k) {\n    // find canonically valid signature\n    var Q = G.multiply(k);\n    if (curve.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  }, nonce);\n  var N_OVER_TWO = n.shiftRight(1); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return ECSignature(r, s);\n}\n\nfunction verifyRaw(curve, e, signature, Q) {\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s; // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false; // c = s^-1 mod n\n\n  var c = s.modInverse(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  var u1 = e.multiply(c).mod(n);\n  var u2 = r.multiply(c).mod(n); // 1.4.5 Compute R = (xR, yR) = u1G + u2Q\n\n  var R = G.multiplyTwo(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (curve.isInfinity(R)) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  var xR = R.affineX; // 1.4.7 Set v = xR mod n\n\n  var v = xR.mod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.equals(r);\n}\n\nfunction verify(curve, hash, signature, Q) {\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  var e = BigInteger.fromBuffer(hash);\n  return verifyRaw(curve, e, signature, Q);\n}\n/**\n  * Recover a public key from a signature.\n  *\n  * See SEC 1: Elliptic Curve Cryptography, section 4.1.6, \"Public\n  * Key Recovery Operation\".\n  *\n  * http://www.secg.org/download/aid-780/sec1-v2.pdf\n  */\n\n\nfunction recoverPubKey(curve, e, signature, i) {\n  assert.strictEqual(i & 3, i, 'Recovery param is more than two bits');\n  var n = curve.n;\n  var G = curve.G;\n  var r = signature.r;\n  var s = signature.s;\n  assert(r.signum() > 0 && r.compareTo(n) < 0, 'Invalid r value');\n  assert(s.signum() > 0 && s.compareTo(n) < 0, 'Invalid s value'); // A set LSB signifies that the y-coordinate is odd\n\n  var isYOdd = i & 1; // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n\n  var isSecondKey = i >> 1; // 1.1 Let x = r + jn\n\n  var x = isSecondKey ? r.add(n) : r;\n  var R = curve.pointFromX(isYOdd, x); // 1.4 Check that nR is at infinity\n\n  var nR = R.multiply(n);\n  assert(curve.isInfinity(nR), 'nR is not a valid curve point'); // Compute -e from e\n\n  var eNeg = e.negate().mod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n\n  var rInv = r.modInverse(n);\n  var Q = R.multiplyTwo(s, G, eNeg).multiply(rInv);\n  curve.validate(Q);\n  return Q;\n}\n/**\n  * Calculate pubkey extraction parameter.\n  *\n  * When extracting a pubkey from a signature, we have to\n  * distinguish four different cases. Rather than putting this\n  * burden on the verifier, Bitcoin includes a 2-bit value with the\n  * signature.\n  *\n  * This function simply tries all four cases and returns the value\n  * that resulted in a successful pubkey recovery.\n  */\n\n\nfunction calcPubKeyRecoveryParam(curve, e, signature, Q) {\n  for (var i = 0; i < 4; i++) {\n    var Qprime = recoverPubKey(curve, e, signature, i); // 1.6.2 Verify Q\n\n    if (Qprime.equals(Q)) {\n      return i;\n    }\n  }\n\n  throw new Error('Unable to find valid recovery factor');\n}\n\nmodule.exports = {\n  calcPubKeyRecoveryParam: calcPubKeyRecoveryParam,\n  deterministicGenerateK: deterministicGenerateK,\n  recoverPubKey: recoverPubKey,\n  sign: sign,\n  verify: verify,\n  verifyRaw: verifyRaw\n};"]},"metadata":{},"sourceType":"script"}