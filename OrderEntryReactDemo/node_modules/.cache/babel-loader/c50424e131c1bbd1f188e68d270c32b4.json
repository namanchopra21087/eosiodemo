{"ast":null,"code":"\"use strict\";\n\nvar randomBytes = require('randombytes');\n\nvar ByteBuffer = require('bytebuffer');\n\nvar crypto = require('browserify-aes');\n\nvar assert = require('assert');\n\nvar PublicKey = require('./key_public');\n\nvar PrivateKey = require('./key_private');\n\nvar hash = require('./hash');\n\nvar Long = ByteBuffer.Long;\nmodule.exports = {\n  encrypt: encrypt,\n  decrypt: decrypt\n};\n/**\n    Spec: http://localhost:3002/steem/@dantheman/how-to-encrypt-a-memo-when-transferring-steem\n\n    @throws {Error|TypeError} - \"Invalid Key, ...\"\n\n    @arg {PrivateKey} private_key - required and used for decryption\n    @arg {PublicKey} public_key - required and used to calcualte the shared secret\n    @arg {string} [nonce = uniqueNonce()] - assigned a random unique uint64\n\n    @return {object}\n    @property {string} nonce - random or unique uint64, provides entropy when re-using the same private/public keys.\n    @property {Buffer} message - Plain text message\n    @property {number} checksum - shared secret checksum\n*/\n\nfunction encrypt(private_key, public_key, message) {\n  var nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uniqueNonce();\n  return crypt(private_key, public_key, nonce, message);\n}\n/**\n    Spec: http://localhost:3002/steem/@dantheman/how-to-encrypt-a-memo-when-transferring-steem\n\n    @arg {PrivateKey} private_key - required and used for decryption\n    @arg {PublicKey} public_key - required and used to calcualte the shared secret\n    @arg {string} nonce - random or unique uint64, provides entropy when re-using the same private/public keys.\n    @arg {Buffer} message - Encrypted or plain text message\n    @arg {number} checksum - shared secret checksum\n\n    @throws {Error|TypeError} - \"Invalid Key, ...\"\n\n    @return {Buffer} - message\n*/\n\n\nfunction decrypt(private_key, public_key, nonce, message, checksum) {\n  return crypt(private_key, public_key, nonce, message, checksum).message;\n}\n/**\n    @arg {Buffer} message - Encrypted or plain text message (see checksum)\n    @arg {number} checksum - shared secret checksum (null to encrypt, non-null to decrypt)\n    @private\n*/\n\n\nfunction crypt(private_key, public_key, nonce, message, checksum) {\n  private_key = PrivateKey(private_key);\n  if (!private_key) throw new TypeError('private_key is required');\n  public_key = PublicKey(public_key);\n  if (!public_key) throw new TypeError('public_key is required');\n  nonce = toLongObj(nonce);\n  if (!nonce) throw new TypeError('nonce is required');\n\n  if (!Buffer.isBuffer(message)) {\n    if (typeof message !== 'string') throw new TypeError('message should be buffer or string');\n    message = new Buffer(message, 'binary');\n  }\n\n  if (checksum && typeof checksum !== 'number') throw new TypeError('checksum should be a number');\n  var S = private_key.getSharedSecret(public_key);\n  var ebuf = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n  ebuf.writeUint64(nonce);\n  ebuf.append(S.toString('binary'), 'binary');\n  ebuf = new Buffer(ebuf.copy(0, ebuf.offset).toBinary(), 'binary');\n  var encryption_key = hash.sha512(ebuf); // D E B U G\n  // console.log('crypt', {\n  //     priv_to_pub: private_key.toPublic().toString(),\n  //     pub: public_key.toString(),\n  //     nonce: nonce.toString(),\n  //     message: message.length,\n  //     checksum,\n  //     S: S.toString('hex'),\n  //     encryption_key: encryption_key.toString('hex'),\n  // })\n\n  var iv = encryption_key.slice(32, 48);\n  var key = encryption_key.slice(0, 32); // check is first 64 bit of sha256 hash treated as uint64_t truncated to 32 bits.\n\n  var check = hash.sha256(encryption_key);\n  check = check.slice(0, 4);\n  var cbuf = ByteBuffer.fromBinary(check.toString('binary'), ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n  check = cbuf.readUint32();\n\n  if (checksum) {\n    if (check !== checksum) throw new Error('Invalid key');\n    message = cryptoJsDecrypt(message, key, iv);\n  } else {\n    message = cryptoJsEncrypt(message, key, iv);\n  }\n\n  return {\n    nonce: nonce,\n    message: message,\n    checksum: check\n  };\n}\n/** This method does not use a checksum, the returned data must be validated some other way.\n\n    @arg {string|Buffer} message - ciphertext binary format\n    @arg {string<utf8>|Buffer} key - 256bit\n    @arg {string<utf8>|Buffer} iv - 128bit\n\n    @return {Buffer}\n*/\n\n\nfunction cryptoJsDecrypt(message, key, iv) {\n  assert(message, \"Missing cipher text\");\n  message = toBinaryBuffer(message);\n  var decipher = crypto.createDecipheriv('aes-256-cbc', key, iv); // decipher.setAutoPadding(true)\n\n  message = Buffer.concat([decipher.update(message), decipher[\"final\"]()]);\n  return message;\n}\n/** This method does not use a checksum, the returned data must be validated some other way.\n    @arg {string|Buffer} message - plaintext binary format\n    @arg {string<utf8>|Buffer} key - 256bit\n    @arg {string<utf8>|Buffer} iv - 128bit\n\n    @return {Buffer}\n*/\n\n\nfunction cryptoJsEncrypt(message, key, iv) {\n  assert(message, \"Missing plain text\");\n  message = toBinaryBuffer(message);\n  var cipher = crypto.createCipheriv('aes-256-cbc', key, iv); // cipher.setAutoPadding(true)\n\n  message = Buffer.concat([cipher.update(message), cipher[\"final\"]()]);\n  return message;\n}\n/** @return {string} unique 64 bit unsigned number string.  Being time based, this is careful to never choose the same nonce twice.  This value could be recorded in the blockchain for a long time.\n*/\n\n\nfunction uniqueNonce() {\n  if (unique_nonce_entropy === null) {\n    var b = new Uint8Array(randomBytes(2));\n    unique_nonce_entropy = parseInt(b[0] << 8 | b[1], 10);\n  }\n\n  var _long = Long.fromNumber(Date.now());\n\n  var entropy = ++unique_nonce_entropy % 0xFFFF; // console.log('uniqueNonce date\\t', ByteBuffer.allocate(8).writeUint64(long).toHex(0))\n  // console.log('uniqueNonce entropy\\t', ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))\n\n  _long = _long.shiftLeft(16).or(Long.fromNumber(entropy)); // console.log('uniqueNonce final\\t', ByteBuffer.allocate(8).writeUint64(long).toHex(0))\n\n  return _long.toString();\n}\n\nvar unique_nonce_entropy = null; // for(let i=1; i < 10; i++) key.uniqueNonce()\n\nvar toLongObj = function toLongObj(o) {\n  return o ? Long.isLong(o) ? o : Long.fromString(o) : o;\n};\n\nvar toBinaryBuffer = function toBinaryBuffer(o) {\n  return o ? Buffer.isBuffer(o) ? o : new Buffer(o, 'binary') : o;\n};","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosjs-ecc/lib/aes.js"],"names":["randomBytes","require","ByteBuffer","crypto","assert","PublicKey","PrivateKey","hash","Long","module","exports","encrypt","decrypt","private_key","public_key","message","nonce","arguments","length","undefined","uniqueNonce","crypt","checksum","TypeError","toLongObj","Buffer","isBuffer","S","getSharedSecret","ebuf","DEFAULT_CAPACITY","LITTLE_ENDIAN","writeUint64","append","toString","copy","offset","toBinary","encryption_key","sha512","iv","slice","key","check","sha256","cbuf","fromBinary","readUint32","Error","cryptoJsDecrypt","cryptoJsEncrypt","toBinaryBuffer","decipher","createDecipheriv","concat","update","cipher","createCipheriv","unique_nonce_entropy","b","Uint8Array","parseInt","_long","fromNumber","Date","now","entropy","shiftLeft","or","o","isLong","fromString"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar randomBytes = require('randombytes');\n\nvar ByteBuffer = require('bytebuffer');\n\nvar crypto = require('browserify-aes');\n\nvar assert = require('assert');\n\nvar PublicKey = require('./key_public');\n\nvar PrivateKey = require('./key_private');\n\nvar hash = require('./hash');\n\nvar Long = ByteBuffer.Long;\nmodule.exports = {\n  encrypt: encrypt,\n  decrypt: decrypt\n};\n/**\n    Spec: http://localhost:3002/steem/@dantheman/how-to-encrypt-a-memo-when-transferring-steem\n\n    @throws {Error|TypeError} - \"Invalid Key, ...\"\n\n    @arg {PrivateKey} private_key - required and used for decryption\n    @arg {PublicKey} public_key - required and used to calcualte the shared secret\n    @arg {string} [nonce = uniqueNonce()] - assigned a random unique uint64\n\n    @return {object}\n    @property {string} nonce - random or unique uint64, provides entropy when re-using the same private/public keys.\n    @property {Buffer} message - Plain text message\n    @property {number} checksum - shared secret checksum\n*/\n\nfunction encrypt(private_key, public_key, message) {\n  var nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uniqueNonce();\n  return crypt(private_key, public_key, nonce, message);\n}\n/**\n    Spec: http://localhost:3002/steem/@dantheman/how-to-encrypt-a-memo-when-transferring-steem\n\n    @arg {PrivateKey} private_key - required and used for decryption\n    @arg {PublicKey} public_key - required and used to calcualte the shared secret\n    @arg {string} nonce - random or unique uint64, provides entropy when re-using the same private/public keys.\n    @arg {Buffer} message - Encrypted or plain text message\n    @arg {number} checksum - shared secret checksum\n\n    @throws {Error|TypeError} - \"Invalid Key, ...\"\n\n    @return {Buffer} - message\n*/\n\n\nfunction decrypt(private_key, public_key, nonce, message, checksum) {\n  return crypt(private_key, public_key, nonce, message, checksum).message;\n}\n/**\n    @arg {Buffer} message - Encrypted or plain text message (see checksum)\n    @arg {number} checksum - shared secret checksum (null to encrypt, non-null to decrypt)\n    @private\n*/\n\n\nfunction crypt(private_key, public_key, nonce, message, checksum) {\n  private_key = PrivateKey(private_key);\n  if (!private_key) throw new TypeError('private_key is required');\n  public_key = PublicKey(public_key);\n  if (!public_key) throw new TypeError('public_key is required');\n  nonce = toLongObj(nonce);\n  if (!nonce) throw new TypeError('nonce is required');\n\n  if (!Buffer.isBuffer(message)) {\n    if (typeof message !== 'string') throw new TypeError('message should be buffer or string');\n    message = new Buffer(message, 'binary');\n  }\n\n  if (checksum && typeof checksum !== 'number') throw new TypeError('checksum should be a number');\n  var S = private_key.getSharedSecret(public_key);\n  var ebuf = new ByteBuffer(ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n  ebuf.writeUint64(nonce);\n  ebuf.append(S.toString('binary'), 'binary');\n  ebuf = new Buffer(ebuf.copy(0, ebuf.offset).toBinary(), 'binary');\n  var encryption_key = hash.sha512(ebuf); // D E B U G\n  // console.log('crypt', {\n  //     priv_to_pub: private_key.toPublic().toString(),\n  //     pub: public_key.toString(),\n  //     nonce: nonce.toString(),\n  //     message: message.length,\n  //     checksum,\n  //     S: S.toString('hex'),\n  //     encryption_key: encryption_key.toString('hex'),\n  // })\n\n  var iv = encryption_key.slice(32, 48);\n  var key = encryption_key.slice(0, 32); // check is first 64 bit of sha256 hash treated as uint64_t truncated to 32 bits.\n\n  var check = hash.sha256(encryption_key);\n  check = check.slice(0, 4);\n  var cbuf = ByteBuffer.fromBinary(check.toString('binary'), ByteBuffer.DEFAULT_CAPACITY, ByteBuffer.LITTLE_ENDIAN);\n  check = cbuf.readUint32();\n\n  if (checksum) {\n    if (check !== checksum) throw new Error('Invalid key');\n    message = cryptoJsDecrypt(message, key, iv);\n  } else {\n    message = cryptoJsEncrypt(message, key, iv);\n  }\n\n  return {\n    nonce: nonce,\n    message: message,\n    checksum: check\n  };\n}\n/** This method does not use a checksum, the returned data must be validated some other way.\n\n    @arg {string|Buffer} message - ciphertext binary format\n    @arg {string<utf8>|Buffer} key - 256bit\n    @arg {string<utf8>|Buffer} iv - 128bit\n\n    @return {Buffer}\n*/\n\n\nfunction cryptoJsDecrypt(message, key, iv) {\n  assert(message, \"Missing cipher text\");\n  message = toBinaryBuffer(message);\n  var decipher = crypto.createDecipheriv('aes-256-cbc', key, iv); // decipher.setAutoPadding(true)\n\n  message = Buffer.concat([decipher.update(message), decipher[\"final\"]()]);\n  return message;\n}\n/** This method does not use a checksum, the returned data must be validated some other way.\n    @arg {string|Buffer} message - plaintext binary format\n    @arg {string<utf8>|Buffer} key - 256bit\n    @arg {string<utf8>|Buffer} iv - 128bit\n\n    @return {Buffer}\n*/\n\n\nfunction cryptoJsEncrypt(message, key, iv) {\n  assert(message, \"Missing plain text\");\n  message = toBinaryBuffer(message);\n  var cipher = crypto.createCipheriv('aes-256-cbc', key, iv); // cipher.setAutoPadding(true)\n\n  message = Buffer.concat([cipher.update(message), cipher[\"final\"]()]);\n  return message;\n}\n/** @return {string} unique 64 bit unsigned number string.  Being time based, this is careful to never choose the same nonce twice.  This value could be recorded in the blockchain for a long time.\n*/\n\n\nfunction uniqueNonce() {\n  if (unique_nonce_entropy === null) {\n    var b = new Uint8Array(randomBytes(2));\n    unique_nonce_entropy = parseInt(b[0] << 8 | b[1], 10);\n  }\n\n  var _long = Long.fromNumber(Date.now());\n\n  var entropy = ++unique_nonce_entropy % 0xFFFF; // console.log('uniqueNonce date\\t', ByteBuffer.allocate(8).writeUint64(long).toHex(0))\n  // console.log('uniqueNonce entropy\\t', ByteBuffer.allocate(8).writeUint64(Long.fromNumber(entropy)).toHex(0))\n\n  _long = _long.shiftLeft(16).or(Long.fromNumber(entropy)); // console.log('uniqueNonce final\\t', ByteBuffer.allocate(8).writeUint64(long).toHex(0))\n\n  return _long.toString();\n}\n\nvar unique_nonce_entropy = null; // for(let i=1; i < 10; i++) key.uniqueNonce()\n\nvar toLongObj = function toLongObj(o) {\n  return o ? Long.isLong(o) ? o : Long.fromString(o) : o;\n};\n\nvar toBinaryBuffer = function toBinaryBuffer(o) {\n  return o ? Buffer.isBuffer(o) ? o : new Buffer(o, 'binary') : o;\n};"]},"metadata":{},"sourceType":"script"}