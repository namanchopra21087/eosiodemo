{"ast":null,"code":"\"use strict\";\n\nvar Aes = require(\"./aes\");\n\nvar PrivateKey = require(\"./key_private\");\n\nvar PublicKey = require(\"./key_public\");\n\nvar Signature = require(\"./signature\");\n\nvar key_utils = require(\"./key_utils\");\n\nvar hash = require(\"./hash\");\n/**\n    [Wallet Import Format](https://en.bitcoin.it/wiki/Wallet_import_format)\n    @typedef {string} wif\n*/\n\n/**\n    EOSKey..\n    @typedef {string} pubkey\n*/\n\n/** @namespace */\n\n\nvar ecc = {\n  /**\n    Initialize by running some self-checking code.  This should take a\n    second to gather additional CPU entropy used during private key\n    generation.\n     Initialization happens once even if called multiple times.\n     @return {Promise}\n  */\n  initialize: PrivateKey.initialize,\n\n  /**\n    Does not pause to gather CPU entropy.\n    @return {Promise<PrivateKey>} test key\n  */\n  unsafeRandomKey: function unsafeRandomKey() {\n    return PrivateKey.unsafeRandomKey().then(function (key) {\n      return key.toString();\n    });\n  },\n\n  /**\n      @arg {number} [cpuEntropyBits = 0] gather additional entropy\n      from a CPU mining algorithm.  This will already happen once by\n      default.\n       @return {Promise<wif>}\n       @example\n  ecc.randomKey().then(privateKey => {\n  console.log('Private Key:\\t', privateKey) // wif\n  console.log('Public Key:\\t', ecc.privateToPublic(privateKey)) // EOSkey...\n  })\n  */\n  randomKey: function randomKey(cpuEntropyBits) {\n    return PrivateKey.randomKey(cpuEntropyBits).then(function (key) {\n      return key.toString();\n    });\n  },\n\n  /**\n       @arg {string} seed - any length string.  This is private.  The same\n      seed produces the same private key every time.  At least 128 random\n      bits should be used to produce a good private key.\n      @return {wif}\n       @example ecc.seedPrivate('secret') === wif\n  */\n  seedPrivate: function seedPrivate(seed) {\n    return PrivateKey.fromSeed(seed).toString();\n  },\n\n  /**\n      @arg {wif} wif\n      @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n       @return {pubkey}\n       @example ecc.privateToPublic(wif) === pubkey\n  */\n  privateToPublic: function privateToPublic(wif) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n    return PrivateKey(wif).toPublic().toString(pubkey_prefix);\n  },\n\n  /**\n      @arg {pubkey} pubkey - like EOSKey..\n      @arg {string} [pubkey_prefix = 'EOS']\n       @return {boolean} valid\n       @example ecc.isValidPublic(pubkey) === true\n  */\n  isValidPublic: function isValidPublic(pubkey) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n    return PublicKey.isValid(pubkey, pubkey_prefix);\n  },\n\n  /**\n      @arg {wif} wif\n      @return {boolean} valid\n       @example ecc.isValidPrivate(wif) === true\n  */\n  isValidPrivate: function isValidPrivate(wif) {\n    return PrivateKey.isValid(wif);\n  },\n\n  /**\n      Create a signature using data or a hash.\n       @arg {string|Buffer} data\n      @arg {wif|PrivateKey} privateKey\n      @arg {String} [encoding = 'utf8'] - data encoding (if string)\n       @return {string} string signature\n       @example ecc.sign('I am alive', wif)\n  */\n  sign: function sign(data, privateKey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (encoding === true) {\n      throw new TypeError('API changed, use signHash(..) instead');\n    } else {\n      if (encoding === false) {\n        console.log('Warning: ecc.sign hashData parameter was removed');\n      }\n    }\n\n    return Signature.sign(data, privateKey, encoding).toString();\n  },\n\n  /**\n      @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or string\n      @arg {wif|PrivateKey} privateKey\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {string} string signature\n  */\n  signHash: function signHash(dataSha256, privateKey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n    return Signature.signHash(dataSha256, privateKey, encoding).toString();\n  },\n\n  /**\n      Verify signed data.\n       @arg {string|Buffer} signature - buffer or hex string\n      @arg {string|Buffer} data\n      @arg {pubkey|PublicKey} pubkey\n      @arg {boolean} [hashData = true] - sha256 hash data before verify\n      @return {boolean}\n       @example ecc.verify(signature, 'I am alive', pubkey) === true\n  */\n  verify: function verify(signature, data, pubkey) {\n    var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'utf8';\n\n    if (encoding === true) {\n      throw new TypeError('API changed, use verifyHash(..) instead');\n    } else {\n      if (encoding === false) {\n        console.log('Warning: ecc.verify hashData parameter was removed');\n      }\n    }\n\n    signature = Signature.from(signature);\n    return signature.verify(data, pubkey, encoding);\n  },\n  verifyHash: function verifyHash(signature, dataSha256, pubkey) {\n    var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hex';\n    signature = Signature.from(signature);\n    return signature.verifyHash(dataSha256, pubkey, encoding);\n  },\n\n  /**\n      Recover the public key used to create the signature.\n       @arg {String|Buffer} signature (EOSbase58sig.., Hex, Buffer)\n      @arg {String|Buffer} data - full data\n      @arg {String} [encoding = 'utf8'] - data encoding (if data is a string)\n       @return {pubkey}\n       @example ecc.recover(signature, 'I am alive') === pubkey\n  */\n  recover: function recover(signature, data) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (encoding === true) {\n      throw new TypeError('API changed, use recoverHash(signature, data) instead');\n    } else {\n      if (encoding === false) {\n        console.log('Warning: ecc.recover hashData parameter was removed');\n      }\n    }\n\n    signature = Signature.from(signature);\n    return signature.recover(data, encoding).toString();\n  },\n\n  /**\n      @arg {String|Buffer} signature (EOSbase58sig.., Hex, Buffer)\n      @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or hex string\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if dataSha256 is a string)\n       @return {PublicKey}\n  */\n  recoverHash: function recoverHash(signature, dataSha256) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n    signature = Signature.from(signature);\n    return signature.recoverHash(dataSha256, encoding).toString();\n  },\n\n  /** @arg {string|Buffer} data - always binary, you may need Buffer.from(data, 'hex')\n      @arg {string} [encoding = 'hex'] - result encoding 'hex', 'binary' or 'base64'\n      @return {string|Buffer} - Buffer when encoding is null, or string\n       @example ecc.sha256('hashme') === '02208b..'\n      @example ecc.sha256(Buffer.from('02208b', 'hex')) === '29a23..'\n  */\n  sha256: function sha256(data) {\n    var resultEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n    return hash.sha256(data, resultEncoding);\n  }\n};\nmodule.exports = ecc;","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosjs-ecc/lib/api_common.js"],"names":["Aes","require","PrivateKey","PublicKey","Signature","key_utils","hash","ecc","initialize","unsafeRandomKey","then","key","toString","randomKey","cpuEntropyBits","seedPrivate","seed","fromSeed","privateToPublic","wif","pubkey_prefix","arguments","length","undefined","toPublic","isValidPublic","pubkey","isValid","isValidPrivate","sign","data","privateKey","encoding","TypeError","console","log","signHash","dataSha256","verify","signature","from","verifyHash","recover","recoverHash","sha256","resultEncoding","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar Aes = require(\"./aes\");\n\nvar PrivateKey = require(\"./key_private\");\n\nvar PublicKey = require(\"./key_public\");\n\nvar Signature = require(\"./signature\");\n\nvar key_utils = require(\"./key_utils\");\n\nvar hash = require(\"./hash\");\n/**\n    [Wallet Import Format](https://en.bitcoin.it/wiki/Wallet_import_format)\n    @typedef {string} wif\n*/\n\n/**\n    EOSKey..\n    @typedef {string} pubkey\n*/\n\n/** @namespace */\n\n\nvar ecc = {\n  /**\n    Initialize by running some self-checking code.  This should take a\n    second to gather additional CPU entropy used during private key\n    generation.\n     Initialization happens once even if called multiple times.\n     @return {Promise}\n  */\n  initialize: PrivateKey.initialize,\n\n  /**\n    Does not pause to gather CPU entropy.\n    @return {Promise<PrivateKey>} test key\n  */\n  unsafeRandomKey: function unsafeRandomKey() {\n    return PrivateKey.unsafeRandomKey().then(function (key) {\n      return key.toString();\n    });\n  },\n\n  /**\n      @arg {number} [cpuEntropyBits = 0] gather additional entropy\n      from a CPU mining algorithm.  This will already happen once by\n      default.\n       @return {Promise<wif>}\n       @example\n  ecc.randomKey().then(privateKey => {\n  console.log('Private Key:\\t', privateKey) // wif\n  console.log('Public Key:\\t', ecc.privateToPublic(privateKey)) // EOSkey...\n  })\n  */\n  randomKey: function randomKey(cpuEntropyBits) {\n    return PrivateKey.randomKey(cpuEntropyBits).then(function (key) {\n      return key.toString();\n    });\n  },\n\n  /**\n       @arg {string} seed - any length string.  This is private.  The same\n      seed produces the same private key every time.  At least 128 random\n      bits should be used to produce a good private key.\n      @return {wif}\n       @example ecc.seedPrivate('secret') === wif\n  */\n  seedPrivate: function seedPrivate(seed) {\n    return PrivateKey.fromSeed(seed).toString();\n  },\n\n  /**\n      @arg {wif} wif\n      @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n       @return {pubkey}\n       @example ecc.privateToPublic(wif) === pubkey\n  */\n  privateToPublic: function privateToPublic(wif) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n    return PrivateKey(wif).toPublic().toString(pubkey_prefix);\n  },\n\n  /**\n      @arg {pubkey} pubkey - like EOSKey..\n      @arg {string} [pubkey_prefix = 'EOS']\n       @return {boolean} valid\n       @example ecc.isValidPublic(pubkey) === true\n  */\n  isValidPublic: function isValidPublic(pubkey) {\n    var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n    return PublicKey.isValid(pubkey, pubkey_prefix);\n  },\n\n  /**\n      @arg {wif} wif\n      @return {boolean} valid\n       @example ecc.isValidPrivate(wif) === true\n  */\n  isValidPrivate: function isValidPrivate(wif) {\n    return PrivateKey.isValid(wif);\n  },\n\n  /**\n      Create a signature using data or a hash.\n       @arg {string|Buffer} data\n      @arg {wif|PrivateKey} privateKey\n      @arg {String} [encoding = 'utf8'] - data encoding (if string)\n       @return {string} string signature\n       @example ecc.sign('I am alive', wif)\n  */\n  sign: function sign(data, privateKey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (encoding === true) {\n      throw new TypeError('API changed, use signHash(..) instead');\n    } else {\n      if (encoding === false) {\n        console.log('Warning: ecc.sign hashData parameter was removed');\n      }\n    }\n\n    return Signature.sign(data, privateKey, encoding).toString();\n  },\n\n  /**\n      @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or string\n      @arg {wif|PrivateKey} privateKey\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if string)\n       @return {string} string signature\n  */\n  signHash: function signHash(dataSha256, privateKey) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n    return Signature.signHash(dataSha256, privateKey, encoding).toString();\n  },\n\n  /**\n      Verify signed data.\n       @arg {string|Buffer} signature - buffer or hex string\n      @arg {string|Buffer} data\n      @arg {pubkey|PublicKey} pubkey\n      @arg {boolean} [hashData = true] - sha256 hash data before verify\n      @return {boolean}\n       @example ecc.verify(signature, 'I am alive', pubkey) === true\n  */\n  verify: function verify(signature, data, pubkey) {\n    var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'utf8';\n\n    if (encoding === true) {\n      throw new TypeError('API changed, use verifyHash(..) instead');\n    } else {\n      if (encoding === false) {\n        console.log('Warning: ecc.verify hashData parameter was removed');\n      }\n    }\n\n    signature = Signature.from(signature);\n    return signature.verify(data, pubkey, encoding);\n  },\n  verifyHash: function verifyHash(signature, dataSha256, pubkey) {\n    var encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'hex';\n    signature = Signature.from(signature);\n    return signature.verifyHash(dataSha256, pubkey, encoding);\n  },\n\n  /**\n      Recover the public key used to create the signature.\n       @arg {String|Buffer} signature (EOSbase58sig.., Hex, Buffer)\n      @arg {String|Buffer} data - full data\n      @arg {String} [encoding = 'utf8'] - data encoding (if data is a string)\n       @return {pubkey}\n       @example ecc.recover(signature, 'I am alive') === pubkey\n  */\n  recover: function recover(signature, data) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'utf8';\n\n    if (encoding === true) {\n      throw new TypeError('API changed, use recoverHash(signature, data) instead');\n    } else {\n      if (encoding === false) {\n        console.log('Warning: ecc.recover hashData parameter was removed');\n      }\n    }\n\n    signature = Signature.from(signature);\n    return signature.recover(data, encoding).toString();\n  },\n\n  /**\n      @arg {String|Buffer} signature (EOSbase58sig.., Hex, Buffer)\n      @arg {String|Buffer} dataSha256 - sha256 hash 32 byte buffer or hex string\n      @arg {String} [encoding = 'hex'] - dataSha256 encoding (if dataSha256 is a string)\n       @return {PublicKey}\n  */\n  recoverHash: function recoverHash(signature, dataSha256) {\n    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'hex';\n    signature = Signature.from(signature);\n    return signature.recoverHash(dataSha256, encoding).toString();\n  },\n\n  /** @arg {string|Buffer} data - always binary, you may need Buffer.from(data, 'hex')\n      @arg {string} [encoding = 'hex'] - result encoding 'hex', 'binary' or 'base64'\n      @return {string|Buffer} - Buffer when encoding is null, or string\n       @example ecc.sha256('hashme') === '02208b..'\n      @example ecc.sha256(Buffer.from('02208b', 'hex')) === '29a23..'\n  */\n  sha256: function sha256(data) {\n    var resultEncoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'hex';\n    return hash.sha256(data, resultEncoding);\n  }\n};\nmodule.exports = ecc;"]},"metadata":{},"sourceType":"script"}