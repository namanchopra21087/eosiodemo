{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst universal_authenticator_library_1 = require(\"universal-authenticator-library\");\n\nconst UALAnchorError_1 = require(\"./UALAnchorError\");\n\nclass AnchorUser extends universal_authenticator_library_1.User {\n  constructor(rpc, identity) {\n    super();\n    this.accountName = '';\n    this.requestPermission = '';\n    const {\n      session\n    } = identity;\n    this.accountName = session.auth.actor;\n    this.chainId = session.link.chainId;\n\n    if (identity.signatures) {\n      [this.signerProof] = identity.signatures;\n    }\n\n    if (identity.signerKey) {\n      this.signerKey = identity.signerKey;\n    }\n\n    if (identity.serializedTransaction) {\n      this.signerRequest = identity.serializedTransaction;\n    }\n\n    this.requestPermission = session.auth.permission;\n    this.session = session;\n    this.rpc = rpc;\n  }\n\n  signTransaction(transaction, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const completedTransaction = yield this.session.transact(transaction, options);\n        const wasBroadcast = options.broadcast !== false;\n        return this.returnEosjsTransaction(wasBroadcast, Object.assign({\n          transaction_id: completedTransaction.payload.tx\n        }, completedTransaction));\n      } catch (e) {\n        const message = e.message ? e.message : 'Unable to sign transaction';\n        const type = universal_authenticator_library_1.UALErrorType.Signing;\n        const cause = e;\n        throw new UALAnchorError_1.UALAnchorError(message, type, cause);\n      }\n    });\n  }\n\n  signArbitrary(publicKey, data, _) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new UALAnchorError_1.UALAnchorError(`Anchor does not currently support signArbitrary(${publicKey}, ${data})`, universal_authenticator_library_1.UALErrorType.Unsupported, null);\n    });\n  }\n\n  verifyKeyOwnership(challenge) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new UALAnchorError_1.UALAnchorError(`Anchor does not currently support verifyKeyOwnership(${challenge})`, universal_authenticator_library_1.UALErrorType.Unsupported, null);\n    });\n  }\n\n  getAccountName() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountName;\n    });\n  }\n\n  getChainId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.chainId;\n    });\n  }\n\n  getKeys() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const keys = yield this.signatureProvider.getAvailableKeys(this.requestPermission);\n        return keys;\n      } catch (error) {\n        const message = `Unable to getKeys for account ${this.accountName}.\n        Please make sure your wallet is running.`;\n        const type = universal_authenticator_library_1.UALErrorType.DataRequest;\n        const cause = error;\n        throw new UALAnchorError_1.UALAnchorError(message, type, cause);\n      }\n    });\n  }\n\n  isAccountValid() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const account = this.rpc && (yield this.rpc.get_account(this.accountName));\n        const actualKeys = this.extractAccountKeys(account);\n        const authorizationKeys = yield this.getKeys();\n        return actualKeys.filter(key => {\n          return authorizationKeys.indexOf(key) !== -1;\n        }).length > 0;\n      } catch (e) {\n        if (e.constructor.name === 'UALAnchorError') {\n          throw e;\n        }\n\n        const message = `Account validation failed for account ${this.accountName}.`;\n        const type = universal_authenticator_library_1.UALErrorType.Validation;\n        const cause = e;\n        throw new UALAnchorError_1.UALAnchorError(message, type, cause);\n      }\n    });\n  }\n\n  extractAccountKeys(account) {\n    const keySubsets = account.permissions.map(permission => permission.required_auth.keys.map(key => key.key));\n    let keys = [];\n\n    for (const keySubset of keySubsets) {\n      keys = keys.concat(keySubset);\n    }\n\n    return keys;\n  }\n\n}\n\nexports.AnchorUser = AnchorUser;","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/ual-anchor/dist/AnchorUser.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","universal_authenticator_library_1","require","UALAnchorError_1","AnchorUser","User","constructor","rpc","identity","accountName","requestPermission","session","auth","actor","chainId","link","signatures","signerProof","signerKey","serializedTransaction","signerRequest","permission","signTransaction","transaction","options","completedTransaction","transact","wasBroadcast","broadcast","returnEosjsTransaction","assign","transaction_id","payload","tx","message","type","UALErrorType","Signing","cause","UALAnchorError","signArbitrary","publicKey","data","_","Unsupported","verifyKeyOwnership","challenge","getAccountName","getChainId","getKeys","keys","signatureProvider","getAvailableKeys","error","DataRequest","isAccountValid","account","get_account","actualKeys","extractAccountKeys","authorizationKeys","filter","key","indexOf","length","name","Validation","keySubsets","permissions","map","required_auth","keySubset","concat"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst universal_authenticator_library_1 = require(\"universal-authenticator-library\");\nconst UALAnchorError_1 = require(\"./UALAnchorError\");\nclass AnchorUser extends universal_authenticator_library_1.User {\n    constructor(rpc, identity) {\n        super();\n        this.accountName = '';\n        this.requestPermission = '';\n        const { session } = identity;\n        this.accountName = session.auth.actor;\n        this.chainId = session.link.chainId;\n        if (identity.signatures) {\n            [this.signerProof] = identity.signatures;\n        }\n        if (identity.signerKey) {\n            this.signerKey = identity.signerKey;\n        }\n        if (identity.serializedTransaction) {\n            this.signerRequest = identity.serializedTransaction;\n        }\n        this.requestPermission = session.auth.permission;\n        this.session = session;\n        this.rpc = rpc;\n    }\n    signTransaction(transaction, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const completedTransaction = yield this.session.transact(transaction, options);\n                const wasBroadcast = (options.broadcast !== false);\n                return this.returnEosjsTransaction(wasBroadcast, Object.assign({ transaction_id: completedTransaction.payload.tx }, completedTransaction));\n            }\n            catch (e) {\n                const message = e.message ? e.message : 'Unable to sign transaction';\n                const type = universal_authenticator_library_1.UALErrorType.Signing;\n                const cause = e;\n                throw new UALAnchorError_1.UALAnchorError(message, type, cause);\n            }\n        });\n    }\n    signArbitrary(publicKey, data, _) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new UALAnchorError_1.UALAnchorError(`Anchor does not currently support signArbitrary(${publicKey}, ${data})`, universal_authenticator_library_1.UALErrorType.Unsupported, null);\n        });\n    }\n    verifyKeyOwnership(challenge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new UALAnchorError_1.UALAnchorError(`Anchor does not currently support verifyKeyOwnership(${challenge})`, universal_authenticator_library_1.UALErrorType.Unsupported, null);\n        });\n    }\n    getAccountName() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountName;\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.chainId;\n        });\n    }\n    getKeys() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const keys = yield this.signatureProvider.getAvailableKeys(this.requestPermission);\n                return keys;\n            }\n            catch (error) {\n                const message = `Unable to getKeys for account ${this.accountName}.\n        Please make sure your wallet is running.`;\n                const type = universal_authenticator_library_1.UALErrorType.DataRequest;\n                const cause = error;\n                throw new UALAnchorError_1.UALAnchorError(message, type, cause);\n            }\n        });\n    }\n    isAccountValid() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const account = this.rpc && (yield this.rpc.get_account(this.accountName));\n                const actualKeys = this.extractAccountKeys(account);\n                const authorizationKeys = yield this.getKeys();\n                return actualKeys.filter((key) => {\n                    return authorizationKeys.indexOf(key) !== -1;\n                }).length > 0;\n            }\n            catch (e) {\n                if (e.constructor.name === 'UALAnchorError') {\n                    throw e;\n                }\n                const message = `Account validation failed for account ${this.accountName}.`;\n                const type = universal_authenticator_library_1.UALErrorType.Validation;\n                const cause = e;\n                throw new UALAnchorError_1.UALAnchorError(message, type, cause);\n            }\n        });\n    }\n    extractAccountKeys(account) {\n        const keySubsets = account.permissions.map((permission) => permission.required_auth.keys.map((key) => key.key));\n        let keys = [];\n        for (const keySubset of keySubsets) {\n            keys = keys.concat(keySubset);\n        }\n        return keys;\n    }\n}\nexports.AnchorUser = AnchorUser;\n"]},"metadata":{},"sourceType":"script"}