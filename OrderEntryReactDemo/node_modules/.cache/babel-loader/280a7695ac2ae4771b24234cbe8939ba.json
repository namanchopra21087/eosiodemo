{"ast":null,"code":"/**\n * EOSIO Signing Request (ESR).\n */\nimport { Serialize } from 'eosjs';\nimport sha256 from 'fast-sha256';\nimport * as abi from './abi';\nimport * as base64u from './base64u';\nconst ProtocolVersion = 2;\nconst AbiTypes = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), abi.data);\n/** Chain ID aliases. */\n\nexport var ChainName;\n\n(function (ChainName) {\n  ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n  ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n  ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n  ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n  ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n  ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n  ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n  ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n  ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n  ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n  ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n  ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\n\nconst ChainIdLookup = new Map([[ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'], [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'], [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'], [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'], [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'], [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'], [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'], [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'], [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'], [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'], [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'], [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c']]);\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\n\nexport const PlaceholderName = '............1'; // aka uint64(1)\n\n/** Placeholder that will resolve to signer permission name. */\n\nexport const PlaceholderPermission = '............2'; // aka uint64(2)\n\nexport const PlaceholderAuth = {\n  actor: PlaceholderName,\n  permission: PlaceholderPermission\n};\n\nlet SigningRequest =\n/** @class */\n(() => {\n  class SigningRequest {\n    /**\n     * Create a new signing request.\n     * Normally not used directly, see the `create` and `from` class methods.\n     */\n    constructor(version, data, textEncoder, textDecoder, zlib, abiProvider, signature) {\n      if ((data.flags & abi.RequestFlagsBroadcast) !== 0 && data.req[0] === 'identity') {\n        throw new Error('Invalid request (identity request cannot be broadcast)');\n      }\n\n      if ((data.flags & abi.RequestFlagsBroadcast) === 0 && data.callback.length === 0) {\n        throw new Error('Invalid request (nothing to do, no broadcast or callback set)');\n      }\n\n      this.version = version;\n      this.data = data;\n      this.textEncoder = textEncoder;\n      this.textDecoder = textDecoder;\n      this.zlib = zlib;\n      this.abiProvider = abiProvider;\n      this.signature = signature;\n    }\n    /** Create a new signing request. */\n\n\n    static async create(args, options = {}) {\n      const textEncoder = options.textEncoder || new TextEncoder();\n      const textDecoder = options.textDecoder || new TextDecoder();\n      const data = {};\n\n      const serialize = action => {\n        return serializeAction(action, textEncoder, textDecoder, options.abiProvider);\n      }; // set the request data\n\n\n      if (args.identity !== undefined) {\n        data.req = ['identity', args.identity];\n      } else if (args.action && !args.actions && !args.transaction) {\n        data.req = ['action', await serialize(args.action)];\n      } else if (args.actions && !args.action && !args.transaction) {\n        if (args.actions.length === 1) {\n          data.req = ['action', await serialize(args.actions[0])];\n        } else {\n          data.req = ['action[]', await Promise.all(args.actions.map(serialize))];\n        }\n      } else if (args.transaction && !args.action && !args.actions) {\n        const tx = args.transaction; // set default values if missing\n\n        if (tx.expiration === undefined) {\n          tx.expiration = '1970-01-01T00:00:00.000';\n        }\n\n        if (tx.ref_block_num === undefined) {\n          tx.ref_block_num = 0;\n        }\n\n        if (tx.ref_block_prefix === undefined) {\n          tx.ref_block_prefix = 0;\n        }\n\n        if (tx.context_free_actions === undefined) {\n          tx.context_free_actions = [];\n        }\n\n        if (tx.transaction_extensions === undefined) {\n          tx.transaction_extensions = [];\n        }\n\n        if (tx.delay_sec === undefined) {\n          tx.delay_sec = 0;\n        }\n\n        if (tx.max_cpu_usage_ms === undefined) {\n          tx.max_cpu_usage_ms = 0;\n        }\n\n        if (tx.max_net_usage_words === undefined) {\n          tx.max_net_usage_words = 0;\n        } // encode actions if needed\n\n\n        tx.actions = await Promise.all(tx.actions.map(serialize));\n        data.req = ['transaction', tx];\n      } else {\n        throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n      } // set the chain id\n\n\n      data.chain_id = variantId(args.chainId);\n      data.flags = abi.RequestFlagsNone;\n      const broadcast = args.broadcast !== undefined ? args.broadcast : true;\n\n      if (broadcast) {\n        data.flags |= abi.RequestFlagsBroadcast;\n      }\n\n      if (typeof args.callback === 'string') {\n        data.callback = args.callback;\n      } else if (typeof args.callback === 'object') {\n        data.callback = args.callback.url;\n\n        if (args.callback.background) {\n          data.flags |= abi.RequestFlagsBackground;\n        }\n      } else {\n        data.callback = '';\n      }\n\n      data.info = [];\n\n      if (typeof args.info === 'object') {\n        for (const key in args.info) {\n          if (args.info.hasOwnProperty(key)) {\n            let value = args.info[key];\n\n            if (typeof key !== 'string') {\n              throw new Error('Invalid info dict, keys must be strings');\n            }\n\n            if (typeof value === 'string') {\n              value = textEncoder.encode(value);\n            }\n\n            data.info.push({\n              key,\n              value\n            });\n          }\n        }\n      }\n\n      const req = new SigningRequest(ProtocolVersion, data, textEncoder, textDecoder, options.zlib, options.abiProvider); // sign the request if given a signature provider\n\n      if (options.signatureProvider) {\n        req.sign(options.signatureProvider);\n      }\n\n      return req;\n    }\n    /** Creates an identity request. */\n\n\n    static identity(args, options = {}) {\n      let permission = {\n        actor: args.account || PlaceholderName,\n        permission: args.permission || PlaceholderPermission\n      };\n\n      if (permission.actor === PlaceholderName && permission.permission === PlaceholderPermission) {\n        permission = null;\n      }\n\n      return this.create({\n        identity: {\n          permission\n        },\n        broadcast: false,\n        callback: args.callback,\n        info: args.info\n      }, options);\n    }\n    /**\n     * Create a request from a chain id and serialized transaction.\n     * @param chainId The chain id where the transaction is valid.\n     * @param serializedTransaction The serialized transaction.\n     * @param options Creation options.\n     */\n\n\n    static fromTransaction(chainId, serializedTransaction, options = {}) {\n      if (typeof chainId !== 'string') {\n        chainId = Serialize.arrayToHex(chainId);\n      }\n\n      if (typeof serializedTransaction === 'string') {\n        serializedTransaction = Serialize.hexToUint8Array(serializedTransaction);\n      }\n\n      let buf = new Serialize.SerialBuffer({\n        textDecoder: options.textDecoder,\n        textEncoder: options.textEncoder\n      });\n      buf.push(2); // header\n\n      const id = variantId(chainId);\n\n      if (id[0] === 'chain_alias') {\n        buf.push(0);\n        buf.push(id[1]);\n      } else {\n        buf.push(1);\n        buf.pushArray(Serialize.hexToUint8Array(id[1]));\n      }\n\n      buf.push(2); // transaction variant\n\n      buf.pushArray(serializedTransaction);\n      buf.push(abi.RequestFlagsBroadcast); // flags\n\n      buf.push(0); // callback\n\n      buf.push(0); // info\n\n      return SigningRequest.fromData(buf.asUint8Array(), options);\n    }\n    /** Creates a signing request from encoded `esr:` uri string. */\n\n\n    static from(uri, options = {}) {\n      if (typeof uri !== 'string') {\n        throw new Error('Invalid request uri');\n      }\n\n      const [scheme, path] = uri.split(':');\n\n      if (scheme !== 'esr' && scheme !== 'web+esr') {\n        throw new Error('Invalid scheme');\n      }\n\n      const data = base64u.decode(path.startsWith('//') ? path.slice(2) : path);\n      return SigningRequest.fromData(data, options);\n    }\n\n    static fromData(data, options = {}) {\n      const header = data[0];\n      const version = header & ~(1 << 7);\n\n      if (version !== ProtocolVersion) {\n        throw new Error('Unsupported protocol version');\n      }\n\n      let array = data.slice(1);\n\n      if ((header & 1 << 7) !== 0) {\n        if (!options.zlib) {\n          throw new Error('Compressed URI needs zlib');\n        }\n\n        array = options.zlib.inflateRaw(array);\n      }\n\n      const textEncoder = options.textEncoder || new TextEncoder();\n      const textDecoder = options.textDecoder || new TextDecoder();\n      const buffer = new Serialize.SerialBuffer({\n        textEncoder,\n        textDecoder,\n        array\n      });\n      const req = SigningRequest.type.deserialize(buffer);\n      let signature;\n\n      if (buffer.haveReadData()) {\n        const type = AbiTypes.get('request_signature');\n        signature = type.deserialize(buffer);\n      }\n\n      return new SigningRequest(version, req, textEncoder, textDecoder, options.zlib, options.abiProvider, signature);\n    }\n    /**\n     * Sign the request, mutating.\n     * @param signatureProvider The signature provider that provides a signature for the signer.\n     */\n\n\n    sign(signatureProvider) {\n      const message = this.getSignatureDigest();\n      this.signature = signatureProvider.sign(Serialize.arrayToHex(message));\n    }\n    /**\n     * Get the signature digest for this request.\n     */\n\n\n    getSignatureDigest() {\n      const buffer = new Serialize.SerialBuffer({\n        textEncoder: this.textEncoder,\n        textDecoder: this.textDecoder\n      }); // protocol version + utf8 \"request\"\n\n      buffer.pushArray([this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74]);\n      buffer.pushArray(this.getData());\n      return sha256(buffer.asUint8Array());\n    }\n    /**\n     * Set the signature data for this request, mutating.\n     * @param signer Account name of signer.\n     * @param signature The signature string.\n     */\n\n\n    setSignature(signer, signature) {\n      this.signature = {\n        signer,\n        signature\n      };\n    }\n    /**\n     * Set the request callback, mutating.\n     * @param url Where the callback should be sent.\n     * @param background Whether the callback should be sent in the background.\n     */\n\n\n    setCallback(url, background) {\n      this.data.callback = url;\n\n      if (background) {\n        this.data.flags |= abi.RequestFlagsBackground;\n      } else {\n        this.data.flags &= ~abi.RequestFlagsBackground;\n      }\n    }\n    /**\n     * Set broadcast flag.\n     * @param broadcast Whether the transaction should be broadcast by receiver.\n     */\n\n\n    setBroadcast(broadcast) {\n      if (broadcast) {\n        this.data.flags |= abi.RequestFlagsBroadcast;\n      } else {\n        this.data.flags &= ~abi.RequestFlagsBroadcast;\n      }\n    }\n    /**\n     * Encode this request into an `esr:` uri.\n     * @argument compress Whether to compress the request data using zlib,\n     *                    defaults to true if omitted and zlib is present;\n     *                    otherwise false.\n     * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n     *                   Defaults to true.\n     * @returns An esr uri string.\n     */\n\n\n    encode(compress, slashes) {\n      const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n\n      if (shouldCompress && this.zlib === undefined) {\n        throw new Error('Need zlib to compress');\n      }\n\n      let header = this.version;\n      const data = this.getData();\n      const sigData = this.getSignatureData();\n      let array = new Uint8Array(data.byteLength + sigData.byteLength);\n      array.set(data, 0);\n      array.set(sigData, data.byteLength);\n\n      if (shouldCompress) {\n        const deflated = this.zlib.deflateRaw(array);\n\n        if (array.byteLength > deflated.byteLength) {\n          header |= 1 << 7;\n          array = deflated;\n        }\n      }\n\n      const out = new Uint8Array(1 + array.byteLength);\n      out[0] = header;\n      out.set(array, 1);\n      let scheme = 'esr:';\n\n      if (slashes !== false) {\n        scheme += '//';\n      }\n\n      return scheme + base64u.encode(out);\n    }\n    /** Get the request data without header or signature. */\n\n\n    getData() {\n      const buffer = new Serialize.SerialBuffer({\n        textEncoder: this.textEncoder,\n        textDecoder: this.textDecoder\n      });\n      SigningRequest.type.serialize(buffer, this.data);\n      return buffer.asUint8Array();\n    }\n    /** Get signature data, returns an empty array if request is not signed. */\n\n\n    getSignatureData() {\n      if (!this.signature) {\n        return new Uint8Array(0);\n      }\n\n      const buffer = new Serialize.SerialBuffer({\n        textEncoder: this.textEncoder,\n        textDecoder: this.textDecoder\n      });\n      const type = AbiTypes.get('request_signature');\n      type.serialize(buffer, this.signature);\n      return buffer.asUint8Array();\n    }\n    /** ABI definitions required to resolve request. */\n\n\n    getRequiredAbis() {\n      return this.getRawActions().filter(action => !isIdentity(action)).map(action => action.account).filter((value, index, self) => self.indexOf(value) === index);\n    }\n    /** Whether TaPoS values are required to resolve request. */\n\n\n    requiresTapos() {\n      let tx = this.getRawTransaction();\n      return !this.isIdentity() && !hasTapos(tx);\n    }\n    /** Resolve required ABI definitions. */\n\n\n    async fetchAbis(abiProvider) {\n      const provider = abiProvider || this.abiProvider;\n\n      if (!provider) {\n        throw new Error('Missing ABI provider');\n      }\n\n      const abis = new Map();\n      await Promise.all(this.getRequiredAbis().map(async account => {\n        abis.set(account, await provider.getAbi(account));\n      }));\n      return abis;\n    }\n    /**\n     * Decode raw actions actions to object representations.\n     * @param abis ABI defenitions required to decode all actions.\n     * @param signer Placeholders in actions will be resolved to signer if set.\n     */\n\n\n    resolveActions(abis, signer) {\n      return this.getRawActions().map(rawAction => {\n        let contractAbi;\n\n        if (isIdentity(rawAction)) {\n          contractAbi = abi.data;\n        } else {\n          contractAbi = abis.get(rawAction.account);\n        }\n\n        if (!contractAbi) {\n          throw new Error(`Missing ABI definition for ${rawAction.account}`);\n        }\n\n        const contract = getContract(contractAbi);\n\n        if (signer) {\n          // hook into eosjs name decoder and return the signing account if we encounter the placeholder\n          // this is fine because getContract re-creates the initial types each time\n          contract.types.get('name').deserialize = buffer => {\n            const name = buffer.getName();\n\n            if (name === PlaceholderName) {\n              return signer.actor;\n            } else if (name === PlaceholderPermission) {\n              return signer.permission;\n            } else {\n              return name;\n            }\n          };\n        }\n\n        const action = Serialize.deserializeAction(contract, rawAction.account, rawAction.name, rawAction.authorization, rawAction.data, this.textEncoder, this.textDecoder);\n\n        if (signer) {\n          action.authorization = action.authorization.map(auth => {\n            let {\n              actor,\n              permission\n            } = auth;\n\n            if (actor === PlaceholderName) {\n              actor = signer.actor;\n            }\n\n            if (permission === PlaceholderPermission) {\n              permission = signer.permission;\n            } // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n\n\n            if (permission === PlaceholderName) {\n              permission = signer.permission;\n            }\n\n            return {\n              actor,\n              permission\n            };\n          });\n        }\n\n        return action;\n      });\n    }\n\n    resolveTransaction(abis, signer, ctx = {}) {\n      let tx = this.getRawTransaction();\n\n      if (!this.isIdentity() && !hasTapos(tx)) {\n        if (ctx.expiration !== undefined && ctx.ref_block_num !== undefined && ctx.ref_block_prefix !== undefined) {\n          tx.expiration = ctx.expiration;\n          tx.ref_block_num = ctx.ref_block_num;\n          tx.ref_block_prefix = ctx.ref_block_prefix;\n        } else if (ctx.block_num !== undefined && ctx.ref_block_prefix !== undefined && ctx.timestamp !== undefined) {\n          const header = Serialize.transactionHeader(ctx, ctx.expire_seconds !== undefined ? ctx.expire_seconds : 60);\n          tx.expiration = header.expiration;\n          tx.ref_block_num = header.ref_block_num;\n          tx.ref_block_prefix = header.ref_block_prefix;\n        } else {\n          throw new Error('Invalid transaction context, need either a reference block or explicit TAPoS values');\n        }\n      }\n\n      const actions = this.resolveActions(abis, signer);\n      return { ...tx,\n        actions\n      };\n    }\n\n    resolve(abis, signer, ctx = {}) {\n      const transaction = this.resolveTransaction(abis, signer, ctx);\n      const buf = new Serialize.SerialBuffer({\n        textDecoder: this.textDecoder,\n        textEncoder: this.textEncoder\n      });\n      const actions = transaction.actions.map(action => {\n        let contractAbi;\n\n        if (isIdentity(action)) {\n          contractAbi = abi.data;\n        } else {\n          contractAbi = abis.get(action.account);\n        }\n\n        if (!contractAbi) {\n          throw new Error(`Missing ABI definition for ${action.account}`);\n        }\n\n        const contract = getContract(contractAbi);\n        const {\n          textDecoder,\n          textEncoder\n        } = this;\n        return Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder);\n      });\n      SigningRequest.transactionType.serialize(buf, { ...transaction,\n        actions\n      });\n      const serializedTransaction = buf.asUint8Array();\n      return new ResolvedSigningRequest(this, signer, transaction, serializedTransaction);\n    }\n    /**\n     * Get the id of the chain where this request is valid.\n     * @returns The 32-byte chain id as hex encoded string.\n     */\n\n\n    getChainId() {\n      const id = this.data.chain_id;\n\n      switch (id[0]) {\n        case 'chain_id':\n          return id[1];\n\n        case 'chain_alias':\n          if (ChainIdLookup.has(id[1])) {\n            return ChainIdLookup.get(id[1]);\n          } else {\n            throw new Error('Unknown chain id alias');\n          }\n\n        default:\n          throw new Error('Invalid signing request data');\n      }\n    }\n    /** Return the actions in this request with action data encoded. */\n\n\n    getRawActions() {\n      const req = this.data.req;\n\n      switch (req[0]) {\n        case 'action':\n          return [req[1]];\n\n        case 'action[]':\n          return req[1];\n\n        case 'identity':\n          let data = '0101000000000000000200000000000000'; // placeholder permission\n\n          let authorization = [PlaceholderAuth];\n\n          if (req[1].permission) {\n            let buf = new Serialize.SerialBuffer({\n              textDecoder: this.textDecoder,\n              textEncoder: this.textEncoder\n            });\n            SigningRequest.idType.serialize(buf, req[1]);\n            data = Serialize.arrayToHex(buf.asUint8Array());\n            authorization = [req[1].permission];\n          }\n\n          return [{\n            account: '',\n            name: 'identity',\n            authorization,\n            data\n          }];\n\n        case 'transaction':\n          return req[1].actions;\n\n        default:\n          throw new Error('Invalid signing request data');\n      }\n    }\n    /** Unresolved transaction. */\n\n\n    getRawTransaction() {\n      const req = this.data.req;\n\n      switch (req[0]) {\n        case 'transaction':\n          return req[1];\n\n        case 'action':\n        case 'action[]':\n        case 'identity':\n          return {\n            actions: this.getRawActions(),\n            context_free_actions: [],\n            transaction_extensions: [],\n            expiration: '1970-01-01T00:00:00.000',\n            ref_block_num: 0,\n            ref_block_prefix: 0,\n            max_cpu_usage_ms: 0,\n            max_net_usage_words: 0,\n            delay_sec: 0\n          };\n\n        default:\n          throw new Error('Invalid signing request data');\n      }\n    }\n    /** Whether the request is an identity request. */\n\n\n    isIdentity() {\n      return this.data.req[0] === 'identity';\n    }\n    /** Whether the request should be broadcast by signer. */\n\n\n    shouldBroadcast() {\n      if (this.isIdentity()) {\n        return false;\n      }\n\n      return (this.data.flags & abi.RequestFlagsBroadcast) !== 0;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific account.\n     * @note This returns `nil` unless a specific identity has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n\n\n    getIdentity() {\n      if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n        const {\n          actor\n        } = this.data.req[1].permission;\n        return actor === PlaceholderName ? null : actor;\n      }\n\n      return null;\n    }\n    /**\n     * Present if the request is an identity request and requests a specific permission.\n     * @note This returns `nil` unless a specific permission has been requested,\n     *       use `isIdentity` to check id requests.\n     */\n\n\n    getIdentityPermission() {\n      if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n        const {\n          permission\n        } = this.data.req[1].permission;\n        return permission === PlaceholderName ? null : permission;\n      }\n\n      return null;\n    }\n    /** Get raw info dict */\n\n\n    getRawInfo() {\n      let rv = {};\n\n      for (const {\n        key,\n        value\n      } of this.data.info) {\n        rv[key] = typeof value === 'string' ? Serialize.hexToUint8Array(value) : value;\n      }\n\n      return rv;\n    }\n    /** Get metadata values as strings. */\n\n\n    getInfo() {\n      let rv = {};\n      let raw = this.getRawInfo();\n\n      for (const key of Object.keys(raw)) {\n        rv[key] = this.textDecoder.decode(raw[key]);\n      }\n\n      return rv;\n    }\n    /** Set a metadata key. */\n\n\n    setInfoKey(key, value) {\n      let pair = this.data.info.find(pair => {\n        return pair.key === key;\n      });\n      let encodedValue;\n\n      switch (typeof value) {\n        case 'string':\n          encodedValue = this.textEncoder.encode(value);\n          break;\n\n        case 'boolean':\n          encodedValue = new Uint8Array([value ? 1 : 0]);\n          break;\n\n        default:\n          throw new TypeError('Invalid value type, expected string or boolean.');\n      }\n\n      if (!pair) {\n        pair = {\n          key,\n          value: encodedValue\n        };\n        this.data.info.push(pair);\n      } else {\n        pair.value = encodedValue;\n      }\n    }\n    /** Return a deep copy of this request. */\n\n\n    clone() {\n      let signature;\n\n      if (this.signature) {\n        signature = JSON.parse(JSON.stringify(this.signature));\n      }\n\n      const data = JSON.stringify(this.data, (key, value) => {\n        if (value instanceof Uint8Array) {\n          return Array.from(value);\n        }\n\n        return value;\n      });\n      return new SigningRequest(this.version, JSON.parse(data), this.textEncoder, this.textDecoder, this.zlib, this.abiProvider, signature);\n    } // Convenience methods.\n\n\n    toString() {\n      return this.encode();\n    }\n\n    toJSON() {\n      return this.encode();\n    }\n\n  }\n\n  SigningRequest.type = AbiTypes.get('signing_request');\n  SigningRequest.idType = AbiTypes.get('identity');\n  SigningRequest.transactionType = AbiTypes.get('transaction');\n  return SigningRequest;\n})();\n\nexport { SigningRequest };\nexport class ResolvedSigningRequest {\n  constructor(request, signer, transaction, serializedTransaction) {\n    this.request = request;\n    this.signer = signer;\n    this.transaction = transaction;\n    this.serializedTransaction = serializedTransaction;\n  }\n  /** Recreate a resolved request from a callback payload. */\n\n\n  static async fromPayload(payload, options = {}) {\n    const request = SigningRequest.from(payload.req, options);\n    const abis = await request.fetchAbis();\n    return request.resolve(abis, {\n      actor: payload.sa,\n      permission: payload.sp\n    }, {\n      ref_block_num: Number(payload.rbn),\n      ref_block_prefix: Number(payload.rid),\n      expiration: payload.ex\n    });\n  }\n\n  getTransactionId() {\n    return Serialize.arrayToHex(sha256(this.serializedTransaction));\n  }\n\n  getCallback(signatures, blockNum) {\n    const {\n      callback,\n      flags\n    } = this.request.data;\n\n    if (!callback || callback.length === 0) {\n      return null;\n    }\n\n    if (!signatures || signatures.length === 0) {\n      throw new Error('Must have at least one signature to resolve callback');\n    }\n\n    const payload = {\n      sig: signatures[0],\n      tx: this.getTransactionId(),\n      rbn: String(this.transaction.ref_block_num),\n      rid: String(this.transaction.ref_block_prefix),\n      ex: this.transaction.expiration,\n      req: this.request.encode(),\n      sa: this.signer.actor,\n      sp: this.signer.permission\n    };\n\n    for (const [n, sig] of signatures.slice(1).entries()) {\n      payload[`sig${n}`] = sig;\n    }\n\n    if (blockNum) {\n      payload.bn = String(blockNum);\n    }\n\n    const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n      return payload[m] || '';\n    });\n    return {\n      background: (flags & abi.RequestFlagsBackground) !== 0,\n      payload,\n      url\n    };\n  }\n\n}\n/** Internal helper that creates a contract representation from an abi for the eosjs serializer. */\n\nfunction getContract(contractAbi) {\n  const types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), contractAbi);\n  const actions = new Map();\n\n  for (const {\n    name,\n    type\n  } of contractAbi.actions) {\n    actions.set(name, Serialize.getType(types, type));\n  }\n\n  return {\n    types,\n    actions\n  };\n}\n\nasync function serializeAction(action, textEncoder, textDecoder, abiProvider) {\n  if (typeof action.data === 'string') {\n    return action;\n  }\n\n  let contractAbi;\n\n  if (isIdentity(action)) {\n    contractAbi = abi.data;\n  } else if (abiProvider) {\n    contractAbi = await abiProvider.getAbi(action.account);\n  } else {\n    throw new Error('Missing abi provider');\n  }\n\n  const contract = getContract(contractAbi);\n  return Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder);\n}\n\nfunction variantId(chainId) {\n  if (!chainId) {\n    chainId = ChainName.EOS;\n  }\n\n  if (typeof chainId === 'number') {\n    return ['chain_alias', chainId];\n  } else {\n    // resolve known chain id's to their aliases\n    const name = idToName(chainId);\n\n    if (name !== ChainName.UNKNOWN) {\n      return ['chain_alias', name];\n    }\n\n    return ['chain_id', chainId];\n  }\n}\n\nfunction isIdentity(action) {\n  return action.account === '' && action.name === 'identity';\n}\n\nfunction hasTapos(tx) {\n  return !(tx.expiration === '1970-01-01T00:00:00.000' && tx.ref_block_num === 0 && tx.ref_block_prefix === 0);\n}\n/** Resolve a chain id to a chain name alias, returns UNKNOWN (0x00) if the chain id has no alias. */\n\n\nexport function idToName(chainId) {\n  chainId = chainId.toLowerCase();\n\n  for (const [n, id] of ChainIdLookup) {\n    if (id === chainId) {\n      n;\n    }\n  }\n\n  return ChainName.UNKNOWN;\n}\n/** Resolve a chain name alias to a chain id. */\n\nexport function nameToId(chainName) {\n  return ChainIdLookup.get(chainName) || '0000000000000000000000000000000000000000000000000000000000000000';\n}","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosio-signing-request/lib/signing-request.js"],"names":["Serialize","sha256","abi","base64u","ProtocolVersion","AbiTypes","getTypesFromAbi","createInitialTypes","data","ChainName","ChainIdLookup","Map","EOS","TELOS","JUNGLE","KYLIN","WORBLI","BOS","MEETONE","INSIGHTS","BEOS","WAX","PROTON","FIO","PlaceholderName","PlaceholderPermission","PlaceholderAuth","actor","permission","SigningRequest","constructor","version","textEncoder","textDecoder","zlib","abiProvider","signature","flags","RequestFlagsBroadcast","req","Error","callback","length","create","args","options","TextEncoder","TextDecoder","serialize","action","serializeAction","identity","undefined","actions","transaction","Promise","all","map","tx","expiration","ref_block_num","ref_block_prefix","context_free_actions","transaction_extensions","delay_sec","max_cpu_usage_ms","max_net_usage_words","TypeError","chain_id","variantId","chainId","RequestFlagsNone","broadcast","url","background","RequestFlagsBackground","info","key","hasOwnProperty","value","encode","push","signatureProvider","sign","account","fromTransaction","serializedTransaction","arrayToHex","hexToUint8Array","buf","SerialBuffer","id","pushArray","fromData","asUint8Array","from","uri","scheme","path","split","decode","startsWith","slice","header","array","inflateRaw","buffer","type","deserialize","haveReadData","get","message","getSignatureDigest","getData","setSignature","signer","setCallback","setBroadcast","compress","slashes","shouldCompress","sigData","getSignatureData","Uint8Array","byteLength","set","deflated","deflateRaw","out","getRequiredAbis","getRawActions","filter","isIdentity","index","self","indexOf","requiresTapos","getRawTransaction","hasTapos","fetchAbis","provider","abis","getAbi","resolveActions","rawAction","contractAbi","contract","getContract","types","name","getName","deserializeAction","authorization","auth","resolveTransaction","ctx","block_num","timestamp","transactionHeader","expire_seconds","resolve","transactionType","ResolvedSigningRequest","getChainId","has","idType","shouldBroadcast","getIdentity","getIdentityPermission","getRawInfo","rv","getInfo","raw","Object","keys","setInfoKey","pair","find","encodedValue","clone","JSON","parse","stringify","Array","toString","toJSON","request","fromPayload","payload","sa","sp","Number","rbn","rid","ex","getTransactionId","getCallback","signatures","blockNum","sig","String","n","entries","bn","replace","_1","_2","m","getType","idToName","UNKNOWN","toLowerCase","nameToId","chainName"],"mappings":"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","sourcesContent":["/**\n * EOSIO Signing Request (ESR).\n */\nimport { Serialize } from 'eosjs';\nimport sha256 from 'fast-sha256';\nimport * as abi from './abi';\nimport * as base64u from './base64u';\nconst ProtocolVersion = 2;\nconst AbiTypes = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), abi.data);\n/** Chain ID aliases. */\nexport var ChainName;\n(function (ChainName) {\n    ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n    ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n    ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n    ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n    ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n    ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n    ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n    ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n    ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n    ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n    ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n    ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\nconst ChainIdLookup = new Map([\n    [ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'],\n    [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'],\n    [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'],\n    [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'],\n    [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'],\n    [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'],\n    [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'],\n    [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'],\n    [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'],\n    [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'],\n    [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'],\n    [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c'],\n]);\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\nexport const PlaceholderName = '............1'; // aka uint64(1)\n/** Placeholder that will resolve to signer permission name. */\nexport const PlaceholderPermission = '............2'; // aka uint64(2)\nexport const PlaceholderAuth = {\n    actor: PlaceholderName,\n    permission: PlaceholderPermission,\n};\nlet SigningRequest = /** @class */ (() => {\n    class SigningRequest {\n        /**\n         * Create a new signing request.\n         * Normally not used directly, see the `create` and `from` class methods.\n         */\n        constructor(version, data, textEncoder, textDecoder, zlib, abiProvider, signature) {\n            if ((data.flags & abi.RequestFlagsBroadcast) !== 0 && data.req[0] === 'identity') {\n                throw new Error('Invalid request (identity request cannot be broadcast)');\n            }\n            if ((data.flags & abi.RequestFlagsBroadcast) === 0 && data.callback.length === 0) {\n                throw new Error('Invalid request (nothing to do, no broadcast or callback set)');\n            }\n            this.version = version;\n            this.data = data;\n            this.textEncoder = textEncoder;\n            this.textDecoder = textDecoder;\n            this.zlib = zlib;\n            this.abiProvider = abiProvider;\n            this.signature = signature;\n        }\n        /** Create a new signing request. */\n        static async create(args, options = {}) {\n            const textEncoder = options.textEncoder || new TextEncoder();\n            const textDecoder = options.textDecoder || new TextDecoder();\n            const data = {};\n            const serialize = (action) => {\n                return serializeAction(action, textEncoder, textDecoder, options.abiProvider);\n            };\n            // set the request data\n            if (args.identity !== undefined) {\n                data.req = ['identity', args.identity];\n            }\n            else if (args.action && !args.actions && !args.transaction) {\n                data.req = ['action', await serialize(args.action)];\n            }\n            else if (args.actions && !args.action && !args.transaction) {\n                if (args.actions.length === 1) {\n                    data.req = ['action', await serialize(args.actions[0])];\n                }\n                else {\n                    data.req = ['action[]', await Promise.all(args.actions.map(serialize))];\n                }\n            }\n            else if (args.transaction && !args.action && !args.actions) {\n                const tx = args.transaction;\n                // set default values if missing\n                if (tx.expiration === undefined) {\n                    tx.expiration = '1970-01-01T00:00:00.000';\n                }\n                if (tx.ref_block_num === undefined) {\n                    tx.ref_block_num = 0;\n                }\n                if (tx.ref_block_prefix === undefined) {\n                    tx.ref_block_prefix = 0;\n                }\n                if (tx.context_free_actions === undefined) {\n                    tx.context_free_actions = [];\n                }\n                if (tx.transaction_extensions === undefined) {\n                    tx.transaction_extensions = [];\n                }\n                if (tx.delay_sec === undefined) {\n                    tx.delay_sec = 0;\n                }\n                if (tx.max_cpu_usage_ms === undefined) {\n                    tx.max_cpu_usage_ms = 0;\n                }\n                if (tx.max_net_usage_words === undefined) {\n                    tx.max_net_usage_words = 0;\n                }\n                // encode actions if needed\n                tx.actions = await Promise.all(tx.actions.map(serialize));\n                data.req = ['transaction', tx];\n            }\n            else {\n                throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n            }\n            // set the chain id\n            data.chain_id = variantId(args.chainId);\n            data.flags = abi.RequestFlagsNone;\n            const broadcast = args.broadcast !== undefined ? args.broadcast : true;\n            if (broadcast) {\n                data.flags |= abi.RequestFlagsBroadcast;\n            }\n            if (typeof args.callback === 'string') {\n                data.callback = args.callback;\n            }\n            else if (typeof args.callback === 'object') {\n                data.callback = args.callback.url;\n                if (args.callback.background) {\n                    data.flags |= abi.RequestFlagsBackground;\n                }\n            }\n            else {\n                data.callback = '';\n            }\n            data.info = [];\n            if (typeof args.info === 'object') {\n                for (const key in args.info) {\n                    if (args.info.hasOwnProperty(key)) {\n                        let value = args.info[key];\n                        if (typeof key !== 'string') {\n                            throw new Error('Invalid info dict, keys must be strings');\n                        }\n                        if (typeof value === 'string') {\n                            value = textEncoder.encode(value);\n                        }\n                        data.info.push({ key, value });\n                    }\n                }\n            }\n            const req = new SigningRequest(ProtocolVersion, data, textEncoder, textDecoder, options.zlib, options.abiProvider);\n            // sign the request if given a signature provider\n            if (options.signatureProvider) {\n                req.sign(options.signatureProvider);\n            }\n            return req;\n        }\n        /** Creates an identity request. */\n        static identity(args, options = {}) {\n            let permission = {\n                actor: args.account || PlaceholderName,\n                permission: args.permission || PlaceholderPermission,\n            };\n            if (permission.actor === PlaceholderName &&\n                permission.permission === PlaceholderPermission) {\n                permission = null;\n            }\n            return this.create({\n                identity: {\n                    permission,\n                },\n                broadcast: false,\n                callback: args.callback,\n                info: args.info,\n            }, options);\n        }\n        /**\n         * Create a request from a chain id and serialized transaction.\n         * @param chainId The chain id where the transaction is valid.\n         * @param serializedTransaction The serialized transaction.\n         * @param options Creation options.\n         */\n        static fromTransaction(chainId, serializedTransaction, options = {}) {\n            if (typeof chainId !== 'string') {\n                chainId = Serialize.arrayToHex(chainId);\n            }\n            if (typeof serializedTransaction === 'string') {\n                serializedTransaction = Serialize.hexToUint8Array(serializedTransaction);\n            }\n            let buf = new Serialize.SerialBuffer({\n                textDecoder: options.textDecoder,\n                textEncoder: options.textEncoder,\n            });\n            buf.push(2); // header\n            const id = variantId(chainId);\n            if (id[0] === 'chain_alias') {\n                buf.push(0);\n                buf.push(id[1]);\n            }\n            else {\n                buf.push(1);\n                buf.pushArray(Serialize.hexToUint8Array(id[1]));\n            }\n            buf.push(2); // transaction variant\n            buf.pushArray(serializedTransaction);\n            buf.push(abi.RequestFlagsBroadcast); // flags\n            buf.push(0); // callback\n            buf.push(0); // info\n            return SigningRequest.fromData(buf.asUint8Array(), options);\n        }\n        /** Creates a signing request from encoded `esr:` uri string. */\n        static from(uri, options = {}) {\n            if (typeof uri !== 'string') {\n                throw new Error('Invalid request uri');\n            }\n            const [scheme, path] = uri.split(':');\n            if (scheme !== 'esr' && scheme !== 'web+esr') {\n                throw new Error('Invalid scheme');\n            }\n            const data = base64u.decode(path.startsWith('//') ? path.slice(2) : path);\n            return SigningRequest.fromData(data, options);\n        }\n        static fromData(data, options = {}) {\n            const header = data[0];\n            const version = header & ~(1 << 7);\n            if (version !== ProtocolVersion) {\n                throw new Error('Unsupported protocol version');\n            }\n            let array = data.slice(1);\n            if ((header & (1 << 7)) !== 0) {\n                if (!options.zlib) {\n                    throw new Error('Compressed URI needs zlib');\n                }\n                array = options.zlib.inflateRaw(array);\n            }\n            const textEncoder = options.textEncoder || new TextEncoder();\n            const textDecoder = options.textDecoder || new TextDecoder();\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder,\n                textDecoder,\n                array,\n            });\n            const req = SigningRequest.type.deserialize(buffer);\n            let signature;\n            if (buffer.haveReadData()) {\n                const type = AbiTypes.get('request_signature');\n                signature = type.deserialize(buffer);\n            }\n            return new SigningRequest(version, req, textEncoder, textDecoder, options.zlib, options.abiProvider, signature);\n        }\n        /**\n         * Sign the request, mutating.\n         * @param signatureProvider The signature provider that provides a signature for the signer.\n         */\n        sign(signatureProvider) {\n            const message = this.getSignatureDigest();\n            this.signature = signatureProvider.sign(Serialize.arrayToHex(message));\n        }\n        /**\n         * Get the signature digest for this request.\n         */\n        getSignatureDigest() {\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder: this.textEncoder,\n                textDecoder: this.textDecoder,\n            });\n            // protocol version + utf8 \"request\"\n            buffer.pushArray([this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74]);\n            buffer.pushArray(this.getData());\n            return sha256(buffer.asUint8Array());\n        }\n        /**\n         * Set the signature data for this request, mutating.\n         * @param signer Account name of signer.\n         * @param signature The signature string.\n         */\n        setSignature(signer, signature) {\n            this.signature = { signer, signature };\n        }\n        /**\n         * Set the request callback, mutating.\n         * @param url Where the callback should be sent.\n         * @param background Whether the callback should be sent in the background.\n         */\n        setCallback(url, background) {\n            this.data.callback = url;\n            if (background) {\n                this.data.flags |= abi.RequestFlagsBackground;\n            }\n            else {\n                this.data.flags &= ~abi.RequestFlagsBackground;\n            }\n        }\n        /**\n         * Set broadcast flag.\n         * @param broadcast Whether the transaction should be broadcast by receiver.\n         */\n        setBroadcast(broadcast) {\n            if (broadcast) {\n                this.data.flags |= abi.RequestFlagsBroadcast;\n            }\n            else {\n                this.data.flags &= ~abi.RequestFlagsBroadcast;\n            }\n        }\n        /**\n         * Encode this request into an `esr:` uri.\n         * @argument compress Whether to compress the request data using zlib,\n         *                    defaults to true if omitted and zlib is present;\n         *                    otherwise false.\n         * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n         *                   Defaults to true.\n         * @returns An esr uri string.\n         */\n        encode(compress, slashes) {\n            const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n            if (shouldCompress && this.zlib === undefined) {\n                throw new Error('Need zlib to compress');\n            }\n            let header = this.version;\n            const data = this.getData();\n            const sigData = this.getSignatureData();\n            let array = new Uint8Array(data.byteLength + sigData.byteLength);\n            array.set(data, 0);\n            array.set(sigData, data.byteLength);\n            if (shouldCompress) {\n                const deflated = this.zlib.deflateRaw(array);\n                if (array.byteLength > deflated.byteLength) {\n                    header |= 1 << 7;\n                    array = deflated;\n                }\n            }\n            const out = new Uint8Array(1 + array.byteLength);\n            out[0] = header;\n            out.set(array, 1);\n            let scheme = 'esr:';\n            if (slashes !== false) {\n                scheme += '//';\n            }\n            return scheme + base64u.encode(out);\n        }\n        /** Get the request data without header or signature. */\n        getData() {\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder: this.textEncoder,\n                textDecoder: this.textDecoder,\n            });\n            SigningRequest.type.serialize(buffer, this.data);\n            return buffer.asUint8Array();\n        }\n        /** Get signature data, returns an empty array if request is not signed. */\n        getSignatureData() {\n            if (!this.signature) {\n                return new Uint8Array(0);\n            }\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder: this.textEncoder,\n                textDecoder: this.textDecoder,\n            });\n            const type = AbiTypes.get('request_signature');\n            type.serialize(buffer, this.signature);\n            return buffer.asUint8Array();\n        }\n        /** ABI definitions required to resolve request. */\n        getRequiredAbis() {\n            return this.getRawActions()\n                .filter((action) => !isIdentity(action))\n                .map((action) => action.account)\n                .filter((value, index, self) => self.indexOf(value) === index);\n        }\n        /** Whether TaPoS values are required to resolve request. */\n        requiresTapos() {\n            let tx = this.getRawTransaction();\n            return !this.isIdentity() && !hasTapos(tx);\n        }\n        /** Resolve required ABI definitions. */\n        async fetchAbis(abiProvider) {\n            const provider = abiProvider || this.abiProvider;\n            if (!provider) {\n                throw new Error('Missing ABI provider');\n            }\n            const abis = new Map();\n            await Promise.all(this.getRequiredAbis().map(async (account) => {\n                abis.set(account, await provider.getAbi(account));\n            }));\n            return abis;\n        }\n        /**\n         * Decode raw actions actions to object representations.\n         * @param abis ABI defenitions required to decode all actions.\n         * @param signer Placeholders in actions will be resolved to signer if set.\n         */\n        resolveActions(abis, signer) {\n            return this.getRawActions().map((rawAction) => {\n                let contractAbi;\n                if (isIdentity(rawAction)) {\n                    contractAbi = abi.data;\n                }\n                else {\n                    contractAbi = abis.get(rawAction.account);\n                }\n                if (!contractAbi) {\n                    throw new Error(`Missing ABI definition for ${rawAction.account}`);\n                }\n                const contract = getContract(contractAbi);\n                if (signer) {\n                    // hook into eosjs name decoder and return the signing account if we encounter the placeholder\n                    // this is fine because getContract re-creates the initial types each time\n                    contract.types.get('name').deserialize = (buffer) => {\n                        const name = buffer.getName();\n                        if (name === PlaceholderName) {\n                            return signer.actor;\n                        }\n                        else if (name === PlaceholderPermission) {\n                            return signer.permission;\n                        }\n                        else {\n                            return name;\n                        }\n                    };\n                }\n                const action = Serialize.deserializeAction(contract, rawAction.account, rawAction.name, rawAction.authorization, rawAction.data, this.textEncoder, this.textDecoder);\n                if (signer) {\n                    action.authorization = action.authorization.map((auth) => {\n                        let { actor, permission } = auth;\n                        if (actor === PlaceholderName) {\n                            actor = signer.actor;\n                        }\n                        if (permission === PlaceholderPermission) {\n                            permission = signer.permission;\n                        }\n                        // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n                        if (permission === PlaceholderName) {\n                            permission = signer.permission;\n                        }\n                        return { actor, permission };\n                    });\n                }\n                return action;\n            });\n        }\n        resolveTransaction(abis, signer, ctx = {}) {\n            let tx = this.getRawTransaction();\n            if (!this.isIdentity() && !hasTapos(tx)) {\n                if (ctx.expiration !== undefined &&\n                    ctx.ref_block_num !== undefined &&\n                    ctx.ref_block_prefix !== undefined) {\n                    tx.expiration = ctx.expiration;\n                    tx.ref_block_num = ctx.ref_block_num;\n                    tx.ref_block_prefix = ctx.ref_block_prefix;\n                }\n                else if (ctx.block_num !== undefined &&\n                    ctx.ref_block_prefix !== undefined &&\n                    ctx.timestamp !== undefined) {\n                    const header = Serialize.transactionHeader(ctx, ctx.expire_seconds !== undefined ? ctx.expire_seconds : 60);\n                    tx.expiration = header.expiration;\n                    tx.ref_block_num = header.ref_block_num;\n                    tx.ref_block_prefix = header.ref_block_prefix;\n                }\n                else {\n                    throw new Error('Invalid transaction context, need either a reference block or explicit TAPoS values');\n                }\n            }\n            const actions = this.resolveActions(abis, signer);\n            return { ...tx, actions };\n        }\n        resolve(abis, signer, ctx = {}) {\n            const transaction = this.resolveTransaction(abis, signer, ctx);\n            const buf = new Serialize.SerialBuffer({\n                textDecoder: this.textDecoder,\n                textEncoder: this.textEncoder,\n            });\n            const actions = transaction.actions.map((action) => {\n                let contractAbi;\n                if (isIdentity(action)) {\n                    contractAbi = abi.data;\n                }\n                else {\n                    contractAbi = abis.get(action.account);\n                }\n                if (!contractAbi) {\n                    throw new Error(`Missing ABI definition for ${action.account}`);\n                }\n                const contract = getContract(contractAbi);\n                const { textDecoder, textEncoder } = this;\n                return Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder);\n            });\n            SigningRequest.transactionType.serialize(buf, {\n                ...transaction,\n                actions,\n            });\n            const serializedTransaction = buf.asUint8Array();\n            return new ResolvedSigningRequest(this, signer, transaction, serializedTransaction);\n        }\n        /**\n         * Get the id of the chain where this request is valid.\n         * @returns The 32-byte chain id as hex encoded string.\n         */\n        getChainId() {\n            const id = this.data.chain_id;\n            switch (id[0]) {\n                case 'chain_id':\n                    return id[1];\n                case 'chain_alias':\n                    if (ChainIdLookup.has(id[1])) {\n                        return ChainIdLookup.get(id[1]);\n                    }\n                    else {\n                        throw new Error('Unknown chain id alias');\n                    }\n                default:\n                    throw new Error('Invalid signing request data');\n            }\n        }\n        /** Return the actions in this request with action data encoded. */\n        getRawActions() {\n            const req = this.data.req;\n            switch (req[0]) {\n                case 'action':\n                    return [req[1]];\n                case 'action[]':\n                    return req[1];\n                case 'identity':\n                    let data = '0101000000000000000200000000000000'; // placeholder permission\n                    let authorization = [PlaceholderAuth];\n                    if (req[1].permission) {\n                        let buf = new Serialize.SerialBuffer({\n                            textDecoder: this.textDecoder,\n                            textEncoder: this.textEncoder,\n                        });\n                        SigningRequest.idType.serialize(buf, req[1]);\n                        data = Serialize.arrayToHex(buf.asUint8Array());\n                        authorization = [req[1].permission];\n                    }\n                    return [\n                        {\n                            account: '',\n                            name: 'identity',\n                            authorization,\n                            data,\n                        },\n                    ];\n                case 'transaction':\n                    return req[1].actions;\n                default:\n                    throw new Error('Invalid signing request data');\n            }\n        }\n        /** Unresolved transaction. */\n        getRawTransaction() {\n            const req = this.data.req;\n            switch (req[0]) {\n                case 'transaction':\n                    return req[1];\n                case 'action':\n                case 'action[]':\n                case 'identity':\n                    return {\n                        actions: this.getRawActions(),\n                        context_free_actions: [],\n                        transaction_extensions: [],\n                        expiration: '1970-01-01T00:00:00.000',\n                        ref_block_num: 0,\n                        ref_block_prefix: 0,\n                        max_cpu_usage_ms: 0,\n                        max_net_usage_words: 0,\n                        delay_sec: 0,\n                    };\n                default:\n                    throw new Error('Invalid signing request data');\n            }\n        }\n        /** Whether the request is an identity request. */\n        isIdentity() {\n            return this.data.req[0] === 'identity';\n        }\n        /** Whether the request should be broadcast by signer. */\n        shouldBroadcast() {\n            if (this.isIdentity()) {\n                return false;\n            }\n            return (this.data.flags & abi.RequestFlagsBroadcast) !== 0;\n        }\n        /**\n         * Present if the request is an identity request and requests a specific account.\n         * @note This returns `nil` unless a specific identity has been requested,\n         *       use `isIdentity` to check id requests.\n         */\n        getIdentity() {\n            if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n                const { actor } = this.data.req[1].permission;\n                return actor === PlaceholderName ? null : actor;\n            }\n            return null;\n        }\n        /**\n         * Present if the request is an identity request and requests a specific permission.\n         * @note This returns `nil` unless a specific permission has been requested,\n         *       use `isIdentity` to check id requests.\n         */\n        getIdentityPermission() {\n            if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n                const { permission } = this.data.req[1].permission;\n                return permission === PlaceholderName ? null : permission;\n            }\n            return null;\n        }\n        /** Get raw info dict */\n        getRawInfo() {\n            let rv = {};\n            for (const { key, value } of this.data.info) {\n                rv[key] = typeof value === 'string' ? Serialize.hexToUint8Array(value) : value;\n            }\n            return rv;\n        }\n        /** Get metadata values as strings. */\n        getInfo() {\n            let rv = {};\n            let raw = this.getRawInfo();\n            for (const key of Object.keys(raw)) {\n                rv[key] = this.textDecoder.decode(raw[key]);\n            }\n            return rv;\n        }\n        /** Set a metadata key. */\n        setInfoKey(key, value) {\n            let pair = this.data.info.find((pair) => {\n                return pair.key === key;\n            });\n            let encodedValue;\n            switch (typeof value) {\n                case 'string':\n                    encodedValue = this.textEncoder.encode(value);\n                    break;\n                case 'boolean':\n                    encodedValue = new Uint8Array([value ? 1 : 0]);\n                    break;\n                default:\n                    throw new TypeError('Invalid value type, expected string or boolean.');\n            }\n            if (!pair) {\n                pair = { key, value: encodedValue };\n                this.data.info.push(pair);\n            }\n            else {\n                pair.value = encodedValue;\n            }\n        }\n        /** Return a deep copy of this request. */\n        clone() {\n            let signature;\n            if (this.signature) {\n                signature = JSON.parse(JSON.stringify(this.signature));\n            }\n            const data = JSON.stringify(this.data, (key, value) => {\n                if (value instanceof Uint8Array) {\n                    return Array.from(value);\n                }\n                return value;\n            });\n            return new SigningRequest(this.version, JSON.parse(data), this.textEncoder, this.textDecoder, this.zlib, this.abiProvider, signature);\n        }\n        // Convenience methods.\n        toString() {\n            return this.encode();\n        }\n        toJSON() {\n            return this.encode();\n        }\n    }\n    SigningRequest.type = AbiTypes.get('signing_request');\n    SigningRequest.idType = AbiTypes.get('identity');\n    SigningRequest.transactionType = AbiTypes.get('transaction');\n    return SigningRequest;\n})();\nexport { SigningRequest };\nexport class ResolvedSigningRequest {\n    constructor(request, signer, transaction, serializedTransaction) {\n        this.request = request;\n        this.signer = signer;\n        this.transaction = transaction;\n        this.serializedTransaction = serializedTransaction;\n    }\n    /** Recreate a resolved request from a callback payload. */\n    static async fromPayload(payload, options = {}) {\n        const request = SigningRequest.from(payload.req, options);\n        const abis = await request.fetchAbis();\n        return request.resolve(abis, { actor: payload.sa, permission: payload.sp }, {\n            ref_block_num: Number(payload.rbn),\n            ref_block_prefix: Number(payload.rid),\n            expiration: payload.ex,\n        });\n    }\n    getTransactionId() {\n        return Serialize.arrayToHex(sha256(this.serializedTransaction));\n    }\n    getCallback(signatures, blockNum) {\n        const { callback, flags } = this.request.data;\n        if (!callback || callback.length === 0) {\n            return null;\n        }\n        if (!signatures || signatures.length === 0) {\n            throw new Error('Must have at least one signature to resolve callback');\n        }\n        const payload = {\n            sig: signatures[0],\n            tx: this.getTransactionId(),\n            rbn: String(this.transaction.ref_block_num),\n            rid: String(this.transaction.ref_block_prefix),\n            ex: this.transaction.expiration,\n            req: this.request.encode(),\n            sa: this.signer.actor,\n            sp: this.signer.permission,\n        };\n        for (const [n, sig] of signatures.slice(1).entries()) {\n            payload[`sig${n}`] = sig;\n        }\n        if (blockNum) {\n            payload.bn = String(blockNum);\n        }\n        const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n            return payload[m] || '';\n        });\n        return {\n            background: (flags & abi.RequestFlagsBackground) !== 0,\n            payload,\n            url,\n        };\n    }\n}\n/** Internal helper that creates a contract representation from an abi for the eosjs serializer. */\nfunction getContract(contractAbi) {\n    const types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), contractAbi);\n    const actions = new Map();\n    for (const { name, type } of contractAbi.actions) {\n        actions.set(name, Serialize.getType(types, type));\n    }\n    return { types, actions };\n}\nasync function serializeAction(action, textEncoder, textDecoder, abiProvider) {\n    if (typeof action.data === 'string') {\n        return action;\n    }\n    let contractAbi;\n    if (isIdentity(action)) {\n        contractAbi = abi.data;\n    }\n    else if (abiProvider) {\n        contractAbi = await abiProvider.getAbi(action.account);\n    }\n    else {\n        throw new Error('Missing abi provider');\n    }\n    const contract = getContract(contractAbi);\n    return Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder);\n}\nfunction variantId(chainId) {\n    if (!chainId) {\n        chainId = ChainName.EOS;\n    }\n    if (typeof chainId === 'number') {\n        return ['chain_alias', chainId];\n    }\n    else {\n        // resolve known chain id's to their aliases\n        const name = idToName(chainId);\n        if (name !== ChainName.UNKNOWN) {\n            return ['chain_alias', name];\n        }\n        return ['chain_id', chainId];\n    }\n}\nfunction isIdentity(action) {\n    return action.account === '' && action.name === 'identity';\n}\nfunction hasTapos(tx) {\n    return !(tx.expiration === '1970-01-01T00:00:00.000' &&\n        tx.ref_block_num === 0 &&\n        tx.ref_block_prefix === 0);\n}\n/** Resolve a chain id to a chain name alias, returns UNKNOWN (0x00) if the chain id has no alias. */\nexport function idToName(chainId) {\n    chainId = chainId.toLowerCase();\n    for (const [n, id] of ChainIdLookup) {\n        if (id === chainId) {\n            n;\n        }\n    }\n    return ChainName.UNKNOWN;\n}\n/** Resolve a chain name alias to a chain id. */\nexport function nameToId(chainName) {\n    return (ChainIdLookup.get(chainName) ||\n        '0000000000000000000000000000000000000000000000000000000000000000');\n}\n"]},"metadata":{},"sourceType":"module"}