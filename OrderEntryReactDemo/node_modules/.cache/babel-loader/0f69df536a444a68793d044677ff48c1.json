{"ast":null,"code":"import * as esr from 'eosio-signing-request';\nimport { JsonRpc } from 'eosjs';\nimport * as ecc from 'eosjs-ecc';\nimport WebSocket from 'isomorphic-ws';\nimport zlib from 'pako';\nimport { v4 as uuid } from 'uuid';\nimport { CancelError, IdentityError } from './errors';\nimport { defaults } from './link-options';\nimport { LinkChannelSession, LinkFallbackSession, LinkSession } from './link-session';\nimport { abiEncode, fetch, generatePrivateKey, normalizePublicKey, publicKeyEqual } from './utils';\n/**\n * Main class, also exposed as the default export of the library.\n *\n * Example:\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport()\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\n\nexport class Link {\n  /** Create a new link instance. */\n  constructor(options) {\n    this.abiCache = new Map();\n    this.pendingAbis = new Map();\n\n    if (typeof options !== 'object') {\n      throw new TypeError('Missing options object');\n    }\n\n    if (!options.transport) {\n      throw new TypeError('options.transport is required, see https://github.com/greymass/anchor-link#transports');\n    }\n\n    if (options.rpc === undefined || typeof options.rpc === 'string') {\n      this.rpc = new JsonRpc(options.rpc || defaults.rpc, {\n        fetch: fetch\n      });\n    } else {\n      this.rpc = options.rpc;\n    }\n\n    if (options.chainId) {\n      this.chainId = typeof options.chainId === 'number' ? esr.nameToId(options.chainId) : options.chainId;\n    } else {\n      this.chainId = defaults.chainId;\n    }\n\n    this.serviceAddress = (options.service || defaults.service).trim().replace(/\\/$/, '');\n    this.transport = options.transport;\n\n    if (options.storage !== null) {\n      this.storage = options.storage || this.transport.storage;\n    }\n\n    this.requestOptions = {\n      abiProvider: this,\n      textDecoder: options.textDecoder || new TextDecoder(),\n      textEncoder: options.textEncoder || new TextEncoder(),\n      zlib\n    };\n  }\n  /**\n   * Fetch the ABI for given account, cached.\n   * @internal\n   */\n\n\n  async getAbi(account) {\n    let rv = this.abiCache.get(account);\n\n    if (!rv) {\n      let getAbi = this.pendingAbis.get(account);\n\n      if (!getAbi) {\n        getAbi = this.rpc.get_abi(account);\n        this.pendingAbis.set(account, getAbi);\n      }\n\n      rv = (await getAbi).abi;\n      this.pendingAbis.delete(account);\n\n      if (rv) {\n        this.abiCache.set(account, rv);\n      }\n    }\n\n    return rv;\n  }\n  /**\n   * Create a new unique buoy callback url.\n   * @internal\n   */\n\n\n  createCallbackUrl() {\n    return `${this.serviceAddress}/${uuid()}`;\n  }\n  /**\n   * Create a SigningRequest instance configured for this link.\n   * @internal\n   */\n\n\n  async createRequest(args, transport) {\n    const t = transport || this.transport; // generate unique callback url\n\n    let request = await esr.SigningRequest.create({ ...args,\n      chainId: this.chainId,\n      broadcast: false,\n      callback: {\n        url: this.createCallbackUrl(),\n        background: true\n      }\n    }, this.requestOptions);\n\n    if (t.prepare) {\n      request = await t.prepare(request);\n    }\n\n    return request;\n  }\n  /**\n   * Send a SigningRequest instance using this link.\n   * @internal\n   */\n\n\n  async sendRequest(request, transport, broadcast = false) {\n    const t = transport || this.transport;\n\n    try {\n      const linkUrl = request.data.callback;\n\n      if (!linkUrl.startsWith(this.serviceAddress)) {\n        throw new Error('Request must have a link callback');\n      }\n\n      if (request.data.flags !== 2) {\n        throw new Error('Invalid request flags');\n      } // wait for callback or user cancel\n\n\n      const ctx = {};\n      const socket = waitForCallback(linkUrl, ctx).then(data => {\n        if (typeof data.rejected === 'string') {\n          throw new CancelError(`Rejected by wallet: ${data.rejected}`);\n        }\n\n        return data;\n      });\n      const cancel = new Promise((resolve, reject) => {\n        t.onRequest(request, reason => {\n          if (ctx.cancel) {\n            ctx.cancel();\n          }\n\n          if (typeof reason === 'string') {\n            reject(new CancelError(reason));\n          } else {\n            reject(reason);\n          }\n        });\n      });\n      const payload = await Promise.race([socket, cancel]);\n      const signer = {\n        actor: payload.sa,\n        permission: payload.sp\n      };\n      const signatures = Object.keys(payload).filter(key => key.startsWith('sig') && key !== 'sig0').map(key => payload[key]); // recreate transaction from request response\n\n      const resolved = await esr.ResolvedSigningRequest.fromPayload(payload, this.requestOptions);\n      const info = resolved.request.getInfo();\n\n      if (info['fuel_sig']) {\n        signatures.unshift(info['fuel_sig']);\n      }\n\n      const {\n        serializedTransaction,\n        transaction\n      } = resolved;\n      const result = {\n        request: resolved.request,\n        serializedTransaction,\n        transaction,\n        signatures,\n        payload,\n        signer\n      };\n\n      if (broadcast) {\n        const res = await this.rpc.push_transaction({\n          signatures: result.signatures,\n          serializedTransaction: result.serializedTransaction\n        });\n        result.processed = res.processed;\n      }\n\n      if (t.onSuccess) {\n        t.onSuccess(request, result);\n      }\n\n      return result;\n    } catch (error) {\n      if (t.onFailure) {\n        t.onFailure(request, error);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Sign and optionally broadcast a EOSIO transaction, action or actions.\n   *\n   * Example:\n   *\n   * ```ts\n   * let result = await myLink.transact({transaction: myTx})\n   * ```\n   *\n   * @param args The action, actions or transaction to use.\n   * @param options Options for this transact call.\n   * @param transport Transport override, for internal use.\n   */\n\n\n  async transact(args, options, transport) {\n    const t = transport || this.transport;\n    const broadcast = options ? options.broadcast !== false : true; // Initialize the loading state of the transport\n\n    if (t && t.showLoading) {\n      t.showLoading();\n    } // eosjs transact compat: upgrade to transaction if args have any header fields\n\n\n    let anyArgs = args;\n\n    if (args.actions && (anyArgs.expiration || anyArgs.ref_block_num || anyArgs.ref_block_prefix || anyArgs.max_net_usage_words || anyArgs.max_cpu_usage_ms || anyArgs.delay_sec)) {\n      args = {\n        transaction: {\n          expiration: '1970-01-01T00:00:00',\n          ref_block_num: 0,\n          ref_block_prefix: 0,\n          max_net_usage_words: 0,\n          max_cpu_usage_ms: 0,\n          delay_sec: 0,\n          ...anyArgs\n        }\n      };\n    }\n\n    const request = await this.createRequest(args, t);\n    const result = await this.sendRequest(request, t, broadcast);\n    return result;\n  }\n  /**\n   * Send an identity request and verify the identity proof.\n   * @param requestPermission Optional request permission if the request is for a specific account or permission.\n   * @param info Metadata to add to the request.\n   * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n   */\n\n\n  async identify(requestPermission, info) {\n    const request = await this.createRequest({\n      identity: {\n        permission: requestPermission || null\n      },\n      info\n    });\n    const res = await this.sendRequest(request);\n\n    if (!res.request.isIdentity()) {\n      throw new IdentityError(`Unexpected response`);\n    }\n\n    const message = Buffer.concat([Buffer.from(request.getChainId(), 'hex'), Buffer.from(res.serializedTransaction), Buffer.alloc(32)]);\n    const {\n      signer\n    } = res;\n    const signerKey = ecc.recover(res.signatures[0], message);\n    const account = await this.rpc.get_account(signer.actor);\n\n    if (!account) {\n      throw new IdentityError(`Signature from unknown account: ${signer.actor}`);\n    }\n\n    const permission = account.permissions.find(({\n      perm_name\n    }) => perm_name === signer.permission);\n\n    if (!permission) {\n      throw new IdentityError(`${signer.actor} signed for unknown permission: ${signer.permission}`);\n    }\n\n    const auth = permission.required_auth;\n    const keyAuth = auth.keys.find(({\n      key\n    }) => publicKeyEqual(key, signerKey));\n\n    if (!keyAuth) {\n      throw new IdentityError(`${formatAuth(signer)} has no key matching id signature`);\n    }\n\n    if (auth.threshold > keyAuth.weight) {\n      throw new IdentityError(`${formatAuth(signer)} signature does not reach auth threshold`);\n    }\n\n    if (requestPermission) {\n      if (requestPermission.actor !== esr.PlaceholderName && requestPermission.actor !== signer.actor || requestPermission.permission !== esr.PlaceholderPermission && requestPermission.permission !== signer.permission) {\n        throw new IdentityError(`Unexpected identity proof from ${formatAuth(signer)}, expected ${formatAuth(requestPermission)} `);\n      }\n    }\n\n    return { ...res,\n      account,\n      signerKey\n    };\n  }\n  /**\n   * Login and create a persistent session.\n   * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n   *                   Should be set to the contract account if applicable.\n   */\n\n\n  async login(identifier) {\n    const privateKey = await generatePrivateKey();\n    const requestKey = ecc.privateToPublic(privateKey);\n    const createInfo = {\n      session_name: identifier,\n      request_key: requestKey\n    };\n    const res = await this.identify(undefined, {\n      link: abiEncode(createInfo, 'link_create')\n    });\n    const metadata = {\n      sameDevice: res.request.getRawInfo()['return_path'] !== undefined\n    };\n    let session;\n\n    if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n      session = new LinkChannelSession(this, {\n        identifier,\n        auth: res.signer,\n        publicKey: res.signerKey,\n        channel: {\n          url: res.payload.link_ch,\n          key: res.payload.link_key,\n          name: res.payload.link_name\n        },\n        requestKey: privateKey\n      }, metadata);\n    } else {\n      session = new LinkFallbackSession(this, {\n        identifier,\n        auth: res.signer,\n        publicKey: res.signerKey\n      }, metadata);\n    }\n\n    if (this.storage) {\n      await this.storeSession(identifier, session);\n    }\n\n    return { ...res,\n      session\n    };\n  }\n  /**\n   * Restore previous session, see [[Link.login]] to create a new session.\n   * @param identifier The session identifier, should be same as what was used when creating the session with [[Link.login]].\n   * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n   * @returns A [[LinkSession]] instance or null if no session can be found.\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n   **/\n\n\n  async restoreSession(identifier, auth) {\n    if (!this.storage) {\n      throw new Error('Unable to restore session: No storage adapter configured');\n    }\n\n    let key;\n\n    if (auth) {\n      key = this.sessionKey(identifier, formatAuth(auth));\n    } else {\n      let latest = (await this.listSessions(identifier))[0];\n\n      if (!latest) {\n        return null;\n      }\n\n      key = this.sessionKey(identifier, formatAuth(latest));\n    }\n\n    let data = await this.storage.read(key);\n\n    if (!data) {\n      return null;\n    }\n\n    let sessionData;\n\n    try {\n      sessionData = JSON.parse(data);\n    } catch (error) {\n      throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);\n    }\n\n    const session = LinkSession.restore(this, sessionData);\n\n    if (auth) {\n      // update latest used\n      await this.touchSession(identifier, auth);\n    }\n\n    return session;\n  }\n  /**\n   * List stored session auths for given identifier.\n   * The most recently used session is at the top (index 0).\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n   **/\n\n\n  async listSessions(identifier) {\n    if (!this.storage) {\n      throw new Error('Unable to list sessions: No storage adapter configured');\n    }\n\n    let key = this.sessionKey(identifier, 'list');\n    let list;\n\n    try {\n      list = JSON.parse((await this.storage.read(key)) || '[]');\n    } catch (error) {\n      throw new Error(`Unable to list sessions: Stored JSON invalid (${error.message || String(error)})`);\n    }\n\n    return list;\n  }\n  /**\n   * Remove stored session for given identifier and auth.\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n   */\n\n\n  async removeSession(identifier, auth) {\n    if (!this.storage) {\n      throw new Error('Unable to remove session: No storage adapter configured');\n    }\n\n    let key = this.sessionKey(identifier, formatAuth(auth));\n    await this.storage.remove(key);\n    await this.touchSession(identifier, auth, true);\n  }\n  /**\n   * Remove all stored sessions for given identifier.\n   * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n   */\n\n\n  async clearSessions(identifier) {\n    if (!this.storage) {\n      throw new Error('Unable to clear sessions: No storage adapter configured');\n    }\n\n    for (const auth of await this.listSessions(identifier)) {\n      await this.removeSession(identifier, auth);\n    }\n  }\n  /**\n   * Create an eosjs compatible signature provider using this link.\n   * @param availableKeys Keys the created provider will claim to be able to sign for.\n   * @param transport (internal) Transport override for this call.\n   * @note We don't know what keys are available so those have to be provided,\n   *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n   */\n\n\n  makeSignatureProvider(availableKeys, transport) {\n    return {\n      getAvailableKeys: async () => availableKeys,\n      sign: async args => {\n        const t = transport || this.transport;\n        let request = esr.SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, this.requestOptions);\n        request.setCallback(this.createCallbackUrl(), true);\n        request.setBroadcast(false);\n\n        if (t.prepare) {\n          request = await t.prepare(request);\n        }\n\n        const {\n          serializedTransaction,\n          signatures\n        } = await this.sendRequest(request, t);\n        return { ...args,\n          serializedTransaction,\n          signatures\n        };\n      }\n    };\n  }\n  /**\n   * Create an eosjs authority provider using this link.\n   * @note Uses the configured RPC Node's `/v1/chain/get_required_keys` API to resolve keys.\n   */\n\n\n  makeAuthorityProvider() {\n    const {\n      rpc\n    } = this;\n    return {\n      async getRequiredKeys(args) {\n        const {\n          availableKeys,\n          transaction\n        } = args;\n        const result = await rpc.fetch('/v1/chain/get_required_keys', {\n          transaction,\n          available_keys: availableKeys.map(normalizePublicKey)\n        });\n        return result.required_keys.map(normalizePublicKey);\n      }\n\n    };\n  }\n  /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n\n  async touchSession(identifier, auth, remove = false) {\n    let auths = await this.listSessions(identifier);\n    let formattedAuth = formatAuth(auth);\n    let existing = auths.findIndex(a => formatAuth(a) === formattedAuth);\n\n    if (existing >= 0) {\n      auths.splice(existing, 1);\n    }\n\n    if (remove === false) {\n      auths.unshift(auth);\n    }\n\n    let key = this.sessionKey(identifier, 'list');\n    await this.storage.write(key, JSON.stringify(auths));\n  }\n  /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n\n\n  async storeSession(identifier, session) {\n    let key = this.sessionKey(identifier, formatAuth(session.auth));\n    let data = JSON.stringify(session.serialize());\n    await this.storage.write(key, data);\n    await this.touchSession(identifier, session.auth);\n  }\n  /** Session storage key for identifier and suffix. */\n\n\n  sessionKey(identifier, suffix) {\n    return [this.chainId, identifier, suffix].join('-');\n  }\n\n}\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\n\nfunction waitForCallback(url, ctx) {\n  return new Promise((resolve, reject) => {\n    let active = true;\n    let retries = 0;\n    const socketUrl = url.replace(/^http/, 'ws');\n\n    const handleResponse = response => {\n      try {\n        resolve(JSON.parse(response));\n      } catch (error) {\n        error.message = 'Unable to parse callback JSON: ' + error.message;\n        reject(error);\n      }\n    };\n\n    const connect = () => {\n      const socket = new WebSocket(socketUrl);\n\n      ctx.cancel = () => {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {\n          socket.close();\n        }\n      };\n\n      socket.onmessage = event => {\n        active = false;\n\n        if (socket.readyState === WebSocket.OPEN) {\n          socket.close();\n        }\n\n        if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n          const reader = new FileReader();\n\n          reader.onload = () => {\n            handleResponse(reader.result);\n          };\n\n          reader.onerror = error => {\n            reject(error);\n          };\n\n          reader.readAsText(event.data);\n        } else {\n          if (typeof event.data === 'string') {\n            handleResponse(event.data);\n          } else {\n            handleResponse(event.data.toString());\n          }\n        }\n      };\n\n      socket.onopen = () => {\n        retries = 0;\n      };\n\n      socket.onerror = error => {};\n\n      socket.onclose = close => {\n        if (active) {\n          setTimeout(connect, backoff(retries++));\n        }\n      };\n    };\n\n    connect();\n  });\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\n\n\nfunction backoff(tries) {\n  return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\n\n\nfunction formatAuth(auth) {\n  let {\n    actor,\n    permission\n  } = auth;\n\n  if (actor === esr.PlaceholderName) {\n    actor = '<any>';\n  }\n\n  if (permission === esr.PlaceholderName || permission === esr.PlaceholderPermission) {\n    permission = '<any>';\n  }\n\n  return `${actor}@${permission}`;\n}","map":{"version":3,"sources":["../src/link.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as esr from 'eosio-signing-request';\nimport { JsonRpc } from 'eosjs';\nimport * as ecc from 'eosjs-ecc';\nimport WebSocket from 'isomorphic-ws';\nimport zlib from 'pako';\nimport { v4 as uuid } from 'uuid';\nimport { CancelError, IdentityError } from './errors';\nimport { defaults } from './link-options';\nimport { LinkChannelSession, LinkFallbackSession, LinkSession } from './link-session';\nimport { abiEncode, fetch, generatePrivateKey, normalizePublicKey, publicKeyEqual } from './utils';\n/**\n * Main class, also exposed as the default export of the library.\n *\n * Example:\n *\n * ```ts\n * import AnchorLink from 'anchor-link'\n * import ConsoleTransport from 'anchor-link-console-transport'\n *\n * const link = new AnchorLink({\n *     transport: new ConsoleTransport()\n * })\n *\n * const result = await link.transact({actions: myActions})\n * ```\n */\nexport class Link {\n    /** Create a new link instance. */\n    constructor(options) {\n        this.abiCache = new Map();\n        this.pendingAbis = new Map();\n        if (typeof options !== 'object') {\n            throw new TypeError('Missing options object');\n        }\n        if (!options.transport) {\n            throw new TypeError('options.transport is required, see https://github.com/greymass/anchor-link#transports');\n        }\n        if (options.rpc === undefined || typeof options.rpc === 'string') {\n            this.rpc = new JsonRpc(options.rpc || defaults.rpc, { fetch: fetch });\n        }\n        else {\n            this.rpc = options.rpc;\n        }\n        if (options.chainId) {\n            this.chainId =\n                typeof options.chainId === 'number'\n                    ? esr.nameToId(options.chainId)\n                    : options.chainId;\n        }\n        else {\n            this.chainId = defaults.chainId;\n        }\n        this.serviceAddress = (options.service || defaults.service).trim().replace(/\\/$/, '');\n        this.transport = options.transport;\n        if (options.storage !== null) {\n            this.storage = options.storage || this.transport.storage;\n        }\n        this.requestOptions = {\n            abiProvider: this,\n            textDecoder: options.textDecoder || new TextDecoder(),\n            textEncoder: options.textEncoder || new TextEncoder(),\n            zlib,\n        };\n    }\n    /**\n     * Fetch the ABI for given account, cached.\n     * @internal\n     */\n    async getAbi(account) {\n        let rv = this.abiCache.get(account);\n        if (!rv) {\n            let getAbi = this.pendingAbis.get(account);\n            if (!getAbi) {\n                getAbi = this.rpc.get_abi(account);\n                this.pendingAbis.set(account, getAbi);\n            }\n            rv = (await getAbi).abi;\n            this.pendingAbis.delete(account);\n            if (rv) {\n                this.abiCache.set(account, rv);\n            }\n        }\n        return rv;\n    }\n    /**\n     * Create a new unique buoy callback url.\n     * @internal\n     */\n    createCallbackUrl() {\n        return `${this.serviceAddress}/${uuid()}`;\n    }\n    /**\n     * Create a SigningRequest instance configured for this link.\n     * @internal\n     */\n    async createRequest(args, transport) {\n        const t = transport || this.transport;\n        // generate unique callback url\n        let request = await esr.SigningRequest.create({\n            ...args,\n            chainId: this.chainId,\n            broadcast: false,\n            callback: {\n                url: this.createCallbackUrl(),\n                background: true,\n            },\n        }, this.requestOptions);\n        if (t.prepare) {\n            request = await t.prepare(request);\n        }\n        return request;\n    }\n    /**\n     * Send a SigningRequest instance using this link.\n     * @internal\n     */\n    async sendRequest(request, transport, broadcast = false) {\n        const t = transport || this.transport;\n        try {\n            const linkUrl = request.data.callback;\n            if (!linkUrl.startsWith(this.serviceAddress)) {\n                throw new Error('Request must have a link callback');\n            }\n            if (request.data.flags !== 2) {\n                throw new Error('Invalid request flags');\n            }\n            // wait for callback or user cancel\n            const ctx = {};\n            const socket = waitForCallback(linkUrl, ctx).then((data) => {\n                if (typeof data.rejected === 'string') {\n                    throw new CancelError(`Rejected by wallet: ${data.rejected}`);\n                }\n                return data;\n            });\n            const cancel = new Promise((resolve, reject) => {\n                t.onRequest(request, (reason) => {\n                    if (ctx.cancel) {\n                        ctx.cancel();\n                    }\n                    if (typeof reason === 'string') {\n                        reject(new CancelError(reason));\n                    }\n                    else {\n                        reject(reason);\n                    }\n                });\n            });\n            const payload = await Promise.race([socket, cancel]);\n            const signer = {\n                actor: payload.sa,\n                permission: payload.sp,\n            };\n            const signatures = Object.keys(payload)\n                .filter((key) => key.startsWith('sig') && key !== 'sig0')\n                .map((key) => payload[key]);\n            // recreate transaction from request response\n            const resolved = await esr.ResolvedSigningRequest.fromPayload(payload, this.requestOptions);\n            const info = resolved.request.getInfo();\n            if (info['fuel_sig']) {\n                signatures.unshift(info['fuel_sig']);\n            }\n            const { serializedTransaction, transaction } = resolved;\n            const result = {\n                request: resolved.request,\n                serializedTransaction,\n                transaction,\n                signatures,\n                payload,\n                signer,\n            };\n            if (broadcast) {\n                const res = await this.rpc.push_transaction({\n                    signatures: result.signatures,\n                    serializedTransaction: result.serializedTransaction,\n                });\n                result.processed = res.processed;\n            }\n            if (t.onSuccess) {\n                t.onSuccess(request, result);\n            }\n            return result;\n        }\n        catch (error) {\n            if (t.onFailure) {\n                t.onFailure(request, error);\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sign and optionally broadcast a EOSIO transaction, action or actions.\n     *\n     * Example:\n     *\n     * ```ts\n     * let result = await myLink.transact({transaction: myTx})\n     * ```\n     *\n     * @param args The action, actions or transaction to use.\n     * @param options Options for this transact call.\n     * @param transport Transport override, for internal use.\n     */\n    async transact(args, options, transport) {\n        const t = transport || this.transport;\n        const broadcast = options ? options.broadcast !== false : true;\n        // Initialize the loading state of the transport\n        if (t && t.showLoading) {\n            t.showLoading();\n        }\n        // eosjs transact compat: upgrade to transaction if args have any header fields\n        let anyArgs = args;\n        if (args.actions &&\n            (anyArgs.expiration ||\n                anyArgs.ref_block_num ||\n                anyArgs.ref_block_prefix ||\n                anyArgs.max_net_usage_words ||\n                anyArgs.max_cpu_usage_ms ||\n                anyArgs.delay_sec)) {\n            args = {\n                transaction: {\n                    expiration: '1970-01-01T00:00:00',\n                    ref_block_num: 0,\n                    ref_block_prefix: 0,\n                    max_net_usage_words: 0,\n                    max_cpu_usage_ms: 0,\n                    delay_sec: 0,\n                    ...anyArgs,\n                },\n            };\n        }\n        const request = await this.createRequest(args, t);\n        const result = await this.sendRequest(request, t, broadcast);\n        return result;\n    }\n    /**\n     * Send an identity request and verify the identity proof.\n     * @param requestPermission Optional request permission if the request is for a specific account or permission.\n     * @param info Metadata to add to the request.\n     * @note This is for advanced use-cases, you probably want to use [[Link.login]] instead.\n     */\n    async identify(requestPermission, info) {\n        const request = await this.createRequest({\n            identity: { permission: requestPermission || null },\n            info,\n        });\n        const res = await this.sendRequest(request);\n        if (!res.request.isIdentity()) {\n            throw new IdentityError(`Unexpected response`);\n        }\n        const message = Buffer.concat([\n            Buffer.from(request.getChainId(), 'hex'),\n            Buffer.from(res.serializedTransaction),\n            Buffer.alloc(32),\n        ]);\n        const { signer } = res;\n        const signerKey = ecc.recover(res.signatures[0], message);\n        const account = await this.rpc.get_account(signer.actor);\n        if (!account) {\n            throw new IdentityError(`Signature from unknown account: ${signer.actor}`);\n        }\n        const permission = account.permissions.find(({ perm_name }) => perm_name === signer.permission);\n        if (!permission) {\n            throw new IdentityError(`${signer.actor} signed for unknown permission: ${signer.permission}`);\n        }\n        const auth = permission.required_auth;\n        const keyAuth = auth.keys.find(({ key }) => publicKeyEqual(key, signerKey));\n        if (!keyAuth) {\n            throw new IdentityError(`${formatAuth(signer)} has no key matching id signature`);\n        }\n        if (auth.threshold > keyAuth.weight) {\n            throw new IdentityError(`${formatAuth(signer)} signature does not reach auth threshold`);\n        }\n        if (requestPermission) {\n            if ((requestPermission.actor !== esr.PlaceholderName &&\n                requestPermission.actor !== signer.actor) ||\n                (requestPermission.permission !== esr.PlaceholderPermission &&\n                    requestPermission.permission !== signer.permission)) {\n                throw new IdentityError(`Unexpected identity proof from ${formatAuth(signer)}, expected ${formatAuth(requestPermission)} `);\n            }\n        }\n        return {\n            ...res,\n            account,\n            signerKey,\n        };\n    }\n    /**\n     * Login and create a persistent session.\n     * @param identifier The session identifier, an EOSIO name (`[a-z1-5]{1,12}`).\n     *                   Should be set to the contract account if applicable.\n     */\n    async login(identifier) {\n        const privateKey = await generatePrivateKey();\n        const requestKey = ecc.privateToPublic(privateKey);\n        const createInfo = {\n            session_name: identifier,\n            request_key: requestKey,\n        };\n        const res = await this.identify(undefined, {\n            link: abiEncode(createInfo, 'link_create'),\n        });\n        const metadata = { sameDevice: res.request.getRawInfo()['return_path'] !== undefined };\n        let session;\n        if (res.payload.link_ch && res.payload.link_key && res.payload.link_name) {\n            session = new LinkChannelSession(this, {\n                identifier,\n                auth: res.signer,\n                publicKey: res.signerKey,\n                channel: {\n                    url: res.payload.link_ch,\n                    key: res.payload.link_key,\n                    name: res.payload.link_name,\n                },\n                requestKey: privateKey,\n            }, metadata);\n        }\n        else {\n            session = new LinkFallbackSession(this, {\n                identifier,\n                auth: res.signer,\n                publicKey: res.signerKey,\n            }, metadata);\n        }\n        if (this.storage) {\n            await this.storeSession(identifier, session);\n        }\n        return {\n            ...res,\n            session,\n        };\n    }\n    /**\n     * Restore previous session, see [[Link.login]] to create a new session.\n     * @param identifier The session identifier, should be same as what was used when creating the session with [[Link.login]].\n     * @param auth A specific session auth to restore, if omitted the most recently used session will be restored.\n     * @returns A [[LinkSession]] instance or null if no session can be found.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session data.\n     **/\n    async restoreSession(identifier, auth) {\n        if (!this.storage) {\n            throw new Error('Unable to restore session: No storage adapter configured');\n        }\n        let key;\n        if (auth) {\n            key = this.sessionKey(identifier, formatAuth(auth));\n        }\n        else {\n            let latest = (await this.listSessions(identifier))[0];\n            if (!latest) {\n                return null;\n            }\n            key = this.sessionKey(identifier, formatAuth(latest));\n        }\n        let data = await this.storage.read(key);\n        if (!data) {\n            return null;\n        }\n        let sessionData;\n        try {\n            sessionData = JSON.parse(data);\n        }\n        catch (error) {\n            throw new Error(`Unable to restore session: Stored JSON invalid (${error.message || String(error)})`);\n        }\n        const session = LinkSession.restore(this, sessionData);\n        if (auth) {\n            // update latest used\n            await this.touchSession(identifier, auth);\n        }\n        return session;\n    }\n    /**\n     * List stored session auths for given identifier.\n     * The most recently used session is at the top (index 0).\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error retrieving the session list.\n     **/\n    async listSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to list sessions: No storage adapter configured');\n        }\n        let key = this.sessionKey(identifier, 'list');\n        let list;\n        try {\n            list = JSON.parse((await this.storage.read(key)) || '[]');\n        }\n        catch (error) {\n            throw new Error(`Unable to list sessions: Stored JSON invalid (${error.message || String(error)})`);\n        }\n        return list;\n    }\n    /**\n     * Remove stored session for given identifier and auth.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async removeSession(identifier, auth) {\n        if (!this.storage) {\n            throw new Error('Unable to remove session: No storage adapter configured');\n        }\n        let key = this.sessionKey(identifier, formatAuth(auth));\n        await this.storage.remove(key);\n        await this.touchSession(identifier, auth, true);\n    }\n    /**\n     * Remove all stored sessions for given identifier.\n     * @throws If no [[LinkStorage]] adapter is configured or there was an error removing the session data.\n     */\n    async clearSessions(identifier) {\n        if (!this.storage) {\n            throw new Error('Unable to clear sessions: No storage adapter configured');\n        }\n        for (const auth of await this.listSessions(identifier)) {\n            await this.removeSession(identifier, auth);\n        }\n    }\n    /**\n     * Create an eosjs compatible signature provider using this link.\n     * @param availableKeys Keys the created provider will claim to be able to sign for.\n     * @param transport (internal) Transport override for this call.\n     * @note We don't know what keys are available so those have to be provided,\n     *       to avoid this use [[LinkSession.makeSignatureProvider]] instead. Sessions can be created with [[Link.login]].\n     */\n    makeSignatureProvider(availableKeys, transport) {\n        return {\n            getAvailableKeys: async () => availableKeys,\n            sign: async (args) => {\n                const t = transport || this.transport;\n                let request = esr.SigningRequest.fromTransaction(args.chainId, args.serializedTransaction, this.requestOptions);\n                request.setCallback(this.createCallbackUrl(), true);\n                request.setBroadcast(false);\n                if (t.prepare) {\n                    request = await t.prepare(request);\n                }\n                const { serializedTransaction, signatures, } = await this.sendRequest(request, t);\n                return {\n                    ...args,\n                    serializedTransaction,\n                    signatures,\n                };\n            },\n        };\n    }\n    /**\n     * Create an eosjs authority provider using this link.\n     * @note Uses the configured RPC Node's `/v1/chain/get_required_keys` API to resolve keys.\n     */\n    makeAuthorityProvider() {\n        const { rpc } = this;\n        return {\n            async getRequiredKeys(args) {\n                const { availableKeys, transaction } = args;\n                const result = await rpc.fetch('/v1/chain/get_required_keys', {\n                    transaction,\n                    available_keys: availableKeys.map(normalizePublicKey),\n                });\n                return result.required_keys.map(normalizePublicKey);\n            },\n        };\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async touchSession(identifier, auth, remove = false) {\n        let auths = await this.listSessions(identifier);\n        let formattedAuth = formatAuth(auth);\n        let existing = auths.findIndex((a) => formatAuth(a) === formattedAuth);\n        if (existing >= 0) {\n            auths.splice(existing, 1);\n        }\n        if (remove === false) {\n            auths.unshift(auth);\n        }\n        let key = this.sessionKey(identifier, 'list');\n        await this.storage.write(key, JSON.stringify(auths));\n    }\n    /** Makes sure session is in storage list of sessions and moves it to top (most recently used). */\n    async storeSession(identifier, session) {\n        let key = this.sessionKey(identifier, formatAuth(session.auth));\n        let data = JSON.stringify(session.serialize());\n        await this.storage.write(key, data);\n        await this.touchSession(identifier, session.auth);\n    }\n    /** Session storage key for identifier and suffix. */\n    sessionKey(identifier, suffix) {\n        return [this.chainId, identifier, suffix].join('-');\n    }\n}\n/**\n * Connect to a WebSocket channel and wait for a message.\n * @internal\n */\nfunction waitForCallback(url, ctx) {\n    return new Promise((resolve, reject) => {\n        let active = true;\n        let retries = 0;\n        const socketUrl = url.replace(/^http/, 'ws');\n        const handleResponse = (response) => {\n            try {\n                resolve(JSON.parse(response));\n            }\n            catch (error) {\n                error.message = 'Unable to parse callback JSON: ' + error.message;\n                reject(error);\n            }\n        };\n        const connect = () => {\n            const socket = new WebSocket(socketUrl);\n            ctx.cancel = () => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN ||\n                    socket.readyState === WebSocket.CONNECTING) {\n                    socket.close();\n                }\n            };\n            socket.onmessage = (event) => {\n                active = false;\n                if (socket.readyState === WebSocket.OPEN) {\n                    socket.close();\n                }\n                if (typeof Blob !== 'undefined' && event.data instanceof Blob) {\n                    const reader = new FileReader();\n                    reader.onload = () => {\n                        handleResponse(reader.result);\n                    };\n                    reader.onerror = (error) => {\n                        reject(error);\n                    };\n                    reader.readAsText(event.data);\n                }\n                else {\n                    if (typeof event.data === 'string') {\n                        handleResponse(event.data);\n                    }\n                    else {\n                        handleResponse(event.data.toString());\n                    }\n                }\n            };\n            socket.onopen = () => {\n                retries = 0;\n            };\n            socket.onerror = (error) => { };\n            socket.onclose = (close) => {\n                if (active) {\n                    setTimeout(connect, backoff(retries++));\n                }\n            };\n        };\n        connect();\n    });\n}\n/**\n * Exponential backoff function that caps off at 10s after 10 tries.\n * https://i.imgur.com/IrUDcJp.png\n * @internal\n */\nfunction backoff(tries) {\n    return Math.min(Math.pow(tries * 10, 2), 10 * 1000);\n}\n/**\n * Format a EOSIO permission level in the format `actor@permission` taking placeholders into consideration.\n * @internal\n */\nfunction formatAuth(auth) {\n    let { actor, permission } = auth;\n    if (actor === esr.PlaceholderName) {\n        actor = '<any>';\n    }\n    if (permission === esr.PlaceholderName || permission === esr.PlaceholderPermission) {\n        permission = '<any>';\n    }\n    return `${actor}@${permission}`;\n}\n//# sourceMappingURL=link.js.map"]},"metadata":{},"sourceType":"module"}