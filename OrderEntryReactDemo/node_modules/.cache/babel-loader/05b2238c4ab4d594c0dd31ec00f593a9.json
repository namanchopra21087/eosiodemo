{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * EOSIO Signing Request (ESR).\n */\nimport { Serialize } from 'eosjs';\nimport sha256 from 'fast-sha256';\nimport * as abi from './abi';\nimport * as base64u from './base64u';\nvar ProtocolVersion = 2;\nvar AbiTypes = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), abi.data);\n/** Chain ID aliases. */\n\nexport var ChainName;\n\n(function (ChainName) {\n  ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n  ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n  ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n  ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n  ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n  ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n  ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n  ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n  ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n  ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n  ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n  ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\n\nvar ChainIdLookup = new Map([[ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'], [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'], [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'], [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'], [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'], [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'], [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'], [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'], [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'], [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'], [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'], [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c']]);\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\n\nexport var PlaceholderName = '............1'; // aka uint64(1)\n\n/** Placeholder that will resolve to signer permission name. */\n\nexport var PlaceholderPermission = '............2'; // aka uint64(2)\n\nexport var PlaceholderAuth = {\n  actor: PlaceholderName,\n  permission: PlaceholderPermission\n};\n\nvar SigningRequest =\n/** @class */\nfunction () {\n  var SigningRequest = /*#__PURE__*/function () {\n    /**\n     * Create a new signing request.\n     * Normally not used directly, see the `create` and `from` class methods.\n     */\n    function SigningRequest(version, data, textEncoder, textDecoder, zlib, abiProvider, signature) {\n      _classCallCheck(this, SigningRequest);\n\n      if ((data.flags & abi.RequestFlagsBroadcast) !== 0 && data.req[0] === 'identity') {\n        throw new Error('Invalid request (identity request cannot be broadcast)');\n      }\n\n      if ((data.flags & abi.RequestFlagsBroadcast) === 0 && data.callback.length === 0) {\n        throw new Error('Invalid request (nothing to do, no broadcast or callback set)');\n      }\n\n      this.version = version;\n      this.data = data;\n      this.textEncoder = textEncoder;\n      this.textDecoder = textDecoder;\n      this.zlib = zlib;\n      this.abiProvider = abiProvider;\n      this.signature = signature;\n    }\n    /** Create a new signing request. */\n\n\n    _createClass(SigningRequest, [{\n      key: \"sign\",\n      value:\n      /**\n       * Sign the request, mutating.\n       * @param signatureProvider The signature provider that provides a signature for the signer.\n       */\n      function sign(signatureProvider) {\n        var message = this.getSignatureDigest();\n        this.signature = signatureProvider.sign(Serialize.arrayToHex(message));\n      }\n      /**\n       * Get the signature digest for this request.\n       */\n\n    }, {\n      key: \"getSignatureDigest\",\n      value: function getSignatureDigest() {\n        var buffer = new Serialize.SerialBuffer({\n          textEncoder: this.textEncoder,\n          textDecoder: this.textDecoder\n        }); // protocol version + utf8 \"request\"\n\n        buffer.pushArray([this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74]);\n        buffer.pushArray(this.getData());\n        return sha256(buffer.asUint8Array());\n      }\n      /**\n       * Set the signature data for this request, mutating.\n       * @param signer Account name of signer.\n       * @param signature The signature string.\n       */\n\n    }, {\n      key: \"setSignature\",\n      value: function setSignature(signer, signature) {\n        this.signature = {\n          signer: signer,\n          signature: signature\n        };\n      }\n      /**\n       * Set the request callback, mutating.\n       * @param url Where the callback should be sent.\n       * @param background Whether the callback should be sent in the background.\n       */\n\n    }, {\n      key: \"setCallback\",\n      value: function setCallback(url, background) {\n        this.data.callback = url;\n\n        if (background) {\n          this.data.flags |= abi.RequestFlagsBackground;\n        } else {\n          this.data.flags &= ~abi.RequestFlagsBackground;\n        }\n      }\n      /**\n       * Set broadcast flag.\n       * @param broadcast Whether the transaction should be broadcast by receiver.\n       */\n\n    }, {\n      key: \"setBroadcast\",\n      value: function setBroadcast(broadcast) {\n        if (broadcast) {\n          this.data.flags |= abi.RequestFlagsBroadcast;\n        } else {\n          this.data.flags &= ~abi.RequestFlagsBroadcast;\n        }\n      }\n      /**\n       * Encode this request into an `esr:` uri.\n       * @argument compress Whether to compress the request data using zlib,\n       *                    defaults to true if omitted and zlib is present;\n       *                    otherwise false.\n       * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n       *                   Defaults to true.\n       * @returns An esr uri string.\n       */\n\n    }, {\n      key: \"encode\",\n      value: function encode(compress, slashes) {\n        var shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n\n        if (shouldCompress && this.zlib === undefined) {\n          throw new Error('Need zlib to compress');\n        }\n\n        var header = this.version;\n        var data = this.getData();\n        var sigData = this.getSignatureData();\n        var array = new Uint8Array(data.byteLength + sigData.byteLength);\n        array.set(data, 0);\n        array.set(sigData, data.byteLength);\n\n        if (shouldCompress) {\n          var deflated = this.zlib.deflateRaw(array);\n\n          if (array.byteLength > deflated.byteLength) {\n            header |= 1 << 7;\n            array = deflated;\n          }\n        }\n\n        var out = new Uint8Array(1 + array.byteLength);\n        out[0] = header;\n        out.set(array, 1);\n        var scheme = 'esr:';\n\n        if (slashes !== false) {\n          scheme += '//';\n        }\n\n        return scheme + base64u.encode(out);\n      }\n      /** Get the request data without header or signature. */\n\n    }, {\n      key: \"getData\",\n      value: function getData() {\n        var buffer = new Serialize.SerialBuffer({\n          textEncoder: this.textEncoder,\n          textDecoder: this.textDecoder\n        });\n        SigningRequest.type.serialize(buffer, this.data);\n        return buffer.asUint8Array();\n      }\n      /** Get signature data, returns an empty array if request is not signed. */\n\n    }, {\n      key: \"getSignatureData\",\n      value: function getSignatureData() {\n        if (!this.signature) {\n          return new Uint8Array(0);\n        }\n\n        var buffer = new Serialize.SerialBuffer({\n          textEncoder: this.textEncoder,\n          textDecoder: this.textDecoder\n        });\n        var type = AbiTypes.get('request_signature');\n        type.serialize(buffer, this.signature);\n        return buffer.asUint8Array();\n      }\n      /** ABI definitions required to resolve request. */\n\n    }, {\n      key: \"getRequiredAbis\",\n      value: function getRequiredAbis() {\n        return this.getRawActions().filter(function (action) {\n          return !isIdentity(action);\n        }).map(function (action) {\n          return action.account;\n        }).filter(function (value, index, self) {\n          return self.indexOf(value) === index;\n        });\n      }\n      /** Whether TaPoS values are required to resolve request. */\n\n    }, {\n      key: \"requiresTapos\",\n      value: function requiresTapos() {\n        var tx = this.getRawTransaction();\n        return !this.isIdentity() && !hasTapos(tx);\n      }\n      /** Resolve required ABI definitions. */\n\n    }, {\n      key: \"fetchAbis\",\n      value: function () {\n        var _fetchAbis = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(abiProvider) {\n          var provider, abis;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  provider = abiProvider || this.abiProvider;\n\n                  if (provider) {\n                    _context2.next = 3;\n                    break;\n                  }\n\n                  throw new Error('Missing ABI provider');\n\n                case 3:\n                  abis = new Map();\n                  _context2.next = 6;\n                  return Promise.all(this.getRequiredAbis().map( /*#__PURE__*/function () {\n                    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(account) {\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _context.t0 = abis;\n                              _context.t1 = account;\n                              _context.next = 4;\n                              return provider.getAbi(account);\n\n                            case 4:\n                              _context.t2 = _context.sent;\n\n                              _context.t0.set.call(_context.t0, _context.t1, _context.t2);\n\n                            case 6:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee);\n                    }));\n\n                    return function (_x2) {\n                      return _ref.apply(this, arguments);\n                    };\n                  }()));\n\n                case 6:\n                  return _context2.abrupt(\"return\", abis);\n\n                case 7:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function fetchAbis(_x) {\n          return _fetchAbis.apply(this, arguments);\n        }\n\n        return fetchAbis;\n      }()\n      /**\n       * Decode raw actions actions to object representations.\n       * @param abis ABI defenitions required to decode all actions.\n       * @param signer Placeholders in actions will be resolved to signer if set.\n       */\n\n    }, {\n      key: \"resolveActions\",\n      value: function resolveActions(abis, signer) {\n        var _this = this;\n\n        return this.getRawActions().map(function (rawAction) {\n          var contractAbi;\n\n          if (isIdentity(rawAction)) {\n            contractAbi = abi.data;\n          } else {\n            contractAbi = abis.get(rawAction.account);\n          }\n\n          if (!contractAbi) {\n            throw new Error(\"Missing ABI definition for \".concat(rawAction.account));\n          }\n\n          var contract = getContract(contractAbi);\n\n          if (signer) {\n            // hook into eosjs name decoder and return the signing account if we encounter the placeholder\n            // this is fine because getContract re-creates the initial types each time\n            contract.types.get('name').deserialize = function (buffer) {\n              var name = buffer.getName();\n\n              if (name === PlaceholderName) {\n                return signer.actor;\n              } else if (name === PlaceholderPermission) {\n                return signer.permission;\n              } else {\n                return name;\n              }\n            };\n          }\n\n          var action = Serialize.deserializeAction(contract, rawAction.account, rawAction.name, rawAction.authorization, rawAction.data, _this.textEncoder, _this.textDecoder);\n\n          if (signer) {\n            action.authorization = action.authorization.map(function (auth) {\n              var actor = auth.actor,\n                  permission = auth.permission;\n\n              if (actor === PlaceholderName) {\n                actor = signer.actor;\n              }\n\n              if (permission === PlaceholderPermission) {\n                permission = signer.permission;\n              } // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n\n\n              if (permission === PlaceholderName) {\n                permission = signer.permission;\n              }\n\n              return {\n                actor: actor,\n                permission: permission\n              };\n            });\n          }\n\n          return action;\n        });\n      }\n    }, {\n      key: \"resolveTransaction\",\n      value: function resolveTransaction(abis, signer) {\n        var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var tx = this.getRawTransaction();\n\n        if (!this.isIdentity() && !hasTapos(tx)) {\n          if (ctx.expiration !== undefined && ctx.ref_block_num !== undefined && ctx.ref_block_prefix !== undefined) {\n            tx.expiration = ctx.expiration;\n            tx.ref_block_num = ctx.ref_block_num;\n            tx.ref_block_prefix = ctx.ref_block_prefix;\n          } else if (ctx.block_num !== undefined && ctx.ref_block_prefix !== undefined && ctx.timestamp !== undefined) {\n            var header = Serialize.transactionHeader(ctx, ctx.expire_seconds !== undefined ? ctx.expire_seconds : 60);\n            tx.expiration = header.expiration;\n            tx.ref_block_num = header.ref_block_num;\n            tx.ref_block_prefix = header.ref_block_prefix;\n          } else {\n            throw new Error('Invalid transaction context, need either a reference block or explicit TAPoS values');\n          }\n        }\n\n        var actions = this.resolveActions(abis, signer);\n        return _objectSpread(_objectSpread({}, tx), {}, {\n          actions: actions\n        });\n      }\n    }, {\n      key: \"resolve\",\n      value: function resolve(abis, signer) {\n        var _this2 = this;\n\n        var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var transaction = this.resolveTransaction(abis, signer, ctx);\n        var buf = new Serialize.SerialBuffer({\n          textDecoder: this.textDecoder,\n          textEncoder: this.textEncoder\n        });\n        var actions = transaction.actions.map(function (action) {\n          var contractAbi;\n\n          if (isIdentity(action)) {\n            contractAbi = abi.data;\n          } else {\n            contractAbi = abis.get(action.account);\n          }\n\n          if (!contractAbi) {\n            throw new Error(\"Missing ABI definition for \".concat(action.account));\n          }\n\n          var contract = getContract(contractAbi);\n          var textDecoder = _this2.textDecoder,\n              textEncoder = _this2.textEncoder;\n          return Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder);\n        });\n        SigningRequest.transactionType.serialize(buf, _objectSpread(_objectSpread({}, transaction), {}, {\n          actions: actions\n        }));\n        var serializedTransaction = buf.asUint8Array();\n        return new ResolvedSigningRequest(this, signer, transaction, serializedTransaction);\n      }\n      /**\n       * Get the id of the chain where this request is valid.\n       * @returns The 32-byte chain id as hex encoded string.\n       */\n\n    }, {\n      key: \"getChainId\",\n      value: function getChainId() {\n        var id = this.data.chain_id;\n\n        switch (id[0]) {\n          case 'chain_id':\n            return id[1];\n\n          case 'chain_alias':\n            if (ChainIdLookup.has(id[1])) {\n              return ChainIdLookup.get(id[1]);\n            } else {\n              throw new Error('Unknown chain id alias');\n            }\n\n          default:\n            throw new Error('Invalid signing request data');\n        }\n      }\n      /** Return the actions in this request with action data encoded. */\n\n    }, {\n      key: \"getRawActions\",\n      value: function getRawActions() {\n        var req = this.data.req;\n\n        switch (req[0]) {\n          case 'action':\n            return [req[1]];\n\n          case 'action[]':\n            return req[1];\n\n          case 'identity':\n            var data = '0101000000000000000200000000000000'; // placeholder permission\n\n            var authorization = [PlaceholderAuth];\n\n            if (req[1].permission) {\n              var buf = new Serialize.SerialBuffer({\n                textDecoder: this.textDecoder,\n                textEncoder: this.textEncoder\n              });\n              SigningRequest.idType.serialize(buf, req[1]);\n              data = Serialize.arrayToHex(buf.asUint8Array());\n              authorization = [req[1].permission];\n            }\n\n            return [{\n              account: '',\n              name: 'identity',\n              authorization: authorization,\n              data: data\n            }];\n\n          case 'transaction':\n            return req[1].actions;\n\n          default:\n            throw new Error('Invalid signing request data');\n        }\n      }\n      /** Unresolved transaction. */\n\n    }, {\n      key: \"getRawTransaction\",\n      value: function getRawTransaction() {\n        var req = this.data.req;\n\n        switch (req[0]) {\n          case 'transaction':\n            return req[1];\n\n          case 'action':\n          case 'action[]':\n          case 'identity':\n            return {\n              actions: this.getRawActions(),\n              context_free_actions: [],\n              transaction_extensions: [],\n              expiration: '1970-01-01T00:00:00.000',\n              ref_block_num: 0,\n              ref_block_prefix: 0,\n              max_cpu_usage_ms: 0,\n              max_net_usage_words: 0,\n              delay_sec: 0\n            };\n\n          default:\n            throw new Error('Invalid signing request data');\n        }\n      }\n      /** Whether the request is an identity request. */\n\n    }, {\n      key: \"isIdentity\",\n      value: function isIdentity() {\n        return this.data.req[0] === 'identity';\n      }\n      /** Whether the request should be broadcast by signer. */\n\n    }, {\n      key: \"shouldBroadcast\",\n      value: function shouldBroadcast() {\n        if (this.isIdentity()) {\n          return false;\n        }\n\n        return (this.data.flags & abi.RequestFlagsBroadcast) !== 0;\n      }\n      /**\n       * Present if the request is an identity request and requests a specific account.\n       * @note This returns `nil` unless a specific identity has been requested,\n       *       use `isIdentity` to check id requests.\n       */\n\n    }, {\n      key: \"getIdentity\",\n      value: function getIdentity() {\n        if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n          var actor = this.data.req[1].permission.actor;\n          return actor === PlaceholderName ? null : actor;\n        }\n\n        return null;\n      }\n      /**\n       * Present if the request is an identity request and requests a specific permission.\n       * @note This returns `nil` unless a specific permission has been requested,\n       *       use `isIdentity` to check id requests.\n       */\n\n    }, {\n      key: \"getIdentityPermission\",\n      value: function getIdentityPermission() {\n        if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n          var permission = this.data.req[1].permission.permission;\n          return permission === PlaceholderName ? null : permission;\n        }\n\n        return null;\n      }\n      /** Get raw info dict */\n\n    }, {\n      key: \"getRawInfo\",\n      value: function getRawInfo() {\n        var rv = {};\n\n        var _iterator = _createForOfIteratorHelper(this.data.info),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _step.value,\n                key = _step$value.key,\n                value = _step$value.value;\n            rv[key] = typeof value === 'string' ? Serialize.hexToUint8Array(value) : value;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return rv;\n      }\n      /** Get metadata values as strings. */\n\n    }, {\n      key: \"getInfo\",\n      value: function getInfo() {\n        var rv = {};\n        var raw = this.getRawInfo();\n\n        for (var _i = 0, _Object$keys = Object.keys(raw); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          rv[key] = this.textDecoder.decode(raw[key]);\n        }\n\n        return rv;\n      }\n      /** Set a metadata key. */\n\n    }, {\n      key: \"setInfoKey\",\n      value: function setInfoKey(key, value) {\n        var pair = this.data.info.find(function (pair) {\n          return pair.key === key;\n        });\n        var encodedValue;\n\n        switch (typeof value) {\n          case 'string':\n            encodedValue = this.textEncoder.encode(value);\n            break;\n\n          case 'boolean':\n            encodedValue = new Uint8Array([value ? 1 : 0]);\n            break;\n\n          default:\n            throw new TypeError('Invalid value type, expected string or boolean.');\n        }\n\n        if (!pair) {\n          pair = {\n            key: key,\n            value: encodedValue\n          };\n          this.data.info.push(pair);\n        } else {\n          pair.value = encodedValue;\n        }\n      }\n      /** Return a deep copy of this request. */\n\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        var signature;\n\n        if (this.signature) {\n          signature = JSON.parse(JSON.stringify(this.signature));\n        }\n\n        var data = JSON.stringify(this.data, function (key, value) {\n          if (value instanceof Uint8Array) {\n            return Array.from(value);\n          }\n\n          return value;\n        });\n        return new SigningRequest(this.version, JSON.parse(data), this.textEncoder, this.textDecoder, this.zlib, this.abiProvider, signature);\n      } // Convenience methods.\n\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        return this.encode();\n      }\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return this.encode();\n      }\n    }], [{\n      key: \"create\",\n      value: function () {\n        var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(args) {\n          var options,\n              textEncoder,\n              textDecoder,\n              data,\n              serialize,\n              tx,\n              broadcast,\n              key,\n              value,\n              req,\n              _args3 = arguments;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                  textEncoder = options.textEncoder || new TextEncoder();\n                  textDecoder = options.textDecoder || new TextDecoder();\n                  data = {};\n\n                  serialize = function serialize(action) {\n                    return serializeAction(action, textEncoder, textDecoder, options.abiProvider);\n                  }; // set the request data\n\n\n                  if (!(args.identity !== undefined)) {\n                    _context3.next = 9;\n                    break;\n                  }\n\n                  data.req = ['identity', args.identity];\n                  _context3.next = 47;\n                  break;\n\n                case 9:\n                  if (!(args.action && !args.actions && !args.transaction)) {\n                    _context3.next = 16;\n                    break;\n                  }\n\n                  _context3.next = 12;\n                  return serialize(args.action);\n\n                case 12:\n                  _context3.t0 = _context3.sent;\n                  data.req = ['action', _context3.t0];\n                  _context3.next = 47;\n                  break;\n\n                case 16:\n                  if (!(args.actions && !args.action && !args.transaction)) {\n                    _context3.next = 30;\n                    break;\n                  }\n\n                  if (!(args.actions.length === 1)) {\n                    _context3.next = 24;\n                    break;\n                  }\n\n                  _context3.next = 20;\n                  return serialize(args.actions[0]);\n\n                case 20:\n                  _context3.t1 = _context3.sent;\n                  data.req = ['action', _context3.t1];\n                  _context3.next = 28;\n                  break;\n\n                case 24:\n                  _context3.next = 26;\n                  return Promise.all(args.actions.map(serialize));\n\n                case 26:\n                  _context3.t2 = _context3.sent;\n                  data.req = ['action[]', _context3.t2];\n\n                case 28:\n                  _context3.next = 47;\n                  break;\n\n                case 30:\n                  if (!(args.transaction && !args.action && !args.actions)) {\n                    _context3.next = 46;\n                    break;\n                  }\n\n                  tx = args.transaction; // set default values if missing\n\n                  if (tx.expiration === undefined) {\n                    tx.expiration = '1970-01-01T00:00:00.000';\n                  }\n\n                  if (tx.ref_block_num === undefined) {\n                    tx.ref_block_num = 0;\n                  }\n\n                  if (tx.ref_block_prefix === undefined) {\n                    tx.ref_block_prefix = 0;\n                  }\n\n                  if (tx.context_free_actions === undefined) {\n                    tx.context_free_actions = [];\n                  }\n\n                  if (tx.transaction_extensions === undefined) {\n                    tx.transaction_extensions = [];\n                  }\n\n                  if (tx.delay_sec === undefined) {\n                    tx.delay_sec = 0;\n                  }\n\n                  if (tx.max_cpu_usage_ms === undefined) {\n                    tx.max_cpu_usage_ms = 0;\n                  }\n\n                  if (tx.max_net_usage_words === undefined) {\n                    tx.max_net_usage_words = 0;\n                  } // encode actions if needed\n\n\n                  _context3.next = 42;\n                  return Promise.all(tx.actions.map(serialize));\n\n                case 42:\n                  tx.actions = _context3.sent;\n                  data.req = ['transaction', tx];\n                  _context3.next = 47;\n                  break;\n\n                case 46:\n                  throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n\n                case 47:\n                  // set the chain id\n                  data.chain_id = variantId(args.chainId);\n                  data.flags = abi.RequestFlagsNone;\n                  broadcast = args.broadcast !== undefined ? args.broadcast : true;\n\n                  if (broadcast) {\n                    data.flags |= abi.RequestFlagsBroadcast;\n                  }\n\n                  if (typeof args.callback === 'string') {\n                    data.callback = args.callback;\n                  } else if (typeof args.callback === 'object') {\n                    data.callback = args.callback.url;\n\n                    if (args.callback.background) {\n                      data.flags |= abi.RequestFlagsBackground;\n                    }\n                  } else {\n                    data.callback = '';\n                  }\n\n                  data.info = [];\n\n                  if (!(typeof args.info === 'object')) {\n                    _context3.next = 65;\n                    break;\n                  }\n\n                  _context3.t3 = _regeneratorRuntime.keys(args.info);\n\n                case 55:\n                  if ((_context3.t4 = _context3.t3()).done) {\n                    _context3.next = 65;\n                    break;\n                  }\n\n                  key = _context3.t4.value;\n\n                  if (!args.info.hasOwnProperty(key)) {\n                    _context3.next = 63;\n                    break;\n                  }\n\n                  value = args.info[key];\n\n                  if (!(typeof key !== 'string')) {\n                    _context3.next = 61;\n                    break;\n                  }\n\n                  throw new Error('Invalid info dict, keys must be strings');\n\n                case 61:\n                  if (typeof value === 'string') {\n                    value = textEncoder.encode(value);\n                  }\n\n                  data.info.push({\n                    key: key,\n                    value: value\n                  });\n\n                case 63:\n                  _context3.next = 55;\n                  break;\n\n                case 65:\n                  req = new SigningRequest(ProtocolVersion, data, textEncoder, textDecoder, options.zlib, options.abiProvider); // sign the request if given a signature provider\n\n                  if (options.signatureProvider) {\n                    req.sign(options.signatureProvider);\n                  }\n\n                  return _context3.abrupt(\"return\", req);\n\n                case 68:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        function create(_x3) {\n          return _create.apply(this, arguments);\n        }\n\n        return create;\n      }()\n      /** Creates an identity request. */\n\n    }, {\n      key: \"identity\",\n      value: function identity(args) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var permission = {\n          actor: args.account || PlaceholderName,\n          permission: args.permission || PlaceholderPermission\n        };\n\n        if (permission.actor === PlaceholderName && permission.permission === PlaceholderPermission) {\n          permission = null;\n        }\n\n        return this.create({\n          identity: {\n            permission: permission\n          },\n          broadcast: false,\n          callback: args.callback,\n          info: args.info\n        }, options);\n      }\n      /**\n       * Create a request from a chain id and serialized transaction.\n       * @param chainId The chain id where the transaction is valid.\n       * @param serializedTransaction The serialized transaction.\n       * @param options Creation options.\n       */\n\n    }, {\n      key: \"fromTransaction\",\n      value: function fromTransaction(chainId, serializedTransaction) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        if (typeof chainId !== 'string') {\n          chainId = Serialize.arrayToHex(chainId);\n        }\n\n        if (typeof serializedTransaction === 'string') {\n          serializedTransaction = Serialize.hexToUint8Array(serializedTransaction);\n        }\n\n        var buf = new Serialize.SerialBuffer({\n          textDecoder: options.textDecoder,\n          textEncoder: options.textEncoder\n        });\n        buf.push(2); // header\n\n        var id = variantId(chainId);\n\n        if (id[0] === 'chain_alias') {\n          buf.push(0);\n          buf.push(id[1]);\n        } else {\n          buf.push(1);\n          buf.pushArray(Serialize.hexToUint8Array(id[1]));\n        }\n\n        buf.push(2); // transaction variant\n\n        buf.pushArray(serializedTransaction);\n        buf.push(abi.RequestFlagsBroadcast); // flags\n\n        buf.push(0); // callback\n\n        buf.push(0); // info\n\n        return SigningRequest.fromData(buf.asUint8Array(), options);\n      }\n      /** Creates a signing request from encoded `esr:` uri string. */\n\n    }, {\n      key: \"from\",\n      value: function from(uri) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (typeof uri !== 'string') {\n          throw new Error('Invalid request uri');\n        }\n\n        var _uri$split = uri.split(':'),\n            _uri$split2 = _slicedToArray(_uri$split, 2),\n            scheme = _uri$split2[0],\n            path = _uri$split2[1];\n\n        if (scheme !== 'esr' && scheme !== 'web+esr') {\n          throw new Error('Invalid scheme');\n        }\n\n        var data = base64u.decode(path.startsWith('//') ? path.slice(2) : path);\n        return SigningRequest.fromData(data, options);\n      }\n    }, {\n      key: \"fromData\",\n      value: function fromData(data) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var header = data[0];\n        var version = header & ~(1 << 7);\n\n        if (version !== ProtocolVersion) {\n          throw new Error('Unsupported protocol version');\n        }\n\n        var array = data.slice(1);\n\n        if ((header & 1 << 7) !== 0) {\n          if (!options.zlib) {\n            throw new Error('Compressed URI needs zlib');\n          }\n\n          array = options.zlib.inflateRaw(array);\n        }\n\n        var textEncoder = options.textEncoder || new TextEncoder();\n        var textDecoder = options.textDecoder || new TextDecoder();\n        var buffer = new Serialize.SerialBuffer({\n          textEncoder: textEncoder,\n          textDecoder: textDecoder,\n          array: array\n        });\n        var req = SigningRequest.type.deserialize(buffer);\n        var signature;\n\n        if (buffer.haveReadData()) {\n          var type = AbiTypes.get('request_signature');\n          signature = type.deserialize(buffer);\n        }\n\n        return new SigningRequest(version, req, textEncoder, textDecoder, options.zlib, options.abiProvider, signature);\n      }\n    }]);\n\n    return SigningRequest;\n  }();\n\n  SigningRequest.type = AbiTypes.get('signing_request');\n  SigningRequest.idType = AbiTypes.get('identity');\n  SigningRequest.transactionType = AbiTypes.get('transaction');\n  return SigningRequest;\n}();\n\nexport { SigningRequest };\nexport var ResolvedSigningRequest = /*#__PURE__*/function () {\n  function ResolvedSigningRequest(request, signer, transaction, serializedTransaction) {\n    _classCallCheck(this, ResolvedSigningRequest);\n\n    this.request = request;\n    this.signer = signer;\n    this.transaction = transaction;\n    this.serializedTransaction = serializedTransaction;\n  }\n  /** Recreate a resolved request from a callback payload. */\n\n\n  _createClass(ResolvedSigningRequest, [{\n    key: \"getTransactionId\",\n    value: function getTransactionId() {\n      return Serialize.arrayToHex(sha256(this.serializedTransaction));\n    }\n  }, {\n    key: \"getCallback\",\n    value: function getCallback(signatures, blockNum) {\n      var _this$request$data = this.request.data,\n          callback = _this$request$data.callback,\n          flags = _this$request$data.flags;\n\n      if (!callback || callback.length === 0) {\n        return null;\n      }\n\n      if (!signatures || signatures.length === 0) {\n        throw new Error('Must have at least one signature to resolve callback');\n      }\n\n      var payload = {\n        sig: signatures[0],\n        tx: this.getTransactionId(),\n        rbn: String(this.transaction.ref_block_num),\n        rid: String(this.transaction.ref_block_prefix),\n        ex: this.transaction.expiration,\n        req: this.request.encode(),\n        sa: this.signer.actor,\n        sp: this.signer.permission\n      };\n\n      var _iterator2 = _createForOfIteratorHelper(signatures.slice(1).entries()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              n = _step2$value[0],\n              sig = _step2$value[1];\n\n          payload[\"sig\".concat(n)] = sig;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (blockNum) {\n        payload.bn = String(blockNum);\n      }\n\n      var url = callback.replace(/({{([a-z0-9]+)}})/g, function (_1, _2, m) {\n        return payload[m] || '';\n      });\n      return {\n        background: (flags & abi.RequestFlagsBackground) !== 0,\n        payload: payload,\n        url: url\n      };\n    }\n  }], [{\n    key: \"fromPayload\",\n    value: function () {\n      var _fromPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(payload) {\n        var options,\n            request,\n            abis,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                request = SigningRequest.from(payload.req, options);\n                _context4.next = 4;\n                return request.fetchAbis();\n\n              case 4:\n                abis = _context4.sent;\n                return _context4.abrupt(\"return\", request.resolve(abis, {\n                  actor: payload.sa,\n                  permission: payload.sp\n                }, {\n                  ref_block_num: Number(payload.rbn),\n                  ref_block_prefix: Number(payload.rid),\n                  expiration: payload.ex\n                }));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function fromPayload(_x4) {\n        return _fromPayload.apply(this, arguments);\n      }\n\n      return fromPayload;\n    }()\n  }]);\n\n  return ResolvedSigningRequest;\n}();\n/** Internal helper that creates a contract representation from an abi for the eosjs serializer. */\n\nfunction getContract(contractAbi) {\n  var types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), contractAbi);\n  var actions = new Map();\n\n  var _iterator3 = _createForOfIteratorHelper(contractAbi.actions),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _step3.value,\n          name = _step3$value.name,\n          type = _step3$value.type;\n      actions.set(name, Serialize.getType(types, type));\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return {\n    types: types,\n    actions: actions\n  };\n}\n\nfunction serializeAction(_x5, _x6, _x7, _x8) {\n  return _serializeAction.apply(this, arguments);\n}\n\nfunction _serializeAction() {\n  _serializeAction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(action, textEncoder, textDecoder, abiProvider) {\n    var contractAbi, contract;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!(typeof action.data === 'string')) {\n              _context5.next = 2;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", action);\n\n          case 2:\n            if (!isIdentity(action)) {\n              _context5.next = 6;\n              break;\n            }\n\n            contractAbi = abi.data;\n            _context5.next = 13;\n            break;\n\n          case 6:\n            if (!abiProvider) {\n              _context5.next = 12;\n              break;\n            }\n\n            _context5.next = 9;\n            return abiProvider.getAbi(action.account);\n\n          case 9:\n            contractAbi = _context5.sent;\n            _context5.next = 13;\n            break;\n\n          case 12:\n            throw new Error('Missing abi provider');\n\n          case 13:\n            contract = getContract(contractAbi);\n            return _context5.abrupt(\"return\", Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder));\n\n          case 15:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _serializeAction.apply(this, arguments);\n}\n\nfunction variantId(chainId) {\n  if (!chainId) {\n    chainId = ChainName.EOS;\n  }\n\n  if (typeof chainId === 'number') {\n    return ['chain_alias', chainId];\n  } else {\n    // resolve known chain id's to their aliases\n    var name = idToName(chainId);\n\n    if (name !== ChainName.UNKNOWN) {\n      return ['chain_alias', name];\n    }\n\n    return ['chain_id', chainId];\n  }\n}\n\nfunction isIdentity(action) {\n  return action.account === '' && action.name === 'identity';\n}\n\nfunction hasTapos(tx) {\n  return !(tx.expiration === '1970-01-01T00:00:00.000' && tx.ref_block_num === 0 && tx.ref_block_prefix === 0);\n}\n/** Resolve a chain id to a chain name alias, returns UNKNOWN (0x00) if the chain id has no alias. */\n\n\nexport function idToName(chainId) {\n  chainId = chainId.toLowerCase();\n\n  var _iterator4 = _createForOfIteratorHelper(ChainIdLookup),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n          n = _step4$value[0],\n          id = _step4$value[1];\n\n      if (id === chainId) {\n        n;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return ChainName.UNKNOWN;\n}\n/** Resolve a chain name alias to a chain id. */\n\nexport function nameToId(chainName) {\n  return ChainIdLookup.get(chainName) || '0000000000000000000000000000000000000000000000000000000000000000';\n}","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosio-signing-request/lib/signing-request.js"],"names":["Serialize","sha256","abi","base64u","ProtocolVersion","AbiTypes","getTypesFromAbi","createInitialTypes","data","ChainName","ChainIdLookup","Map","EOS","TELOS","JUNGLE","KYLIN","WORBLI","BOS","MEETONE","INSIGHTS","BEOS","WAX","PROTON","FIO","PlaceholderName","PlaceholderPermission","PlaceholderAuth","actor","permission","SigningRequest","version","textEncoder","textDecoder","zlib","abiProvider","signature","flags","RequestFlagsBroadcast","req","Error","callback","length","signatureProvider","message","getSignatureDigest","sign","arrayToHex","buffer","SerialBuffer","pushArray","getData","asUint8Array","signer","url","background","RequestFlagsBackground","broadcast","compress","slashes","shouldCompress","undefined","header","sigData","getSignatureData","array","Uint8Array","byteLength","set","deflated","deflateRaw","out","scheme","encode","type","serialize","get","getRawActions","filter","action","isIdentity","map","account","value","index","self","indexOf","tx","getRawTransaction","hasTapos","provider","abis","Promise","all","getRequiredAbis","getAbi","rawAction","contractAbi","contract","getContract","types","deserialize","name","getName","deserializeAction","authorization","auth","ctx","expiration","ref_block_num","ref_block_prefix","block_num","timestamp","transactionHeader","expire_seconds","actions","resolveActions","transaction","resolveTransaction","buf","serializeAction","transactionType","serializedTransaction","ResolvedSigningRequest","id","chain_id","has","idType","context_free_actions","transaction_extensions","max_cpu_usage_ms","max_net_usage_words","delay_sec","rv","info","key","hexToUint8Array","raw","getRawInfo","Object","keys","decode","pair","find","encodedValue","TypeError","push","JSON","parse","stringify","Array","from","args","options","TextEncoder","TextDecoder","identity","variantId","chainId","RequestFlagsNone","hasOwnProperty","create","fromData","uri","split","path","startsWith","slice","inflateRaw","haveReadData","request","signatures","blockNum","payload","sig","getTransactionId","rbn","String","rid","ex","sa","sp","entries","n","bn","replace","_1","_2","m","fetchAbis","resolve","Number","getType","idToName","UNKNOWN","toLowerCase","nameToId","chainName"],"mappings":"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","sourcesContent":["/**\n * EOSIO Signing Request (ESR).\n */\nimport { Serialize } from 'eosjs';\nimport sha256 from 'fast-sha256';\nimport * as abi from './abi';\nimport * as base64u from './base64u';\nconst ProtocolVersion = 2;\nconst AbiTypes = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), abi.data);\n/** Chain ID aliases. */\nexport var ChainName;\n(function (ChainName) {\n    ChainName[ChainName[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    ChainName[ChainName[\"EOS\"] = 1] = \"EOS\";\n    ChainName[ChainName[\"TELOS\"] = 2] = \"TELOS\";\n    ChainName[ChainName[\"JUNGLE\"] = 3] = \"JUNGLE\";\n    ChainName[ChainName[\"KYLIN\"] = 4] = \"KYLIN\";\n    ChainName[ChainName[\"WORBLI\"] = 5] = \"WORBLI\";\n    ChainName[ChainName[\"BOS\"] = 6] = \"BOS\";\n    ChainName[ChainName[\"MEETONE\"] = 7] = \"MEETONE\";\n    ChainName[ChainName[\"INSIGHTS\"] = 8] = \"INSIGHTS\";\n    ChainName[ChainName[\"BEOS\"] = 9] = \"BEOS\";\n    ChainName[ChainName[\"WAX\"] = 10] = \"WAX\";\n    ChainName[ChainName[\"PROTON\"] = 11] = \"PROTON\";\n    ChainName[ChainName[\"FIO\"] = 12] = \"FIO\";\n})(ChainName || (ChainName = {}));\nconst ChainIdLookup = new Map([\n    [ChainName.EOS, 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'],\n    [ChainName.TELOS, '4667b205c6838ef70ff7988f6e8257e8be0e1284a2f59699054a018f743b1d11'],\n    [ChainName.JUNGLE, 'e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473'],\n    [ChainName.KYLIN, '5fff1dae8dc8e2fc4d5b23b2c7665c97f9e9d8edf2b6485a86ba311c25639191'],\n    [ChainName.WORBLI, '73647cde120091e0a4b85bced2f3cfdb3041e266cbbe95cee59b73235a1b3b6f'],\n    [ChainName.BOS, 'd5a3d18fbb3c084e3b1f3fa98c21014b5f3db536cc15d08f9f6479517c6a3d86'],\n    [ChainName.MEETONE, 'cfe6486a83bad4962f232d48003b1824ab5665c36778141034d75e57b956e422'],\n    [ChainName.INSIGHTS, 'b042025541e25a472bffde2d62edd457b7e70cee943412b1ea0f044f88591664'],\n    [ChainName.BEOS, 'b912d19a6abd2b1b05611ae5be473355d64d95aeff0c09bedc8c166cd6468fe4'],\n    [ChainName.WAX, '1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4'],\n    [ChainName.PROTON, '384da888112027f0321850a169f737c33e53b388aad48b5adace4bab97f437e0'],\n    [ChainName.FIO, '21dcae42c0182200e93f954a074011f9048a7624c6fe81d3c9541a614a88bd1c'],\n]);\n/**\n * The placeholder name: `............1` aka `uint64(1)`.\n * If used in action data will be resolved to current signer.\n * If used in as an authorization permission will be resolved to\n * the signers permission level.\n *\n * Example action:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"............1\", permission: \"............1\"}],\n *   data: {\n *     from: \"............1\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n * When signed by `foo@active` would resolve to:\n * ```\n * { account: \"eosio.token\",\n *   name: \"transfer\",\n *   authorization: [{actor: \"foo\", permission: \"active\"}],\n *   data: {\n *     from: \"foo\",\n *     to: \"bar\",\n *     quantity: \"42.0000 EOS\",\n *     memo: \"Don't panic\" }}\n * ```\n */\nexport const PlaceholderName = '............1'; // aka uint64(1)\n/** Placeholder that will resolve to signer permission name. */\nexport const PlaceholderPermission = '............2'; // aka uint64(2)\nexport const PlaceholderAuth = {\n    actor: PlaceholderName,\n    permission: PlaceholderPermission,\n};\nlet SigningRequest = /** @class */ (() => {\n    class SigningRequest {\n        /**\n         * Create a new signing request.\n         * Normally not used directly, see the `create` and `from` class methods.\n         */\n        constructor(version, data, textEncoder, textDecoder, zlib, abiProvider, signature) {\n            if ((data.flags & abi.RequestFlagsBroadcast) !== 0 && data.req[0] === 'identity') {\n                throw new Error('Invalid request (identity request cannot be broadcast)');\n            }\n            if ((data.flags & abi.RequestFlagsBroadcast) === 0 && data.callback.length === 0) {\n                throw new Error('Invalid request (nothing to do, no broadcast or callback set)');\n            }\n            this.version = version;\n            this.data = data;\n            this.textEncoder = textEncoder;\n            this.textDecoder = textDecoder;\n            this.zlib = zlib;\n            this.abiProvider = abiProvider;\n            this.signature = signature;\n        }\n        /** Create a new signing request. */\n        static async create(args, options = {}) {\n            const textEncoder = options.textEncoder || new TextEncoder();\n            const textDecoder = options.textDecoder || new TextDecoder();\n            const data = {};\n            const serialize = (action) => {\n                return serializeAction(action, textEncoder, textDecoder, options.abiProvider);\n            };\n            // set the request data\n            if (args.identity !== undefined) {\n                data.req = ['identity', args.identity];\n            }\n            else if (args.action && !args.actions && !args.transaction) {\n                data.req = ['action', await serialize(args.action)];\n            }\n            else if (args.actions && !args.action && !args.transaction) {\n                if (args.actions.length === 1) {\n                    data.req = ['action', await serialize(args.actions[0])];\n                }\n                else {\n                    data.req = ['action[]', await Promise.all(args.actions.map(serialize))];\n                }\n            }\n            else if (args.transaction && !args.action && !args.actions) {\n                const tx = args.transaction;\n                // set default values if missing\n                if (tx.expiration === undefined) {\n                    tx.expiration = '1970-01-01T00:00:00.000';\n                }\n                if (tx.ref_block_num === undefined) {\n                    tx.ref_block_num = 0;\n                }\n                if (tx.ref_block_prefix === undefined) {\n                    tx.ref_block_prefix = 0;\n                }\n                if (tx.context_free_actions === undefined) {\n                    tx.context_free_actions = [];\n                }\n                if (tx.transaction_extensions === undefined) {\n                    tx.transaction_extensions = [];\n                }\n                if (tx.delay_sec === undefined) {\n                    tx.delay_sec = 0;\n                }\n                if (tx.max_cpu_usage_ms === undefined) {\n                    tx.max_cpu_usage_ms = 0;\n                }\n                if (tx.max_net_usage_words === undefined) {\n                    tx.max_net_usage_words = 0;\n                }\n                // encode actions if needed\n                tx.actions = await Promise.all(tx.actions.map(serialize));\n                data.req = ['transaction', tx];\n            }\n            else {\n                throw new TypeError('Invalid arguments: Must have exactly one of action, actions or transaction');\n            }\n            // set the chain id\n            data.chain_id = variantId(args.chainId);\n            data.flags = abi.RequestFlagsNone;\n            const broadcast = args.broadcast !== undefined ? args.broadcast : true;\n            if (broadcast) {\n                data.flags |= abi.RequestFlagsBroadcast;\n            }\n            if (typeof args.callback === 'string') {\n                data.callback = args.callback;\n            }\n            else if (typeof args.callback === 'object') {\n                data.callback = args.callback.url;\n                if (args.callback.background) {\n                    data.flags |= abi.RequestFlagsBackground;\n                }\n            }\n            else {\n                data.callback = '';\n            }\n            data.info = [];\n            if (typeof args.info === 'object') {\n                for (const key in args.info) {\n                    if (args.info.hasOwnProperty(key)) {\n                        let value = args.info[key];\n                        if (typeof key !== 'string') {\n                            throw new Error('Invalid info dict, keys must be strings');\n                        }\n                        if (typeof value === 'string') {\n                            value = textEncoder.encode(value);\n                        }\n                        data.info.push({ key, value });\n                    }\n                }\n            }\n            const req = new SigningRequest(ProtocolVersion, data, textEncoder, textDecoder, options.zlib, options.abiProvider);\n            // sign the request if given a signature provider\n            if (options.signatureProvider) {\n                req.sign(options.signatureProvider);\n            }\n            return req;\n        }\n        /** Creates an identity request. */\n        static identity(args, options = {}) {\n            let permission = {\n                actor: args.account || PlaceholderName,\n                permission: args.permission || PlaceholderPermission,\n            };\n            if (permission.actor === PlaceholderName &&\n                permission.permission === PlaceholderPermission) {\n                permission = null;\n            }\n            return this.create({\n                identity: {\n                    permission,\n                },\n                broadcast: false,\n                callback: args.callback,\n                info: args.info,\n            }, options);\n        }\n        /**\n         * Create a request from a chain id and serialized transaction.\n         * @param chainId The chain id where the transaction is valid.\n         * @param serializedTransaction The serialized transaction.\n         * @param options Creation options.\n         */\n        static fromTransaction(chainId, serializedTransaction, options = {}) {\n            if (typeof chainId !== 'string') {\n                chainId = Serialize.arrayToHex(chainId);\n            }\n            if (typeof serializedTransaction === 'string') {\n                serializedTransaction = Serialize.hexToUint8Array(serializedTransaction);\n            }\n            let buf = new Serialize.SerialBuffer({\n                textDecoder: options.textDecoder,\n                textEncoder: options.textEncoder,\n            });\n            buf.push(2); // header\n            const id = variantId(chainId);\n            if (id[0] === 'chain_alias') {\n                buf.push(0);\n                buf.push(id[1]);\n            }\n            else {\n                buf.push(1);\n                buf.pushArray(Serialize.hexToUint8Array(id[1]));\n            }\n            buf.push(2); // transaction variant\n            buf.pushArray(serializedTransaction);\n            buf.push(abi.RequestFlagsBroadcast); // flags\n            buf.push(0); // callback\n            buf.push(0); // info\n            return SigningRequest.fromData(buf.asUint8Array(), options);\n        }\n        /** Creates a signing request from encoded `esr:` uri string. */\n        static from(uri, options = {}) {\n            if (typeof uri !== 'string') {\n                throw new Error('Invalid request uri');\n            }\n            const [scheme, path] = uri.split(':');\n            if (scheme !== 'esr' && scheme !== 'web+esr') {\n                throw new Error('Invalid scheme');\n            }\n            const data = base64u.decode(path.startsWith('//') ? path.slice(2) : path);\n            return SigningRequest.fromData(data, options);\n        }\n        static fromData(data, options = {}) {\n            const header = data[0];\n            const version = header & ~(1 << 7);\n            if (version !== ProtocolVersion) {\n                throw new Error('Unsupported protocol version');\n            }\n            let array = data.slice(1);\n            if ((header & (1 << 7)) !== 0) {\n                if (!options.zlib) {\n                    throw new Error('Compressed URI needs zlib');\n                }\n                array = options.zlib.inflateRaw(array);\n            }\n            const textEncoder = options.textEncoder || new TextEncoder();\n            const textDecoder = options.textDecoder || new TextDecoder();\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder,\n                textDecoder,\n                array,\n            });\n            const req = SigningRequest.type.deserialize(buffer);\n            let signature;\n            if (buffer.haveReadData()) {\n                const type = AbiTypes.get('request_signature');\n                signature = type.deserialize(buffer);\n            }\n            return new SigningRequest(version, req, textEncoder, textDecoder, options.zlib, options.abiProvider, signature);\n        }\n        /**\n         * Sign the request, mutating.\n         * @param signatureProvider The signature provider that provides a signature for the signer.\n         */\n        sign(signatureProvider) {\n            const message = this.getSignatureDigest();\n            this.signature = signatureProvider.sign(Serialize.arrayToHex(message));\n        }\n        /**\n         * Get the signature digest for this request.\n         */\n        getSignatureDigest() {\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder: this.textEncoder,\n                textDecoder: this.textDecoder,\n            });\n            // protocol version + utf8 \"request\"\n            buffer.pushArray([this.version, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74]);\n            buffer.pushArray(this.getData());\n            return sha256(buffer.asUint8Array());\n        }\n        /**\n         * Set the signature data for this request, mutating.\n         * @param signer Account name of signer.\n         * @param signature The signature string.\n         */\n        setSignature(signer, signature) {\n            this.signature = { signer, signature };\n        }\n        /**\n         * Set the request callback, mutating.\n         * @param url Where the callback should be sent.\n         * @param background Whether the callback should be sent in the background.\n         */\n        setCallback(url, background) {\n            this.data.callback = url;\n            if (background) {\n                this.data.flags |= abi.RequestFlagsBackground;\n            }\n            else {\n                this.data.flags &= ~abi.RequestFlagsBackground;\n            }\n        }\n        /**\n         * Set broadcast flag.\n         * @param broadcast Whether the transaction should be broadcast by receiver.\n         */\n        setBroadcast(broadcast) {\n            if (broadcast) {\n                this.data.flags |= abi.RequestFlagsBroadcast;\n            }\n            else {\n                this.data.flags &= ~abi.RequestFlagsBroadcast;\n            }\n        }\n        /**\n         * Encode this request into an `esr:` uri.\n         * @argument compress Whether to compress the request data using zlib,\n         *                    defaults to true if omitted and zlib is present;\n         *                    otherwise false.\n         * @argument slashes Whether add slashes after the protocol scheme, i.e. `esr://`.\n         *                   Defaults to true.\n         * @returns An esr uri string.\n         */\n        encode(compress, slashes) {\n            const shouldCompress = compress !== undefined ? compress : this.zlib !== undefined;\n            if (shouldCompress && this.zlib === undefined) {\n                throw new Error('Need zlib to compress');\n            }\n            let header = this.version;\n            const data = this.getData();\n            const sigData = this.getSignatureData();\n            let array = new Uint8Array(data.byteLength + sigData.byteLength);\n            array.set(data, 0);\n            array.set(sigData, data.byteLength);\n            if (shouldCompress) {\n                const deflated = this.zlib.deflateRaw(array);\n                if (array.byteLength > deflated.byteLength) {\n                    header |= 1 << 7;\n                    array = deflated;\n                }\n            }\n            const out = new Uint8Array(1 + array.byteLength);\n            out[0] = header;\n            out.set(array, 1);\n            let scheme = 'esr:';\n            if (slashes !== false) {\n                scheme += '//';\n            }\n            return scheme + base64u.encode(out);\n        }\n        /** Get the request data without header or signature. */\n        getData() {\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder: this.textEncoder,\n                textDecoder: this.textDecoder,\n            });\n            SigningRequest.type.serialize(buffer, this.data);\n            return buffer.asUint8Array();\n        }\n        /** Get signature data, returns an empty array if request is not signed. */\n        getSignatureData() {\n            if (!this.signature) {\n                return new Uint8Array(0);\n            }\n            const buffer = new Serialize.SerialBuffer({\n                textEncoder: this.textEncoder,\n                textDecoder: this.textDecoder,\n            });\n            const type = AbiTypes.get('request_signature');\n            type.serialize(buffer, this.signature);\n            return buffer.asUint8Array();\n        }\n        /** ABI definitions required to resolve request. */\n        getRequiredAbis() {\n            return this.getRawActions()\n                .filter((action) => !isIdentity(action))\n                .map((action) => action.account)\n                .filter((value, index, self) => self.indexOf(value) === index);\n        }\n        /** Whether TaPoS values are required to resolve request. */\n        requiresTapos() {\n            let tx = this.getRawTransaction();\n            return !this.isIdentity() && !hasTapos(tx);\n        }\n        /** Resolve required ABI definitions. */\n        async fetchAbis(abiProvider) {\n            const provider = abiProvider || this.abiProvider;\n            if (!provider) {\n                throw new Error('Missing ABI provider');\n            }\n            const abis = new Map();\n            await Promise.all(this.getRequiredAbis().map(async (account) => {\n                abis.set(account, await provider.getAbi(account));\n            }));\n            return abis;\n        }\n        /**\n         * Decode raw actions actions to object representations.\n         * @param abis ABI defenitions required to decode all actions.\n         * @param signer Placeholders in actions will be resolved to signer if set.\n         */\n        resolveActions(abis, signer) {\n            return this.getRawActions().map((rawAction) => {\n                let contractAbi;\n                if (isIdentity(rawAction)) {\n                    contractAbi = abi.data;\n                }\n                else {\n                    contractAbi = abis.get(rawAction.account);\n                }\n                if (!contractAbi) {\n                    throw new Error(`Missing ABI definition for ${rawAction.account}`);\n                }\n                const contract = getContract(contractAbi);\n                if (signer) {\n                    // hook into eosjs name decoder and return the signing account if we encounter the placeholder\n                    // this is fine because getContract re-creates the initial types each time\n                    contract.types.get('name').deserialize = (buffer) => {\n                        const name = buffer.getName();\n                        if (name === PlaceholderName) {\n                            return signer.actor;\n                        }\n                        else if (name === PlaceholderPermission) {\n                            return signer.permission;\n                        }\n                        else {\n                            return name;\n                        }\n                    };\n                }\n                const action = Serialize.deserializeAction(contract, rawAction.account, rawAction.name, rawAction.authorization, rawAction.data, this.textEncoder, this.textDecoder);\n                if (signer) {\n                    action.authorization = action.authorization.map((auth) => {\n                        let { actor, permission } = auth;\n                        if (actor === PlaceholderName) {\n                            actor = signer.actor;\n                        }\n                        if (permission === PlaceholderPermission) {\n                            permission = signer.permission;\n                        }\n                        // backwards compatibility, actor placeholder will also resolve to permission when used in auth\n                        if (permission === PlaceholderName) {\n                            permission = signer.permission;\n                        }\n                        return { actor, permission };\n                    });\n                }\n                return action;\n            });\n        }\n        resolveTransaction(abis, signer, ctx = {}) {\n            let tx = this.getRawTransaction();\n            if (!this.isIdentity() && !hasTapos(tx)) {\n                if (ctx.expiration !== undefined &&\n                    ctx.ref_block_num !== undefined &&\n                    ctx.ref_block_prefix !== undefined) {\n                    tx.expiration = ctx.expiration;\n                    tx.ref_block_num = ctx.ref_block_num;\n                    tx.ref_block_prefix = ctx.ref_block_prefix;\n                }\n                else if (ctx.block_num !== undefined &&\n                    ctx.ref_block_prefix !== undefined &&\n                    ctx.timestamp !== undefined) {\n                    const header = Serialize.transactionHeader(ctx, ctx.expire_seconds !== undefined ? ctx.expire_seconds : 60);\n                    tx.expiration = header.expiration;\n                    tx.ref_block_num = header.ref_block_num;\n                    tx.ref_block_prefix = header.ref_block_prefix;\n                }\n                else {\n                    throw new Error('Invalid transaction context, need either a reference block or explicit TAPoS values');\n                }\n            }\n            const actions = this.resolveActions(abis, signer);\n            return { ...tx, actions };\n        }\n        resolve(abis, signer, ctx = {}) {\n            const transaction = this.resolveTransaction(abis, signer, ctx);\n            const buf = new Serialize.SerialBuffer({\n                textDecoder: this.textDecoder,\n                textEncoder: this.textEncoder,\n            });\n            const actions = transaction.actions.map((action) => {\n                let contractAbi;\n                if (isIdentity(action)) {\n                    contractAbi = abi.data;\n                }\n                else {\n                    contractAbi = abis.get(action.account);\n                }\n                if (!contractAbi) {\n                    throw new Error(`Missing ABI definition for ${action.account}`);\n                }\n                const contract = getContract(contractAbi);\n                const { textDecoder, textEncoder } = this;\n                return Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder);\n            });\n            SigningRequest.transactionType.serialize(buf, {\n                ...transaction,\n                actions,\n            });\n            const serializedTransaction = buf.asUint8Array();\n            return new ResolvedSigningRequest(this, signer, transaction, serializedTransaction);\n        }\n        /**\n         * Get the id of the chain where this request is valid.\n         * @returns The 32-byte chain id as hex encoded string.\n         */\n        getChainId() {\n            const id = this.data.chain_id;\n            switch (id[0]) {\n                case 'chain_id':\n                    return id[1];\n                case 'chain_alias':\n                    if (ChainIdLookup.has(id[1])) {\n                        return ChainIdLookup.get(id[1]);\n                    }\n                    else {\n                        throw new Error('Unknown chain id alias');\n                    }\n                default:\n                    throw new Error('Invalid signing request data');\n            }\n        }\n        /** Return the actions in this request with action data encoded. */\n        getRawActions() {\n            const req = this.data.req;\n            switch (req[0]) {\n                case 'action':\n                    return [req[1]];\n                case 'action[]':\n                    return req[1];\n                case 'identity':\n                    let data = '0101000000000000000200000000000000'; // placeholder permission\n                    let authorization = [PlaceholderAuth];\n                    if (req[1].permission) {\n                        let buf = new Serialize.SerialBuffer({\n                            textDecoder: this.textDecoder,\n                            textEncoder: this.textEncoder,\n                        });\n                        SigningRequest.idType.serialize(buf, req[1]);\n                        data = Serialize.arrayToHex(buf.asUint8Array());\n                        authorization = [req[1].permission];\n                    }\n                    return [\n                        {\n                            account: '',\n                            name: 'identity',\n                            authorization,\n                            data,\n                        },\n                    ];\n                case 'transaction':\n                    return req[1].actions;\n                default:\n                    throw new Error('Invalid signing request data');\n            }\n        }\n        /** Unresolved transaction. */\n        getRawTransaction() {\n            const req = this.data.req;\n            switch (req[0]) {\n                case 'transaction':\n                    return req[1];\n                case 'action':\n                case 'action[]':\n                case 'identity':\n                    return {\n                        actions: this.getRawActions(),\n                        context_free_actions: [],\n                        transaction_extensions: [],\n                        expiration: '1970-01-01T00:00:00.000',\n                        ref_block_num: 0,\n                        ref_block_prefix: 0,\n                        max_cpu_usage_ms: 0,\n                        max_net_usage_words: 0,\n                        delay_sec: 0,\n                    };\n                default:\n                    throw new Error('Invalid signing request data');\n            }\n        }\n        /** Whether the request is an identity request. */\n        isIdentity() {\n            return this.data.req[0] === 'identity';\n        }\n        /** Whether the request should be broadcast by signer. */\n        shouldBroadcast() {\n            if (this.isIdentity()) {\n                return false;\n            }\n            return (this.data.flags & abi.RequestFlagsBroadcast) !== 0;\n        }\n        /**\n         * Present if the request is an identity request and requests a specific account.\n         * @note This returns `nil` unless a specific identity has been requested,\n         *       use `isIdentity` to check id requests.\n         */\n        getIdentity() {\n            if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n                const { actor } = this.data.req[1].permission;\n                return actor === PlaceholderName ? null : actor;\n            }\n            return null;\n        }\n        /**\n         * Present if the request is an identity request and requests a specific permission.\n         * @note This returns `nil` unless a specific permission has been requested,\n         *       use `isIdentity` to check id requests.\n         */\n        getIdentityPermission() {\n            if (this.data.req[0] === 'identity' && this.data.req[1].permission) {\n                const { permission } = this.data.req[1].permission;\n                return permission === PlaceholderName ? null : permission;\n            }\n            return null;\n        }\n        /** Get raw info dict */\n        getRawInfo() {\n            let rv = {};\n            for (const { key, value } of this.data.info) {\n                rv[key] = typeof value === 'string' ? Serialize.hexToUint8Array(value) : value;\n            }\n            return rv;\n        }\n        /** Get metadata values as strings. */\n        getInfo() {\n            let rv = {};\n            let raw = this.getRawInfo();\n            for (const key of Object.keys(raw)) {\n                rv[key] = this.textDecoder.decode(raw[key]);\n            }\n            return rv;\n        }\n        /** Set a metadata key. */\n        setInfoKey(key, value) {\n            let pair = this.data.info.find((pair) => {\n                return pair.key === key;\n            });\n            let encodedValue;\n            switch (typeof value) {\n                case 'string':\n                    encodedValue = this.textEncoder.encode(value);\n                    break;\n                case 'boolean':\n                    encodedValue = new Uint8Array([value ? 1 : 0]);\n                    break;\n                default:\n                    throw new TypeError('Invalid value type, expected string or boolean.');\n            }\n            if (!pair) {\n                pair = { key, value: encodedValue };\n                this.data.info.push(pair);\n            }\n            else {\n                pair.value = encodedValue;\n            }\n        }\n        /** Return a deep copy of this request. */\n        clone() {\n            let signature;\n            if (this.signature) {\n                signature = JSON.parse(JSON.stringify(this.signature));\n            }\n            const data = JSON.stringify(this.data, (key, value) => {\n                if (value instanceof Uint8Array) {\n                    return Array.from(value);\n                }\n                return value;\n            });\n            return new SigningRequest(this.version, JSON.parse(data), this.textEncoder, this.textDecoder, this.zlib, this.abiProvider, signature);\n        }\n        // Convenience methods.\n        toString() {\n            return this.encode();\n        }\n        toJSON() {\n            return this.encode();\n        }\n    }\n    SigningRequest.type = AbiTypes.get('signing_request');\n    SigningRequest.idType = AbiTypes.get('identity');\n    SigningRequest.transactionType = AbiTypes.get('transaction');\n    return SigningRequest;\n})();\nexport { SigningRequest };\nexport class ResolvedSigningRequest {\n    constructor(request, signer, transaction, serializedTransaction) {\n        this.request = request;\n        this.signer = signer;\n        this.transaction = transaction;\n        this.serializedTransaction = serializedTransaction;\n    }\n    /** Recreate a resolved request from a callback payload. */\n    static async fromPayload(payload, options = {}) {\n        const request = SigningRequest.from(payload.req, options);\n        const abis = await request.fetchAbis();\n        return request.resolve(abis, { actor: payload.sa, permission: payload.sp }, {\n            ref_block_num: Number(payload.rbn),\n            ref_block_prefix: Number(payload.rid),\n            expiration: payload.ex,\n        });\n    }\n    getTransactionId() {\n        return Serialize.arrayToHex(sha256(this.serializedTransaction));\n    }\n    getCallback(signatures, blockNum) {\n        const { callback, flags } = this.request.data;\n        if (!callback || callback.length === 0) {\n            return null;\n        }\n        if (!signatures || signatures.length === 0) {\n            throw new Error('Must have at least one signature to resolve callback');\n        }\n        const payload = {\n            sig: signatures[0],\n            tx: this.getTransactionId(),\n            rbn: String(this.transaction.ref_block_num),\n            rid: String(this.transaction.ref_block_prefix),\n            ex: this.transaction.expiration,\n            req: this.request.encode(),\n            sa: this.signer.actor,\n            sp: this.signer.permission,\n        };\n        for (const [n, sig] of signatures.slice(1).entries()) {\n            payload[`sig${n}`] = sig;\n        }\n        if (blockNum) {\n            payload.bn = String(blockNum);\n        }\n        const url = callback.replace(/({{([a-z0-9]+)}})/g, (_1, _2, m) => {\n            return payload[m] || '';\n        });\n        return {\n            background: (flags & abi.RequestFlagsBackground) !== 0,\n            payload,\n            url,\n        };\n    }\n}\n/** Internal helper that creates a contract representation from an abi for the eosjs serializer. */\nfunction getContract(contractAbi) {\n    const types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), contractAbi);\n    const actions = new Map();\n    for (const { name, type } of contractAbi.actions) {\n        actions.set(name, Serialize.getType(types, type));\n    }\n    return { types, actions };\n}\nasync function serializeAction(action, textEncoder, textDecoder, abiProvider) {\n    if (typeof action.data === 'string') {\n        return action;\n    }\n    let contractAbi;\n    if (isIdentity(action)) {\n        contractAbi = abi.data;\n    }\n    else if (abiProvider) {\n        contractAbi = await abiProvider.getAbi(action.account);\n    }\n    else {\n        throw new Error('Missing abi provider');\n    }\n    const contract = getContract(contractAbi);\n    return Serialize.serializeAction(contract, action.account, action.name, action.authorization, action.data, textEncoder, textDecoder);\n}\nfunction variantId(chainId) {\n    if (!chainId) {\n        chainId = ChainName.EOS;\n    }\n    if (typeof chainId === 'number') {\n        return ['chain_alias', chainId];\n    }\n    else {\n        // resolve known chain id's to their aliases\n        const name = idToName(chainId);\n        if (name !== ChainName.UNKNOWN) {\n            return ['chain_alias', name];\n        }\n        return ['chain_id', chainId];\n    }\n}\nfunction isIdentity(action) {\n    return action.account === '' && action.name === 'identity';\n}\nfunction hasTapos(tx) {\n    return !(tx.expiration === '1970-01-01T00:00:00.000' &&\n        tx.ref_block_num === 0 &&\n        tx.ref_block_prefix === 0);\n}\n/** Resolve a chain id to a chain name alias, returns UNKNOWN (0x00) if the chain id has no alias. */\nexport function idToName(chainId) {\n    chainId = chainId.toLowerCase();\n    for (const [n, id] of ChainIdLookup) {\n        if (id === chainId) {\n            n;\n        }\n    }\n    return ChainName.UNKNOWN;\n}\n/** Resolve a chain name alias to a chain id. */\nexport function nameToId(chainName) {\n    return (ChainIdLookup.get(chainName) ||\n        '0000000000000000000000000000000000000000000000000000000000000000');\n}\n"]},"metadata":{},"sourceType":"module"}