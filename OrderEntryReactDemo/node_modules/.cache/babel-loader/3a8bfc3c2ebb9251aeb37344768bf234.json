{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar assert = require('assert');\n\nvar ecurve = require('ecurve');\n\nvar BigInteger = require('bigi');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar hash = require('./hash');\n\nvar keyUtils = require('./key_utils');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nmodule.exports = PublicKey;\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\n\nfunction PublicKey(Q) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  if (typeof Q === 'string') {\n    var publicKey = PublicKey.fromString(Q, pubkey_prefix);\n    assert(publicKey != null, 'Invalid public key');\n    return publicKey;\n  } else if (Buffer.isBuffer(Q)) {\n    return PublicKey.fromBuffer(Q);\n  } else if ((0, _typeof2[\"default\"])(Q) === 'object' && Q.Q) {\n    return PublicKey(Q.Q);\n  }\n\n  assert.equal((0, _typeof2[\"default\"])(Q), 'object', 'Invalid public key');\n  assert.equal((0, _typeof2[\"default\"])(Q.compressed), 'boolean', 'Invalid public key');\n\n  function toBuffer() {\n    var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Q.compressed;\n    return Q.getEncoded(compressed);\n  }\n\n  var pubdata; // cache\n  // /**\n  //     @todo secp224r1\n  //     @return {string} PUB_K1_base58pubkey..\n  // */\n  // function toString() {\n  //     if(pubdata) {\n  //         return pubdata\n  //     }\n  //     pubdata = `PUB_K1_` + keyUtils.checkEncode(toBuffer(), 'K1')\n  //     return pubdata;\n  // }\n\n  /** @todo rename to toStringLegacy\n   * @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n  */\n\n  function toString() {\n    var pubkey_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'EOS';\n    return pubkey_prefix + keyUtils.checkEncode(toBuffer());\n  }\n\n  function toUncompressed() {\n    var buf = Q.getEncoded(false);\n    var point = ecurve.Point.decodeFrom(secp256k1, buf);\n    return PublicKey.fromPoint(point);\n  }\n  /** @deprecated */\n\n\n  function child(offset) {\n    console.error('Deprecated warning: PublicKey.child');\n    assert(Buffer.isBuffer(offset), \"Buffer required: offset\");\n    assert.equal(offset.length, 32, \"offset length\");\n    offset = Buffer.concat([toBuffer(), offset]);\n    offset = hash.sha256(offset);\n    var c = BigInteger.fromBuffer(offset);\n    if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n    var cG = G.multiply(c);\n    var Qprime = Q.add(cG);\n    if (secp256k1.isInfinity(Qprime)) throw new Error(\"Child offset derived to an invalid key, try again\");\n    return PublicKey.fromPoint(Qprime);\n  }\n\n  function toHex() {\n    return toBuffer().toString('hex');\n  }\n\n  return {\n    Q: Q,\n    toString: toString,\n    // toStringLegacy,\n    toUncompressed: toUncompressed,\n    toBuffer: toBuffer,\n    child: child,\n    toHex: toHex\n  };\n}\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} pubkey - public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\n\n\nPublicKey.isValid = function (pubkey) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  try {\n    PublicKey(pubkey, pubkey_prefix);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nPublicKey.fromBinary = function (bin) {\n  return PublicKey.fromBuffer(new Buffer(bin, 'binary'));\n};\n\nPublicKey.fromBuffer = function (buffer) {\n  return PublicKey(ecurve.Point.decodeFrom(secp256k1, buffer));\n};\n\nPublicKey.fromPoint = function (point) {\n  return PublicKey(point);\n};\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n    @return PublicKey or `null` (invalid)\n*/\n\n\nPublicKey.fromString = function (public_key) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  try {\n    return PublicKey.fromStringOrThrow(public_key, pubkey_prefix);\n  } catch (e) {\n    return null;\n  }\n};\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n\n    @throws {Error} if public key is invalid\n\n    @return PublicKey\n*/\n\n\nPublicKey.fromStringOrThrow = function (public_key) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n  assert.equal((0, _typeof2[\"default\"])(public_key), 'string', 'public_key');\n  var match = public_key.match(/^PUB_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n\n  if (match === null) {\n    // legacy\n    var prefix_match = new RegExp(\"^\" + pubkey_prefix);\n\n    if (prefix_match.test(public_key)) {\n      public_key = public_key.substring(pubkey_prefix.length);\n    }\n\n    return PublicKey.fromBuffer(keyUtils.checkDecode(public_key));\n  }\n\n  assert(match.length === 3, 'Expecting public key like: PUB_K1_base58pubkey..');\n\n  var _match = (0, _slicedToArray2[\"default\"])(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 private key expected');\n  return PublicKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n\nPublicKey.fromHex = function (hex) {\n  return PublicKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPublicKey.fromStringHex = function (hex) {\n  return PublicKey.fromString(new Buffer(hex, 'hex'));\n};","map":{"version":3,"sources":["C:/Users/naman.chopra/Git-Repo/eosiodemo/OrderEntryReactDemo/node_modules/eosjs-ecc/lib/key_public.js"],"names":["_interopRequireDefault","require","_slicedToArray2","_typeof2","assert","ecurve","BigInteger","secp256k1","getCurveByName","hash","keyUtils","G","n","module","exports","PublicKey","Q","pubkey_prefix","arguments","length","undefined","publicKey","fromString","Buffer","isBuffer","fromBuffer","equal","compressed","toBuffer","getEncoded","pubdata","toString","checkEncode","toUncompressed","buf","point","Point","decodeFrom","fromPoint","child","offset","console","error","concat","sha256","c","compareTo","Error","cG","multiply","Qprime","add","isInfinity","toHex","isValid","pubkey","e","fromBinary","bin","buffer","public_key","fromStringOrThrow","match","prefix_match","RegExp","test","substring","checkDecode","_match","keyType","keyString","fromHex","hex","fromStringHex"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar assert = require('assert');\n\nvar ecurve = require('ecurve');\n\nvar BigInteger = require('bigi');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1');\n\nvar hash = require('./hash');\n\nvar keyUtils = require('./key_utils');\n\nvar G = secp256k1.G;\nvar n = secp256k1.n;\nmodule.exports = PublicKey;\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\n\nfunction PublicKey(Q) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  if (typeof Q === 'string') {\n    var publicKey = PublicKey.fromString(Q, pubkey_prefix);\n    assert(publicKey != null, 'Invalid public key');\n    return publicKey;\n  } else if (Buffer.isBuffer(Q)) {\n    return PublicKey.fromBuffer(Q);\n  } else if ((0, _typeof2[\"default\"])(Q) === 'object' && Q.Q) {\n    return PublicKey(Q.Q);\n  }\n\n  assert.equal((0, _typeof2[\"default\"])(Q), 'object', 'Invalid public key');\n  assert.equal((0, _typeof2[\"default\"])(Q.compressed), 'boolean', 'Invalid public key');\n\n  function toBuffer() {\n    var compressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Q.compressed;\n    return Q.getEncoded(compressed);\n  }\n\n  var pubdata; // cache\n  // /**\n  //     @todo secp224r1\n  //     @return {string} PUB_K1_base58pubkey..\n  // */\n  // function toString() {\n  //     if(pubdata) {\n  //         return pubdata\n  //     }\n  //     pubdata = `PUB_K1_` + keyUtils.checkEncode(toBuffer(), 'K1')\n  //     return pubdata;\n  // }\n\n  /** @todo rename to toStringLegacy\n   * @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n  */\n\n  function toString() {\n    var pubkey_prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'EOS';\n    return pubkey_prefix + keyUtils.checkEncode(toBuffer());\n  }\n\n  function toUncompressed() {\n    var buf = Q.getEncoded(false);\n    var point = ecurve.Point.decodeFrom(secp256k1, buf);\n    return PublicKey.fromPoint(point);\n  }\n  /** @deprecated */\n\n\n  function child(offset) {\n    console.error('Deprecated warning: PublicKey.child');\n    assert(Buffer.isBuffer(offset), \"Buffer required: offset\");\n    assert.equal(offset.length, 32, \"offset length\");\n    offset = Buffer.concat([toBuffer(), offset]);\n    offset = hash.sha256(offset);\n    var c = BigInteger.fromBuffer(offset);\n    if (c.compareTo(n) >= 0) throw new Error(\"Child offset went out of bounds, try again\");\n    var cG = G.multiply(c);\n    var Qprime = Q.add(cG);\n    if (secp256k1.isInfinity(Qprime)) throw new Error(\"Child offset derived to an invalid key, try again\");\n    return PublicKey.fromPoint(Qprime);\n  }\n\n  function toHex() {\n    return toBuffer().toString('hex');\n  }\n\n  return {\n    Q: Q,\n    toString: toString,\n    // toStringLegacy,\n    toUncompressed: toUncompressed,\n    toBuffer: toBuffer,\n    child: child,\n    toHex: toHex\n  };\n}\n/**\n  @param {string|Buffer|PublicKey|ecurve.Point} pubkey - public key\n  @param {string} [pubkey_prefix = 'EOS']\n*/\n\n\nPublicKey.isValid = function (pubkey) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  try {\n    PublicKey(pubkey, pubkey_prefix);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nPublicKey.fromBinary = function (bin) {\n  return PublicKey.fromBuffer(new Buffer(bin, 'binary'));\n};\n\nPublicKey.fromBuffer = function (buffer) {\n  return PublicKey(ecurve.Point.decodeFrom(secp256k1, buffer));\n};\n\nPublicKey.fromPoint = function (point) {\n  return PublicKey(point);\n};\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n    @return PublicKey or `null` (invalid)\n*/\n\n\nPublicKey.fromString = function (public_key) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n\n  try {\n    return PublicKey.fromStringOrThrow(public_key, pubkey_prefix);\n  } catch (e) {\n    return null;\n  }\n};\n/**\n    @arg {string} public_key - like PUB_K1_base58pubkey..\n    @arg {string} [pubkey_prefix = 'EOS'] - public key prefix\n\n    @throws {Error} if public key is invalid\n\n    @return PublicKey\n*/\n\n\nPublicKey.fromStringOrThrow = function (public_key) {\n  var pubkey_prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'EOS';\n  assert.equal((0, _typeof2[\"default\"])(public_key), 'string', 'public_key');\n  var match = public_key.match(/^PUB_([A-Za-z0-9]+)_([A-Za-z0-9]+)$/);\n\n  if (match === null) {\n    // legacy\n    var prefix_match = new RegExp(\"^\" + pubkey_prefix);\n\n    if (prefix_match.test(public_key)) {\n      public_key = public_key.substring(pubkey_prefix.length);\n    }\n\n    return PublicKey.fromBuffer(keyUtils.checkDecode(public_key));\n  }\n\n  assert(match.length === 3, 'Expecting public key like: PUB_K1_base58pubkey..');\n\n  var _match = (0, _slicedToArray2[\"default\"])(match, 3),\n      keyType = _match[1],\n      keyString = _match[2];\n\n  assert.equal(keyType, 'K1', 'K1 private key expected');\n  return PublicKey.fromBuffer(keyUtils.checkDecode(keyString, keyType));\n};\n\nPublicKey.fromHex = function (hex) {\n  return PublicKey.fromBuffer(new Buffer(hex, 'hex'));\n};\n\nPublicKey.fromStringHex = function (hex) {\n  return PublicKey.fromString(new Buffer(hex, 'hex'));\n};"]},"metadata":{},"sourceType":"script"}