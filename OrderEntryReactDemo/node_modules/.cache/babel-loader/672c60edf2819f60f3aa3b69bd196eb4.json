{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\naman.chopra\\\\Git-Repo\\\\eosiodemo\\\\OrderEntryReactDemo\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport { Numeric, Serialize } from 'eosjs';\nimport * as ecc from 'eosjs-ecc';\nimport makeFetch from 'fetch-ponyfill';\nimport linkAbi from './link-abi-data';\n/** @internal */\n\nexport var fetch = makeFetch().fetch;\n/** @internal */\n\nvar types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), linkAbi);\n/**\n * Helper to ABI encode value.\n * @internal\n */\n\nexport function abiEncode(value, typeName) {\n  var type = types.get(typeName);\n\n  if (!type) {\n    throw new Error(\"No such type: \".concat(typeName));\n  }\n\n  var buf = new Serialize.SerialBuffer();\n  type.serialize(buf, value);\n  return buf.asUint8Array();\n}\n/**\n * Helper to ABI decode data.\n * @internal\n */\n\nexport function abiDecode(data, typeName) {\n  var type = types.get(typeName);\n\n  if (!type) {\n    throw new Error(\"No such type: \".concat(typeName));\n  }\n\n  if (typeof data === 'string') {\n    data = Serialize.hexToUint8Array(data);\n  } else if (!(data instanceof Uint8Array)) {\n    data = new Uint8Array(data);\n  }\n\n  var buf = new Serialize.SerialBuffer({\n    array: data\n  });\n  return type.deserialize(buf);\n}\n/**\n * Encrypt a message using AES and shared secret derived from given keys.\n * @internal\n */\n\nexport function sealMessage(message, privateKey, publicKey) {\n  var res = ecc.Aes.encrypt(privateKey, publicKey, message);\n  var data = {\n    from: ecc.privateToPublic(privateKey),\n    nonce: res.nonce.toString(),\n    ciphertext: res.message,\n    checksum: res.checksum\n  };\n  return abiEncode(data, 'sealed_message');\n}\n/**\n * Ensure public key is in new PUB_ format.\n * @internal\n */\n\nexport function normalizePublicKey(key) {\n  if (key.startsWith('PUB_')) {\n    return key;\n  }\n\n  return Numeric.publicKeyToString(Numeric.stringToPublicKey('EOS' + key.substr(-50)));\n}\n/**\n * Return true if given public keys are equal.\n * @internal\n */\n\nexport function publicKeyEqual(keyA, keyB) {\n  return normalizePublicKey(keyA) === normalizePublicKey(keyB);\n}\n/**\n * Generate a random private key.\n * Uses browser crypto if available, otherwise falls back to slow eosjs-ecc.\n * @internal\n */\n\nexport function generatePrivateKey() {\n  return _generatePrivateKey.apply(this, arguments);\n}\n\nfunction _generatePrivateKey() {\n  _generatePrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var data;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(typeof window !== 'undefined' && window.crypto)) {\n              _context.next = 6;\n              break;\n            }\n\n            data = new Uint32Array(32);\n            window.crypto.getRandomValues(data);\n            return _context.abrupt(\"return\", ecc.PrivateKey.fromBuffer(Buffer.from(data)).toString());\n\n          case 6:\n            _context.next = 8;\n            return ecc.randomKey();\n\n          case 8:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _generatePrivateKey.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Numeric, Serialize } from 'eosjs';\nimport * as ecc from 'eosjs-ecc';\nimport makeFetch from 'fetch-ponyfill';\nimport linkAbi from './link-abi-data';\n/** @internal */\nexport const fetch = makeFetch().fetch;\n/** @internal */\nconst types = Serialize.getTypesFromAbi(Serialize.createInitialTypes(), linkAbi);\n/**\n * Helper to ABI encode value.\n * @internal\n */\nexport function abiEncode(value, typeName) {\n    let type = types.get(typeName);\n    if (!type) {\n        throw new Error(`No such type: ${typeName}`);\n    }\n    let buf = new Serialize.SerialBuffer();\n    type.serialize(buf, value);\n    return buf.asUint8Array();\n}\n/**\n * Helper to ABI decode data.\n * @internal\n */\nexport function abiDecode(data, typeName) {\n    let type = types.get(typeName);\n    if (!type) {\n        throw new Error(`No such type: ${typeName}`);\n    }\n    if (typeof data === 'string') {\n        data = Serialize.hexToUint8Array(data);\n    }\n    else if (!(data instanceof Uint8Array)) {\n        data = new Uint8Array(data);\n    }\n    let buf = new Serialize.SerialBuffer({\n        array: data,\n    });\n    return type.deserialize(buf);\n}\n/**\n * Encrypt a message using AES and shared secret derived from given keys.\n * @internal\n */\nexport function sealMessage(message, privateKey, publicKey) {\n    const res = ecc.Aes.encrypt(privateKey, publicKey, message);\n    const data = {\n        from: ecc.privateToPublic(privateKey),\n        nonce: res.nonce.toString(),\n        ciphertext: res.message,\n        checksum: res.checksum,\n    };\n    return abiEncode(data, 'sealed_message');\n}\n/**\n * Ensure public key is in new PUB_ format.\n * @internal\n */\nexport function normalizePublicKey(key) {\n    if (key.startsWith('PUB_')) {\n        return key;\n    }\n    return Numeric.publicKeyToString(Numeric.stringToPublicKey('EOS' + key.substr(-50)));\n}\n/**\n * Return true if given public keys are equal.\n * @internal\n */\nexport function publicKeyEqual(keyA, keyB) {\n    return normalizePublicKey(keyA) === normalizePublicKey(keyB);\n}\n/**\n * Generate a random private key.\n * Uses browser crypto if available, otherwise falls back to slow eosjs-ecc.\n * @internal\n */\nexport async function generatePrivateKey() {\n    if (typeof window !== 'undefined' && window.crypto) {\n        const data = new Uint32Array(32);\n        window.crypto.getRandomValues(data);\n        return ecc.PrivateKey.fromBuffer(Buffer.from(data)).toString();\n    }\n    else {\n        return await ecc.randomKey();\n    }\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}